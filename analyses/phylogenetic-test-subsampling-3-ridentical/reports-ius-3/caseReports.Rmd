---
title: "SARS-CoV-2 State Introductions"
subtitle: "Importation Summary for states"
date: "`r format(Sys.time(), 'Last modified: %d %b %Y')`"
output:
  pdf_document:
    toc: yes
    toc_depth: 3
    number_sections: yes
    keep_tex: no
    fig_crop: no
  html_document:
    toc: yes
    toc_depth: '3'
    df_print: paged
layout: page
editor_options:
  chunk_output_type: inline
params:
  inputpath: "../../../data/phylogenetic-test-subsampling-1/"
  casefile: "../data/cases-rki-by-state.csv"
  infectionfile: "../../../data/epidemiological/flaxman-results.csv"
  epimobilitypath: "../../epidemiological/results/"
  asymptomatic: 31
  cluster_f: DTA
  alpha: 0.7189865
  beta: 28.91369
  startDate: '2020-10-01'
  endDate: '2021-06-01'
  device: pdf
  metadata: "../../../../data/data/gisaid-20210602-metadata.tsv"
  outputfolder: "../results/beast/run/lin-ius-3/"
  caseData: "../data/time_series_covid19_confirmed_global.csv"
  caseDataGermany: "../data/cases-rki-by-state.csv"
  metadataAllSequences   : "../../../../data/data/gisaid-20210602-metadata.tsv"

---


```{r rsetup, include=FALSE}

  # metadata        : "../results/gisaid-20210602-metadata-sampled-unsampled.tsv"
  # outputpath      : "../results/trees-gisaid-Hamburg-20210417-lin-rich/"
  # state           : "Hamburg"
  
    library(lubridate)
    library(dplyr)
    library(gplots)
    library(beastio)
    library(knitr)
    library(tictoc)
    library(stringr)
    library(tidyr)
    library(colorspace)
    library(gpclib)
    library(ggplot2)
    library(rgeos)
    library(maptools)
    gpclibPermit()
    library(grid)

    source("../reports/palettes.R")
    source("../reports/plotutils.R")
    source("../reports/clusterutils.R")
    source("../reports/reportutils.R")

    inputpath    <- params$inputpath
    casefile     <- params$casefile
    infectionfile<- params$infectionfile
    epipath      <- params$epimobilitypath
    mobilitypath <- params$epimobilitypath
    asymptomatic <- params$asymptomatic
    cluster_f    <- params$cluster_f
    alpha        <- params$alpha
    beta         <- params$beta
    
    startDate    <- as.Date(params$startDate)
    endDate      <- as.Date(params$endDate)
  
    outputfolder <- params$outputfolder

    figpath      <- paste0(outputfolder, "figures/importation_figures_", params$device, "/")
    dir.create(figpath, recursive = TRUE, showWarnings = FALSE)
    
    cachepath  <- paste0(outputfolder, "figures/cache/importationSummary_", params$device, "/")


    knitr::opts_chunk$set(tidy=FALSE, cache=FALSE, cache.path = cachepath,
                          dev=params$device, fig.path=figpath, dpi=300,
                          message=FALSE, error=TRUE, warning=TRUE, echo=FALSE)
    
    metadata <- load_metadata(params$metadata)
    
    metadataAllSequences <- load_metadata(params$metadataAllSequences)


    stateFiles = data.frame(state = c("Germany"), 
                            state.name = c("Germany"),
                            adm.level = c(2),
                            outputpath=c("../results/beast/run/lin-ius-3/") )
                            # outputpath=c("../results/beast/run/lin/") )
                            # outputpath=c("../results/beast/run/lin-rich-sk/") )
    stateInfo <- list()
    stateInfo$metadata_instate <- data.frame(matrix(0, nrow=nrow(metadata), ncol=0))
    for (i in 1:nrow(stateFiles)) {
      state <- stateFiles$state[i]
      state.name <- stateFiles$state.name[i]
      # DEBUG TODO
      #stateInfo$metadata_instate <- cbind(stateInfo$metadata_instate, rep(FALSE, nrow(metadata)))
      if (stateFiles$adm.level[i] == 3)
        stateInfo$metadata_instate <- cbind(stateInfo$metadata_instate, set_instate(metadata, state.name))
      else if (stateFiles$adm.level[i] == 2)
        stateInfo$metadata_instate <- cbind(stateInfo$metadata_instate, metadata$country == state)
      colnames(stateInfo$metadata_instate)[ncol(stateInfo$metadata_instate)] <- state
    }

    stateInfo$stateOrder <- c(1)
    
    case_data <- load_case_data(params$caseData)
    
    # for comments and documents before codes.
    states <- paste(stateFiles$state)

    rsumstate <- function(f) {
      return(sapply(seq(nrow(stateFiles)), function(s) { return (paste(stateFiles$state[s], ":", f(stateFiles$state[s], s, stateInfo$clusterStatsMCC[[s]]))); }))
    }

    deCountyDaily <- getDeCountyDaily(params$caseDataGermany, "../data/germany-subdivisions.csv", metadata)

    deCounty <- getDeInfo("../data/germany-data.csv", deCountyDaily, as.Date("2020-10-01"))
    
```




```{r load-data, cache=TRUE}
    
    stateInfo$clusterStatsMCC <- stateInfo$clusterSamplesMCC <- list()
    for (i in 1:nrow(stateFiles)) {
      state <- stateFiles$state[i]
      outputpath <- stateFiles$outputpath[i]
      
    
    # clusterStats      <- read.csv(paste0(outputpath, "clusters_", cluster_f, ".csv"))
    # clusterStatsMCC   <- read.csv(paste0(outputpath, "clusters_", cluster_f, "_MCC_0.5.csv"))
    clusterStatsMCC   <- read.table(paste0(outputpath, "clusters_", cluster_f, "_MCC_0.5.tsv"), sep="\t", head=TRUE, na.strings=c("NA", ""), fill=TRUE, stringsAsFactors=FALSE, quote="|")
    # clusterStatsMCC   <- read.csv(paste0(outputpath, "clusters_", cluster_f, "_MCC_NA.csv"))
    # clusterSamples    <- read.csv(paste0(outputpath, "clusterSamples_", cluster_f, ".csv"))
    # clusterSamplesMCC <- read.csv(paste0(outputpath, "clusterSamples_", cluster_f, "_MCC_0.5.csv"))
    # clusterSamplesMCC <- read.csv(paste0(outputpath, "clusterSamples_", cluster_f, "_MCC_NA.csv"))
      clusterSamplesMCC <- read.table(paste0(outputpath, "clusterSamples_", cluster_f, "_MCC_0.5.tsv"), sep="\t", head=TRUE, na.strings=c("NA", ""), fill=TRUE, stringsAsFactors=FALSE, quote="|")

      clusterStatsMCC$cluster <- sapply(clusterStatsMCC$cluster, function(cluster) paste(strsplit( gsub("-", "_", cluster), split="_")[[1]][c(3,6,7)], collapse="_"))
      clusterSamplesMCC$cluster <- sapply(clusterSamplesMCC$cluster, function(cluster) paste(strsplit( gsub("-", "_", cluster), split="_")[[1]][c(3,6,7)], collapse="_"))

    
    clusterSamplesMCC$cluster <- clusterSamplesMCC$cutoff_NA
    clusterSamplesMCC$country  <- sapply(strsplit(clusterSamplesMCC$Location, '/'), function(x) str_trim(x[2]))
    # clusterSamplesMCC$state    <- str_trim(sapply(str_split(paste0(clusterSamplesMCC$Location,"/",clusterSamplesMCC$Additional.location.information), "/"), "[[", 3))
    clusterSamplesMCC$instate    <-  set_instate(clusterSamplesMCC, state)    
    # 
    # clusterStatsMCC_75   <- read.csv(paste0(outputpath, "clusters_", cluster_f, "_MCC_0.75.csv"))
    # clusterStatsMCC_95   <- read.csv(paste0(outputpath, "clusters_", cluster_f, "_MCC_0.95.csv"))
   clusterSamplesMCC$adm1 <- sapply(
  str_split(paste0(clusterSamplesMCC$Location,"/",clusterSamplesMCC$Additional.location.information), "/"), function(x) str_trim(x[3]) )
   clusterSamplesMCC$adm1 <- ifelse(clusterSamplesMCC$adm1 == "Baden-WÃ¼rttemberg", "Baden-Wurttemberg", clusterSamplesMCC$adm1)

    
    # Convert dates to POSIX dates
    # clusterStats$tmrca_calendar    <- ymd(clusterStats$tmrca_calendar)
    clusterStatsMCC$tmrca_calendar <- ymd(clusterStatsMCC$tmrca_calendar)
    clusterSamplesMCC$sample_date  <- ymd(clusterSamplesMCC$sample_date)
    # 
    # clusterStatsMCC_75$tmrca_calendar <- ymd(clusterStatsMCC_75$tmrca_calendar)
    # clusterStatsMCC_95$tmrca_calendar <- ymd(clusterStatsMCC_95$tmrca_calendar)


    # Lineage sampling durations
    clusterStatsMCC$duration <- round(366*(clusterStatsMCC$mostrecent - clusterStatsMCC$oldest))
    # clusterStats$duration    <- round(366*(clusterStats$mostrecent - clusterStats$oldest))

    clusterStatsMCC$shift <- alpha + beta/clusterStatsMCC$seqs
   clusterStatsMCC$tmrca_shifted <- clusterStatsMCC$tmrca - (clusterStatsMCC$shift/366)
   clusterStatsMCC$tmrca_shifted_calendar <- as.Date(round_date(date_decimal(clusterStatsMCC$tmrca_shifted), unit = "day"))
   clusterStatsMCC$detection_lag <- as.Date(round_date(date_decimal(clusterStatsMCC$oldest), unit = "day")) - clusterStatsMCC$tmrca_shifted_calendar
    
   stateInfo$clusterStatsMCC[[i]] = clusterStatsMCC
   stateInfo$clusterSamplesMCC[[i]] = clusterSamplesMCC
      
    
   ############################################
   # Germany weekly cases and estimated infections #
   ############################################

   deCases <- data.frame(case = unlist(case_data$data[state, case_data$date >= startDate & case_data$date < endDate-6]), 
                         date = case_data$date[case_data$date >= startDate & case_data$date < endDate-6])

   # europeInfections      <- read.csv(infectionfile)
   # europeInfections$time <- as.Date(europeInfections$time)

   weekBreaks <- seq.Date(startDate, endDate, by="weeks")
   deWeekly   <- data.frame(date       = weekBreaks[2:length(weekBreaks)],
                            seqs       = hist(metadata$sample_date[metadata$country == state & metadata$sample_date >= startDate & metadata$sample_date < endDate], breaks=weekBreaks, plot=FALSE, right=FALSE)$counts,
                            cases      = getHistogram(deCases$date, deCases$case,
                                                      breaks=weekBreaks, maxDate = endDate)$counts
                            # infections = getHistogram(europeInfections$time[europeInfections$country == "United_Kingdom"],
                            #                           europeInfections$predicted_infections_mean[europeInfections$country == "United_Kingdom"],
                            #                           breaks=weekBreaks)$counts,
                            # infectionsLower = getHistogram(europeInfections$time[europeInfections$country == "United_Kingdom"],
                            #                                europeInfections$predicted_infections_lower_CI_95[europeInfections$country == "United_Kingdom"],
                            #                                breaks=weekBreaks)$counts,
                            # infectionsUpper = getHistogram(europeInfections$time[europeInfections$country == "United_Kingdom"],
                            #                                europeInfections$predicted_infections_higher_CI_95_cumulative.1[europeInfections$country == "United_Kingdom"],
                            #                                breaks=weekBreaks)$counts
                            )
   deWeekly$seqsCum       <- cumsum(deWeekly$seqs)
   deWeekly$casesCum      <- cumsum(deWeekly$cases)
   # ukWeekly$infectionsCum <- cumsum(ukWeekly$infections)
   # ukWeekly$infectionsLowerCum <- cumsum(ukWeekly$infectionsLower)
   # ukWeekly$infectionsUpperCum <- cumsum(ukWeekly$infectionsUpper)


   dayBreaks <- seq.Date(startDate, endDate, by="day")
   deDaily   <- data.frame(date       = dayBreaks[2:length(dayBreaks)],
                            seqs       = hist(metadata$sample_date[metadata$country == state & metadata$sample_date >= startDate & metadata$sample_date < endDate], breaks=dayBreaks, plot=FALSE, right=FALSE)$counts,
                            cases      = getHistogram(deCases$date, deCases$case,
                                                      breaks=dayBreaks, maxDate = endDate)$counts
                            # infections = getHistogram(europeInfections$time[europeInfections$country == "United_Kingdom"],
                            #                           europeInfections$predicted_infections_mean[europeInfections$country == "United_Kingdom"],
                            #                           breaks=dayBreaks)$counts,
                            # infectionsLower = getHistogram(europeInfections$time[europeInfections$country == "United_Kingdom"],
                            #                                europeInfections$predicted_infections_lower_CI_95[europeInfections$country == "United_Kingdom"],
                            #                                breaks=dayBreaks)$counts,
                            # infectionsUpper = getHistogram(europeInfections$time[europeInfections$country == "United_Kingdom"],
                            #                                europeInfections$predicted_infections_higher_CI_95_cumulative.1[europeInfections$country == "United_Kingdom"],
                            #                                breaks=dayBreaks)$counts)
                        )
   deDaily$seqsCum       <- cumsum(deDaily$seqs)
   deDaily$casesCum      <- cumsum(deDaily$cases)
   # ukDaily$infectionsCum <- cumsum(ukDaily$infections)
   # ukDaily$infectionsLowerCum <- cumsum(ukDaily$infectionsLower)
   # ukDaily$infectionsUpperCum <- cumsum(ukDaily$infectionsUpper)
   
   

#    #######
#    # EII #
#    #######
#    
#    eii      <- read.csv(paste0(epipath, "estimated-introduction-index-", asymptomatic, ".csv"))
#    eii$date <- as.Date(eii$date)
#    colnames(eii)[2] <- "location"
#    eii$location <- revalue(eii$location, c("other"="Other"))
#
#    countryList <- levels(eii$location)
#    countryList <- countryList[-which(countryList == "Other")]
#    
#    dates  <- sort(unique(eii$date))
#    eiiAll <- data.frame(date       = dates, 
#                         location   = rep("all", length(dates)),
#                         num_intros = sapply(dates, function(x) sum(eii$num_intros[eii$date == x])))
#    
#    eii <- rbind(eiiAll, eii)
#
#    # plot(eii$date[eii$location == "all"], eii$num_intros[eii$location == "all"], type='l')
#    # lines(eii$date[eii$location == "Spain"], eii$num_intros[eii$location == "Spain"], type='l', lty=2)
#    # lines(eii$date[eii$location == "France"], eii$num_intros[eii$location == "France"], type='l', lty=2)
#    
#    
#    #########################################
#    # Estimated daily numbers of infections #
#    #########################################
#    
#    infections <- read.csv(paste0(epipath, "estimated-daily-infections.csv"))
#    infections$date <- as.Date(infections$date)
#    
#    infectionsSpecific <- remove <- c()
#    for (country in countryList) {
#      mask   <- which(infections$location == country)
#      remove <- c(remove, mask)
#      infectionsSpecific <- rbind(infectionsSpecific, infections[mask, ])
#    }
#    infectionsSpecific$location <- as.character(infectionsSpecific$location)
#    
#    dates <- sort(unique(infections$date))
#    infectionsAll <- data.frame(date     = dates, 
#                                num_infs = sapply(dates, function(x) sum(infections$num_infs[infections$date == x])),
#                                location = rep("all", length(dates)))
#    
#    infections <- infections[-remove, ]
#    infectionsOther <- data.frame(date     = dates, 
#                                  num_infs = sapply(dates, function(x) sum(infections$num_infs[infections$date == x])),
#                                  location = rep("Other", length(dates)))
#    
#    infections <- rbind(infectionsAll, rbind(infectionsSpecific, infectionsOther))
#    
#    # Smooth with 7-day rolling mean
#    infections$num_infs_smoothed <- rep(0, nrow(infections))
#    for (country in levels(infections$location)) {
#      
#      mask      <- which(infections$location == country)
#      dateOrder <- mask[order(infections$date[mask])]
#      
#      infections$num_infs_smoothed[dateOrder] <- sapply(1:length(dateOrder), function(i) mean(infections$num_infs[dateOrder[max(i-3,1):min(i+3, length(dateOrder))]], na.rm = TRUE))
#    }
#    
#    # Total number of infected in each country by the end of the dataset
#    totalInfected <- sort(sapply(levels(infections$location), function(x) sum(infections$num_infs[infections$location == x], na.rm=TRUE)), decreasing = TRUE)
#    
#    # loc <- "Switzerland"
#    # plot(infections$date[infections$location == loc], infections$num_infs[infections$location == loc], type='l', lty=2)
#    # lines(infections$date[infections$location == loc], infections$num_infs_smoothed[infections$location == loc])
#    
#    
#    ############################
#    # Estimated daily arrivals #
#    ############################
#       
#    arrivals <- read.csv(paste0(epipath, "estimated-arrivals.csv"))
#    arrivals$date    <- as.Date(arrivals$date)
#    arrivals$location <- revalue(arrivals$location, c("United States"  = "US",
#                                                      "Czech Republic" = "Czechia",
#                                                      "Dominican Rep"  = "Dominican Republic", 
#                                                      "Korea (South)"  = "Korea, South"))
#    
#    arrivalsSpecific <- remove <- c()
#    for (country in countryList) {
#      mask   <- which(arrivals$location == country)
#      remove <- c(remove, mask)
#      arrivalsSpecific <- rbind(arrivalsSpecific, arrivals[mask, c("date", "location", "estimate")])
#    }
#    arrivalsSpecific$location <- as.character(arrivalsSpecific$location)
#    
#    dates <- sort(unique(arrivals$date))
#    arrivalsAll <- data.frame(date     = dates, 
#                              location = rep("all", length(dates)),
#                              estimate = sapply(dates, function(x) sum(arrivals$estimate[arrivals$date == x])))
#    
#    arrivals <- arrivals[-remove, ]
#    arrivalsOther <- data.frame(date     = dates, 
#                                location = rep("Other", length(dates)),
#                                estimate = sapply(dates, function(x) sum(arrivals$estimate[arrivals$date == x])))
#    
#    arrivals <- rbind(arrivalsAll, rbind(arrivalsSpecific, arrivalsOther))
#    
#    # Smooth with 7-day rolling mean
#    arrivals$estimate_smoothed <- rep(0, nrow(arrivals))
#    for (country in levels(arrivals$location)) {
#      
#      mask      <- which(arrivals$location == country)
#      dateOrder <- mask[order(arrivals$date[mask])]
#      
#      arrivals$estimate_smoothed[dateOrder] <- sapply(1:length(dateOrder), function(i) mean(arrivals$estimate[dateOrder[max(i-3,1):min(i+3, length(dateOrder))]], na.rm = TRUE))
#    }
#    
#    # plot(arrivals$date[arrivals$location == "Spain"], arrivals$estimate[arrivals$location == "Spain"], type='l')
#    #lines(arrivals$date[arrivals$location == "Spain"], arrivals$estimate_smoothed[arrivals$location == "Spain"], type='l', lty=2)
#    #lines(arrivals$date[arrivals$location == "France"], arrivals$estimate[arrivals$location == "France"], type='l', lty=2)
#    
#    
#    #################################
#    # Lag model parameter estimates #
#    #################################
    
    # lagmodel <- read.csv(paste0(epipath, "tree-varying-lag-estimates.csv"))
    
    }

```

\clearpage

# `r states` Sequenced Genomes


```{r sample-histogram, fig.width=7, fig.height=3, fig.cap = "Collection dates of the `nrow(metadata)` genomes analysed here (left-hand axis). Genomes are coloured by sampling location."}

   sampleBreaks <- seq.Date(startDate, 
                            max(metadata$sample_date_orig, na.rm = TRUE)+1, by="1 day")

   seq_hist_oth <- hist(metadata$sample_date_orig[metadata$sample_date_orig> startDate],
                        breaks=sampleBreaks, plot=FALSE, right=FALSE)
   
   seq_hist_names <- c()
   seq_hist_breakdown <- data.frame(matrix(0, nrow=length(seq_hist_oth$counts), ncol=0))
   
   # seq_hist_names <- c(seq_hist_names, "all")
   # seq_hist_breakdown <- cbind(seq_hist_breakdown, seq_hist_oth$counts)
   
   for (s in 1:nrow(stateFiles)) {
      state <- stateFiles$state[s]
      seq_hist_state <- hist(metadata$sample_date_orig[stateInfo$metadata_instate[s] & metadata$sample_date_orig> startDate], 
                       breaks=sampleBreaks, plot=FALSE, right=FALSE)
      
      seq_hist_breakdown <- cbind(seq_hist_breakdown, seq_hist_state$count)
      seq_hist_names <- c(seq_hist_names, state)

      seq_hist_state <- hist(metadata$sample_date_orig[!stateInfo$metadata_instate[s] & metadata$sample_date_orig> startDate], 
                       breaks=sampleBreaks, plot=FALSE, right=FALSE)
      
      seq_hist_breakdown <- cbind(seq_hist_breakdown, seq_hist_state$count)
      seq_hist_names <- c(seq_hist_names, paste("Non", state))
   }
   
   colnames(seq_hist_breakdown) <- seq_hist_names
   
   # seq_hist_eng <- hist(metadata$sample_date[metadata$adm1 == "UK-ENG"], breaks=sampleBreaks, plot=FALSE, right=FALSE)
   # seq_hist_sct <- hist(metadata$sample_date[metadata$adm1 == "UK-SCT"], breaks=sampleBreaks, plot=FALSE, right=FALSE)
   # seq_hist_wls <- hist(metadata$sample_date[metadata$adm1 == "UK-WLS"], breaks=sampleBreaks, plot=FALSE, right=FALSE)
   # seq_hist_nir <- hist(metadata$sample_date[metadata$adm1 == "UK-NIR"], breaks=sampleBreaks, plot=FALSE, right=FALSE)
   # seq_hist_oth <- hist(metadata$sample_date[metadata$country != "UK"],  breaks=sampleBreaks, plot=FALSE, right=FALSE)

                                    
   # seq_hist_breakdown <- data.frame("eng" = seq_hist_eng$counts,
   #                                  "sct" = seq_hist_sct$counts,
   #                                  "wls" = seq_hist_wls$counts,
   #                                  "nir" = seq_hist_nir$counts,
   #                                  "oth" = seq_hist_oth$counts)
   
   draw_seq_freq_states <- function(selected_names, ymax = NA) {
     
     selected_columns <- seq_hist_names %in% selected_names
     if (is.na(ymax)) {
        if (sum(selected_columns) > 1) {
           ymax = max(rowSums(seq_hist_breakdown[,selected_columns])) * 1.05
        } else {
           ymax = max(seq_hist_breakdown[,selected_columns]) * 1.05
        }
     }
     
     if (sum(selected_columns) == 1)
       pal <- dePal[which(names(dePal) == seq_hist_names[selected_columns])]
     else {
       pal <- dePal[match(seq_hist_names, names(dePal))]
       pal <- pal[selected_columns]
     }
     
     cat(paste(pal))
     
     dateFreqDistribution(t(seq_hist_breakdown[,selected_columns]), sampleBreaks, plot.ci=FALSE, barplot=TRUE,
                          startDate = sampleBreaks[1], 
                          endDate = sampleBreaks[length(sampleBreaks)-1],    
                          col=mPal(unlist(pal), 0.75), border=mPal(unlist(pal)), ymax=ymax,
                          ylab = "Frequency of genomes\n(per day)")
     
     
     legend("top", horiz=FALSE, inset=c(0,-0.3), bty='n', xpd=TRUE, ncol=3,
            fill=mPal(unlist(pal), 0.75), border = mPal(unlist(pal)),
            legend = seq_hist_names[selected_columns],
            # legend = c("Germany", "Other countries"),
            #legend = c("England", "Scotland", "Wales"#FF7F00, "Northern Ireland", "Other countries"),
            cex=0.8)
     
   }
   
   # Sequence histogram
   par(mar=c(4,6,2.5,6), cex.axis=0.7, cex.lab=0.8, mgp=c(3,0.75,0))
   draw_seq_freq_states(c("Germany", "Non Germany"))
   draw_seq_freq_states(c("Germany"), ymax=max(seq_hist_breakdown[, "Germany"]) * 1.05)
   ymax=400 * 1.05
   # draw_seq_freq_states(c("Hamburg"), ymax=ymax)
   # draw_seq_freq_states(c("Bavaria"), ymax=ymax)
   # draw_seq_freq_states(c("North_Rhine-Westphalia"), ymax=ymax)
   # draw_seq_freq_states(c("Saarland"), ymax=ymax)
   # # draw_seq_freq_states(c("Saxony"))
   # draw_seq_freq_states(c("Lower_Saxony"), ymax=ymax)
   # 
   # draw_seq_freq_states(c("Munich"), ymax=ymax)
   # draw_seq_freq_states(c("Dusseldorf"), ymax=ymax)

   # # dateFreqDistribution(t(seq_hist_breakdown), sampleBreaks, plot.ci=FALSE, barplot=TRUE,
   # #                      startDate = sampleBreaks[1], endDate = sampleBreaks[length(sampleBreaks)-1], col=mPal(unlist(ukPal)[1], 0.75), border=mPal(unlist(ukPal))[1], ymax=1100,
   # #                      ylab = "Frequency of genomes\n(per day)")
   # 
   # dateFreqDistribution(t(seq_hist_breakdown), sampleBreaks, plot.ci=FALSE, barplot=TRUE,
   #                      startDate = sampleBreaks[1], 
   #                      endDate = sampleBreaks[length(sampleBreaks)-1],    
   #                      col=mPal(unlist(dePal), 0.75), border=mPal(unlist(dePal)), ymax=max(seq_hist_breakdown)+2,
   #                      ylab = "Frequency of genomes\n(per day)")
   # 
   

      # 
   # legend("top", horiz=FALSE, inset=c(0,-0.3), bty='n', xpd=TRUE, ncol=3,
   #        fill=mPal(unlist(ukPal), 0.75), border = mPal(unlist(ukPal)),
   #        legend = seq_hist_names,
   #        # legend = c("Germany", "Other countries"),
   #        #legend = c("England", "Scotland", "Wales", "Northern Ireland", "Other countries"),
   #        cex=0.8)
   # 
   # dateFreqDistribution(t(seq_hist_breakdown), sampleBreaks, plot.ci=FALSE, barplot=TRUE,
   #                      startDate = sampleBreaks[1], 
   #                      endDate = sampleBreaks[length(sampleBreaks)-1],    
   #                      col=mPal(unlist(dePal), 0.75), border=mPal(unlist(dePal)), ymax=max(seq_hist_breakdown)+2,
   #                      ylab = "Frequency of genomes\n(per day)")
   # 
   # 
   # 
   # legend("top", horiz=FALSE, inset=c(0,-0.3), bty='n', xpd=TRUE, ncol=3,
   #        fill=mPal(unlist(ukPal), 0.75), border = mPal(unlist(ukPal)),
   #        legend = seq_hist_names,
   #        # legend = c("Germany", "Other countries"),
   #        #legend = c("England", "Scotland", "Wales", "Northern Ireland", "Other countries"),
   #        cex=0.8)

   
   
   #   seq_hist_breakdown <- data.frame("de" = seq_hist_de$counts)  
   #   
   #   dateFreqDistribution(t(seq_hist_breakdown), sampleBreaks, plot.ci=FALSE, barplot=TRUE,
   #                      startDate = sampleBreaks[1], endDate = sampleBreaks[length(sampleBreaks)-1], col=mPal(unlist(dePal)[1], 0.75), border=mPal(unlist(dePal))[1], ymax=max(seq_hist_breakdown)+2,
   #                      ylab = "Frequency of genomes\n(per day)")
   # 
   # 
   # legend("top", horiz=FALSE, inset=c(0,-0.3), bty='n', xpd=TRUE, ncol=3,
   #        fill=mPal(unlist(ukPal), 0.75), border = mPal(unlist(ukPal)),
   #        legend = c(state, "Other places"),
   #        # legend = c("Germany", "Other countries"),
   #        #legend = c("England", "Scotland", "Wales", "Northern Ireland", "Other countries"),
   #        cex=0.8)

   normalize_hist <- function(counts, breaks, normalization_break, normalization_value) {
     hist_index <- match(breaks[-length(breaks)], normalization_break)
     hist_weighted <- counts * normalization_value[hist_index]
     valid_index <- !is.na(hist_weighted) & !is.nan(hist_weighted)
     hist_weighted <- hist_weighted[valid_index]
     valid_index[max(which(valid_index))+1] <- TRUE
     hist_breaks <- breaks[valid_index]
     return (list("hist"=hist_weighted, "breaks"=hist_breaks));
   }
   
   # x <- normalize_hist(seq_hist_de$counts, sampleBreaks, case_data$date, case_data$case / case_data$seq_smooth)
   # seq_hist_de_weighted = x$hist;
   # sampleBreaks_weighted = x$breaks;
   # 
   # # hist_index <- match(sampleBreaks[-length(sampleBreaks)], case_data$date)
   # # seq_hist_de_weighted <- seq_hist_de$counts / case_data$seq_smooth[hist_index] * case_data$case[hist_index]
   # # 
   # # valid_index <- !is.na(seq_hist_de_weighted) & !is.nan(seq_hist_de_weighted)
   # # seq_hist_de_weighted <- seq_hist_de_weighted[valid_index]
   # # valid_index[max(which(valid_index))+1] <- TRUE
   # # sampleBreaks_weighted <- sampleBreaks[valid_index]
   # 
   # seq_hist_breakdown <- data.frame("de" = seq_hist_de_weighted)  
   # 
   # # dateFreqDistribution(t(seq_hist_breakdown), sampleBreaks_weighted, plot.ci=FALSE, barplot=TRUE,
   # #                      startDate = sampleBreaks_weighted[1], endDate = sampleBreaks_weighted[length(sampleBreaks_weighted)-1], col=mPal(unlist(dePal)[1], 0.75), border=mPal(unlist(dePal))[1], ymax=50000,
   # #                      ylab = "Frequency of genomes\n(per day)")
   # # 
   # # 
   # # legend("top", horiz=FALSE, inset=c(0,-0.3), bty='n', xpd=TRUE, ncol=3,
   # #        fill=mPal(unlist(ukPal), 0.75), border = mPal(unlist(ukPal)),
   # #        legend = c("Germany", "Other countries"),
   # #        #legend = c("England", "Scotland", "Wales", "Northern Ireland", "Other countries"),
   # #        cex=0.8)
   # # 
   # Cumulative sequences, cases and infections
   # plot.new()
   par(new = TRUE)
   ymax = max(deCases$case) * 1.1
   # plotShadedAxes(xlim=c(startDate, endDate), ylim=c(0, ymax), ylab="Cases", yaxs='i', xaxs='i')
   
   plot(1, type='n', xlim=c(startDate, endDate), ylim=c(0, ymax),
        axes=FALSE, xlab="", ylab="", log='', yaxs='i', xaxs='i')

   # axis(4, las=1, at=axTicks(4), labels=format(axTicks(4), scientific=FALSE))
   # plotLogAxis(lim=c(1, ymax), side=4)
   axis(side=4, las=2)
   mtext(side=4, text="Cases and genomes", line=3, cex=0.8)
   lines(deCases$date, deCases$case, lwd=1, col=dePal[["all"]])
   # legend("top", horiz=FALSE, inset=c(0,-0.3), bty='n', xpd=TRUE, ncol=3,
   #        fill=mPal(unlist(dePal[[state]]), 0.75), border = mPal(unlist(dePal[[state]])),
   #        legend = c("Germany"),
   #        cex=0.8)


   #ukseqs_daily <- data.frame(date = sampleBreaks[1:(length(sampleBreaks)-1)],
   #                          seqs = rowSums(seq_hist_breakdown[, -c(5)]))
   #lines(ukseqs_daily$date, cumsum(ukseqs_daily$seqs), lwd=2)

   # polygon(c(europeInfections$time[europeInfections$country == "United_Kingdom"],
   #           rev(europeInfections$time[europeInfections$country == "United_Kingdom"])),
   #         c(europeInfections$predicted_infections_higher_CI_95_cumulative[europeInfections$country == "United_Kingdom"],
   #           rev(europeInfections$predicted_infections_lower_CI_95_cumulative[europeInfections$country == "United_Kingdom"])),
   #           border=NA, col = mPal(ukPal$oth, 0.75))
   # lines(europeInfections$time[europeInfections$country == "United_Kingdom"], europeInfections$predicted_infections_mean_cumulative[europeInfections$country == "United_Kingdom"],
   #       lty=3, lwd=2)
   #lines(c(ukCases$date, min(ukCases$date)-1), c(ukCases$cumCasesBySpecimenDate, 1E-10), lwd=2, lty=2)

   # idx <- which(ukWeekly$date == as.Date("2020-05-17"))
   # text(x = as.Date("2020-05-17"), y = ukWeekly$infectionsCum[idx]+5E6, "Estimated UK\ninfections",
   #      pos=1, xpd=TRUE, cex=0.6)
   # text(x = as.Date("2020-05-17"), y = ukWeekly$casesCum[idx]+1.5E5, "Reported UK\ncases",
   #      pos=1, xpd=TRUE, cex=0.6)
   # text(x = as.Date("2020-05-17"), y = ukWeekly$seqsCum[idx], "UK genomes\nsequenced",
   #      pos=1, xpd=TRUE, cex=0.6)

   
   
   # 7-day average 
   
   seq_hist_names <- c()
   seq_hist_breakdown <- data.frame(matrix(0, nrow=length(seq_hist_oth$counts), ncol=0))
   
   # seq_hist_names <- c(seq_hist_names, "all")
   # seq_hist_breakdown <- cbind(seq_hist_breakdown, seq_hist_oth$counts)
   
   for (s in 1:nrow(stateFiles)) {
      state <- stateFiles$state[s]
      seq_hist_state <- hist(metadata$sample_date_orig[stateInfo$metadata_instate[s] & metadata$sample_date_orig> startDate], 
                       breaks=sampleBreaks, plot=FALSE, right=FALSE)
      
      seq_hist_breakdown <- cbind(seq_hist_breakdown, average_(seq_hist_state$count))
      seq_hist_names <- c(seq_hist_names, state)

      seq_hist_state <- hist(metadata$sample_date_orig[!stateInfo$metadata_instate[s] & metadata$sample_date_orig> startDate], 
                       breaks=sampleBreaks, plot=FALSE, right=FALSE)
      
      seq_hist_breakdown <- cbind(seq_hist_breakdown, average_(seq_hist_state$count))
      seq_hist_names <- c(seq_hist_names, paste("Non", state))
   }
   
   colnames(seq_hist_breakdown) <- seq_hist_names
   
   # Sequence histogram
   par(mar=c(4,6,2.5,6), cex.axis=0.7, cex.lab=0.8, mgp=c(3,0.75,0))
   draw_seq_freq_states(c("Germany", "Non Germany"))
   draw_seq_freq_states(c("Germany"), ymax=max(seq_hist_breakdown[, "Germany"]) * 1.05)
   ymax=400 * 1.05
   
   par(new = TRUE)
   ymax = max(deCases$case) * 1.1

   plot(1, type='n', xlim=c(startDate, endDate), ylim=c(0, ymax),
        axes=FALSE, xlab="", ylab="", log='', yaxs='i', xaxs='i')

  axis(side=4, las=2)

   # plotLogAxis(lim=c(1, ymax), side=4)
   mtext(side=4, text="Cases and genomes", line=3, cex=0.8)
   lines(deCases$date, average_(deCases$case), lwd=1, col="#d01c8b")




```

- The maximum number of sequences per day is `(metadata[metadata$country == "Germany",] %>% dplyr::count(sample_date, sort = TRUE))[1,"n"]` for Germany, and `(metadata[,] %>% dplyr::count(sample_date, sort = TRUE))[1,"n"]` world-wide. Since the data of each sequenced genome may take one or two weeks to be submitted to the data set, the number of sequences in the data set drops for the last two weeks.

\clearpage

# Cases

```{r case-and-sample-count-absolute, fig.width=7, fig.height=3, fig.cap = "Number of confirmed cases vs number of sequences from Germany."}


# germany_cases <- unlist(case_data["Germany",])
# sampleBreaks      <- seq.Date(as.Date(startDate), as.Date(endDate), by="1 day")
# sampleBreaks <- c(case_data_date, case_data_date[length(case_data_date)]+1)
sampleBreaks <- c(deCases$date, deCases$date[length(deCases$date)]+1)
germany_sequences <- hist(metadata$sample_date[metadata$sample_date >= sampleBreaks[1] & unlist(stateInfo$metadata_instate) & metadata$sample_date <= sampleBreaks[length(sampleBreaks)]],  
                        breaks=sampleBreaks, plot=FALSE, right=FALSE)$counts

germany_cases <- deCases$case[match(deCases$date, sampleBreaks) ]

pal <- list("Sequences" = "#000099", "Cases" = "#BE0F34")


dateFreqDistribution(t(as.matrix(data.frame("Sequences" = germany_sequences, "Cases" = germany_cases - germany_sequences))), 
                     sampleBreaks, plot.ci=FALSE,
                     barplot=TRUE,
                     startDate = sampleBreaks[1], 
                     endDate = sampleBreaks[length(sampleBreaks)-1],    
                     col=mPal(unlist(pal), 0.75), border=mPal(unlist(pal)),
                     ymax=max(germany_cases) * 1.1,
                     ylab = "Frequency of genomes\n(per day)")
 
 
legend("top", horiz=FALSE, inset=c(0,-0.3), bty='n', xpd=TRUE, ncol=3,
        fill=mPal(unlist(pal), 0.75), border = mPal(unlist(pal)),
        legend = c("Sequences", "Cases"),
        # legend = c("Germany", "Other countries"),
        #legend = c("England", "Scotland", "Wales"#FF7F00, "Northern Ireland", "Other countries"),
        cex=0.8)
 
     
pal <- list("Sequences" = "#00BB00")


dateFreqDistribution(t(as.matrix(data.frame("Sequences per Case" = germany_sequences / germany_cases))), 
                     sampleBreaks, plot.ci=FALSE,
                     barplot=TRUE,
                     startDate = sampleBreaks[1], 
                     endDate = sampleBreaks[length(sampleBreaks)-1],    
                     col=mPal(unlist(pal), 0.75), border=mPal(unlist(pal)),
                     ymax=1,
                     ylab = "Frequency of genomes\n(per day)")
 
 
legend("top", horiz=FALSE, inset=c(0,-0.3), bty='n', xpd=TRUE, ncol=3,
        fill=mPal(unlist(pal), 0.75), border = mPal(unlist(pal)),
        legend = c("Sequences per Case"),
        # legend = c("Germany", "Other countries"),
        #legend = c("England", "Scotland", "Wales"#FF7F00, "Northern Ireland", "Other countries"),
        cex=0.8)
 


pal <- list("Cases" = "#BE0F34")


dateFreqDistribution(t(as.matrix(data.frame("Cases" = germany_cases))), 
                     sampleBreaks, plot.ci=FALSE,
                     barplot=TRUE,
                     startDate = sampleBreaks[1], 
                     endDate = sampleBreaks[length(sampleBreaks)-1],    
                     col=mPal(unlist(pal), 0.75), border=mPal(unlist(pal)),
                     ymax=max(germany_cases) * 1.1,
                     ylab = "Frequency of genomes\n(per day)")
 
 
legend("top", horiz=FALSE, inset=c(0,-0.3), bty='n', xpd=TRUE, ncol=3,
        fill=mPal(unlist(pal), 0.75), border = mPal(unlist(pal)),
        legend = c("Cases"),
        # legend = c("Germany", "Other countries"),
        #legend = c("England", "Scotland", "Wales"#FF7F00, "Northern Ireland", "Other countries"),
        cex=0.8)
 
     

# }

```

```{r case-by-county, fig.width=5, fig.height=4}




lin <- "B.1.1.7"

pangolinSequenceCaseCount <- metadataAllSequences %>% 
   filter(country == "Germany") %>%
   mutate(adm1 = ifelse(adm1 == "Herzogenrath", "North Rhine-Westphalia", adm1)) %>%
   mutate(adm1 = ifelse(adm1 == "Sachsen", "Saxony", adm1)) %>%
   filter(Pango.lineage == lin | startsWith(Pango.lineage, paste0(lin, "."))) %>% 
   filter(adm1 != "NA" & !is.na(adm1)) %>%
   group_by(sample_date, adm1) %>%
   dplyr::summarise(n = n()) 
   # mutate(p =  round(n/sum(n) * 100, digits=1)) %>%
   # arrange(desc(n)) %>% left_join(deCounty, by = c("adm1" = "state")) %>%
   # mutate(n.pcapita = n / population * 1000000, n.pcase = n / case * 10000)
   
   
   
   # group_by(adm1) %>% 
   # dplyr::summarise(n = n()) %>% 
   # mutate(p =  round(n/sum(n) * 100, digits=1)) %>% 
   # arrange(desc(n)) %>% left_join(deCounty, by = c("adm1" = "state")) %>%
   # mutate(n.pcapita = n / population * 1000000, n.pcase = n / case * 10000)
   # 
for (countyIt in levels(factor(deCountyDaily$county))) {
   
   sampleBreaks <- c(deCases$date, deCases$date[length(deCases$date)]+1)
   countyDaily <- deCountyDaily %>% dplyr::filter(county == countyIt) %>% dplyr::filter(date >= sampleBreaks[1] & date < sampleBreaks[length(sampleBreaks)])
   countyDaily$case <- average_(countyDaily$case)
   countyDaily$seqs <- average_(countyDaily$seqs)
   
   pal <- list("Sequences" = dePal[[countyIt]])
   
   dateFreqDistribution(t(as.matrix(data.frame("Sequences per case" = countyDaily$seqs / countyDaily$case))), 
                        sampleBreaks, plot.ci=FALSE,
                        barplot=TRUE,
                        startDate = sampleBreaks[1], 
                        endDate = sampleBreaks[length(sampleBreaks)-1],    
                        col=mPal(unlist(pal), 0.75), border=mPal(unlist(pal)),
                        ymax=1,
                        ylab = "Frequency")
   
   
   legend("top", horiz=FALSE, inset=c(0,-0.1), bty='n', xpd=TRUE, ncol=1,
          fill=mPal(unlist(pal), 0.75), border = mPal(unlist(pal)),
          legend = c(paste("Sequences per Case for", countyIt)),
          # legend = c("Germany", "Other countries"),
          #legend = c("England", "Scotland", "Wales"#FF7F00, "Northern Ireland", "Other countries"),
          cex=0.8)
   
   # 
   # 
   # pal <- list("Cases" = "#BE0F34")
   # 
   # 
   # dateFreqDistribution(t(as.matrix(data.frame("Cases" = germany_cases))), 
   #                      sampleBreaks, plot.ci=FALSE,
   #                      barplot=TRUE,
   #                      startDate = sampleBreaks[1], 
   #                      endDate = sampleBreaks[length(sampleBreaks)-1],    
   #                      col=mPal(unlist(pal), 0.75), border=mPal(unlist(pal)),
   #                      ymax=max(germany_cases) * 1.1,
   #                      ylab = "Frequency of genomes\n(per day)")
   #  
   #  
   # legend("top", horiz=FALSE, inset=c(0,-0.3), bty='n', xpd=TRUE, ncol=3,
   #         fill=mPal(unlist(pal), 0.75), border = mPal(unlist(pal)),
   #         legend = c("Cases"),
   #         # legend = c("Germany", "Other countries"),
   #         #legend = c("England", "Scotland", "Wales"#FF7F00, "Northern Ireland", "Other countries"),
   #         cex=0.8)
   
   
   
   pal <- list("Sequence" = dePal[[countyIt]], "Case" = darken(dePal[[countyIt]], 0.75))
   
   ymax = max(countyDaily$case) * 1.1
   
   dateFreqDistribution(t(as.matrix(data.frame("Sequence" = countyDaily$seqs, "Case" = countyDaily$case - countyDaily$seqs))),
                        sampleBreaks, plot.ci=FALSE,
                        barplot=TRUE,
                        startDate = sampleBreaks[1],
                        endDate = sampleBreaks[length(sampleBreaks)-1],
                        col=mPal(unlist(pal), 0.75), border=mPal(unlist(pal)),
                        ymax=ymax,
                        ylab = "Count")
   
   #  par(new = TRUE)
   #
   #  plot(1, type='n', xlim=c(sampleBreaks[1], sampleBreaks[length(sampleBreaks)]), ylim=c(0, ymax),
   #       axes=FALSE, xlab="", ylab="", log='', yaxs='i', xaxs='i')
   #
   # # axis(side=4, las=2)
   #
   #  # plotLogAxis(lim=c(1, ymax), side=4)
   #  # mtext(side=4, text="Cases and genomes", line=3, cex=0.8)
   #  lines(deCases$date, average_(countyDaily$case), lwd=1, col=mPal(unlist(pal)) )
   
   
   legend("top", horiz=FALSE, inset=c(0,-0.1), bty='n', xpd=TRUE, ncol=2,
          fill=mPal(unlist(pal), 0.75), border = mPal(unlist(pal)),
          legend = c(paste("Sequence", countyIt), paste("Cases", countyIt)),
          # legend = c("Germany", "Other countries"),
          #legend = c("England", "Scotland", "Wales"#FF7F00, "Northern Ireland", "Other countries"),
          cex=0.8)
   

   linCount <- data.frame("date" = sampleBreaks[1:(length(sampleBreaks)-1)]) %>% left_join(pangolinSequenceCaseCount %>% filter(adm1 == countyIt), by=c("date" = "sample_date")) %>% mutate(n=ifelse(is.na(n), 0, n)) 
   linCount$n = average_(linCount$n)

   pal <- list("Sequence" = dePal[[countyIt]], lin = darken(dePal[[countyIt]], 0.75))
   ymax = max(countyDaily$seqs) * 1.1
   
   dateFreqDistribution(t(as.matrix(data.frame(lin = linCount$n, "Sequence" = countyDaily$seqs - linCount$n))),
                        sampleBreaks, plot.ci=FALSE,
                        barplot=TRUE,
                        startDate = sampleBreaks[1],
                        endDate = sampleBreaks[length(sampleBreaks)-1],
                        col=mPal(unlist(pal), 0.75), border=mPal(unlist(pal)),
                        ymax=ymax,
                        ylab = "Count")
   
   legend("top", horiz=FALSE, inset=c(0,-0.1), bty='n', xpd=TRUE, ncol=2,
          fill=mPal(unlist(pal), 0.75), border = mPal(unlist(pal)),
          legend = c(paste(lin, countyIt), paste("Sequence", countyIt)),
          # legend = c("Germany", "Other countries"),
          #legend = c("England", "Scotland", "Wales"#FF7F00, "Northern Ireland", "Other countries"),
          cex=0.8)
   
}

lin = "B.1.1.7"
countyIt <- "Germany"
   countyDaily <- deCountyDaily %>% dplyr::filter(date >= sampleBreaks[1] & date < sampleBreaks[length(sampleBreaks)]) %>% group_by(date) %>% dplyr::summarise(seqs = sum(seqs), case = sum(case)) 

   countyDaily$case <- average_(countyDaily$case)
   countyDaily$seqs <- average_(countyDaily$seqs)

   linCount <- data.frame("date" = sampleBreaks[1:(length(sampleBreaks)-1)]) %>% left_join(pangolinSequenceCaseCount, by=c("date" = "sample_date")) %>% mutate(n=ifelse(is.na(n), 0, n)) %>% group_by(date) %>% dplyr::summarise(n = sum(n))
   linCount$n = average_(linCount$n)

   pal <- list("Sequence" = dePal[["Germany"]], lin = darken(dePal[["Germany"]], 0.55), "case" = darken(dePal[["Germany"]], 0.75))
   pal <- list("Sequence" = dePal[["Germany"]], lin = darken(dePal[["Germany"]], 0.55), "case" = "#000080")

   dateFreqDistribution(t(as.matrix(data.frame(lin = linCount$n, "Sequence" = countyDaily$seqs - linCount$n))),
                        sampleBreaks, plot.ci=FALSE,
                        barplot=TRUE,
                        startDate = sampleBreaks[1],
                        endDate = sampleBreaks[length(sampleBreaks)-1],
                        col=mPal(unlist(pal), 0.75), border=mPal(unlist(pal)),
                        ymax=max(countyDaily$seqs) * 1.1,
                        ylab = "Count")
   
   legend("top", horiz=FALSE, inset=c(0,-0.1), bty='n', xpd=TRUE, ncol=2,
          fill=mPal(unlist(pal), 0.75), border = mPal(unlist(pal)),
          legend = c(paste(lin, countyIt), paste("Sequence", countyIt)),
          # legend = c("Germany", "Other countries"),
          #legend = c("England", "Scotland", "Wales"#FF7F00, "Northern Ireland", "Other countries"),
          cex=0.8)

   dateFreqDistribution(t(as.matrix(data.frame(lin = linCount$n, "Sequence" = countyDaily$seqs - linCount$n, "case" = countyDaily$case - countyDaily$seqs - linCount$n))),
                        sampleBreaks, plot.ci=FALSE,
                        barplot=TRUE,
                        startDate = sampleBreaks[1],
                        endDate = sampleBreaks[length(sampleBreaks)-1],
                        col=mPal(unlist(pal), 0.75), border=mPal(unlist(pal)),
                        ymax=max(countyDaily$case) * 1.1,
                        ylab = "Count")
   
   legend("top", horiz=FALSE, inset=c(0,-0.1), bty='n', xpd=TRUE, ncol=3,
          fill=mPal(unlist(pal), 0.75), border = mPal(unlist(pal)),
          legend = c(paste(lin, countyIt), paste("Sequence", countyIt), paste("Case", countyIt)),
          # legend = c("Germany", "Other countries"),
          #legend = c("England", "Scotland", "Wales"#FF7F00, "Northern Ireland", "Other countries"),
          cex=0.8)
   
   pal <- list("Sequence" = dePal[["Germany"]], "case" = "#AFEEEE")
   dateFreqDistribution(t(as.matrix(data.frame("Sequence" = countyDaily$seqs, "case" = countyDaily$case - countyDaily$seqs))),
                        sampleBreaks, plot.ci=FALSE,
                        barplot=TRUE,
                        startDate = sampleBreaks[1],
                        endDate = sampleBreaks[length(sampleBreaks)-1],
                        col=mPal(unlist(pal), 0.75), border=mPal(unlist(pal)),
                        ymax=max(countyDaily$case) * 1.1,
                        ylab = "")
   
   legend("top", horiz=FALSE, inset=c(0,-0.1), bty='n', xpd=TRUE, ncol=3,
          fill=mPal(unlist(pal), 0.75), border = mPal(unlist(pal)),
          legend = c(paste("sequences of ", countyIt), paste("cases of", countyIt)),
          # legend = c("Germany", "Other countries"),
          #legend = c("England", "Scotland", "Wales"#FF7F00, "Northern Ireland", "Other countries"),
          cex=0.8)
   
   

```

```{r calibrated number of B.1.17 sequences, fig.width=5, fig.height=4}

referenceDate <- as.Date("2021-02-01")
lin <- "B.1.1.7"

deCountyWeekly <- deCountyDaily %>% mutate(week = calculateWeek(date, referenceDate)) %>% group_by(week, county) %>% dplyr::summarise(case = sum(case))


pangolinSequenceCaseCount <- metadataAllSequences %>% 
   filter(country == "Germany") %>%
   mutate(adm1 = ifelse(adm1 == "Herzogenrath", "North Rhine-Westphalia", adm1)) %>%
   mutate(adm1 = ifelse(adm1 == "Sachsen", "Saxony", adm1)) %>%
   filter(Pango.lineage == lin | startsWith(Pango.lineage, paste0(lin, "."))) %>% 
   filter(adm1 != "NA" & !is.na(adm1)) %>%
   mutate(week = as.numeric(sample_date - referenceDate)%/%7) %>%
   group_by(week, adm1) %>%
   dplyr::summarise(n = n()) 
   # mutate(p =  round(n/sum(n) * 100, digits=1)) %>%
   # arrange(desc(n)) %>% left_join(deCounty, by = c("adm1" = "state")) %>%
   # mutate(n.pcapita = n / population * 1000000, n.pcase = n / case * 10000)
   
sequenceCaseCount <- metadataAllSequences %>% 
   filter(country == "Germany") %>%
   mutate(adm1 = ifelse(adm1 == "Herzogenrath", "North Rhine-Westphalia", adm1)) %>%
   mutate(adm1 = ifelse(adm1 == "Sachsen", "Saxony", adm1)) %>%
   # filter(Pango.lineage == lin | startsWith(Pango.lineage, paste0(lin, "."))) %>% 
   filter(adm1 != "NA" & !is.na(adm1)) %>%
   mutate(week = as.numeric(sample_date - referenceDate)%/%7) %>%
   group_by(week, adm1) %>%
   dplyr::summarise(n = n()) 
   # mutate(p =  round(n/sum(n) * 100, digits=1)) %>%
   # arrange(desc(n)) %>% left_join(deCounty, by = c("adm1" = "state")) %>%
   # mutate(n.pcapita = n / population * 1000000, n.pcase = n / case * 10000)

deCountyWeeklyCalibrated <- deCountyWeekly %>% filter(!is.na(county)) %>%
   left_join(pangolinSequenceCaseCount %>% dplyr::rename(lin.seq=n), by=c("week"="week", "county"="adm1")) %>% 
   left_join(sequenceCaseCount %>% dplyr::rename(seq=n), by=c("week"="week", "county"="adm1")) %>% 
   mutate(lin.seq = ifelse(is.na(lin.seq), 0, lin.seq)) %>% 
   mutate(seq=ifelse(is.na(seq), 0, seq)) %>% 
   mutate(lin.seq.calibrated = ifelse(seq == 0, 0, lin.seq / seq * case)) %>%
   mutate(lin.seq.norm = ifelse(seq == 0, 0, lin.seq/seq))

endDate <- as.Date("2021-05-26")
data <- deCountyWeeklyCalibrated %>%
   filter(week >= calculateWeek(referenceDate, referenceDate), week <= calculateWeek(endDate, referenceDate)) %>%
   # group_by(county) %>% dplyr::summarise(lin.seq.calibrated = sum(lin.seq.calibrated), lin.seq.norm=mean(lin.seq.norm))%>%
   group_by(county) %>% dplyr::summarise(lin.seq.calibrated = sum(lin.seq) / sum(seq) * sum(case), 
                                         lin.seq.norm=sum(lin.seq)/sum(seq),
                                         seq = sum(seq), lin.seq = sum(lin.seq))%>%
      left_join(deCounty %>% dplyr::select(state, population), by=c("county"="state")) %>%
      mutate(lin.seq.calibared.per.capita = lin.seq.calibrated / population)

# Calibrated number of B.1.1.7 sequences overall
plot_on_map(data$county, data$lin.seq.calibrated / 10000, 
            title="B", legend_title = "Sequences\n (x 10,000) ", col = "#abdda4",max_value = 
              max(data$lin.seq.calibrated) / 10000 * 1.1, legend.position = "bottom", text.font.size = NULL)

plot_on_map(data$county, data$lin.seq.calibared.per.capita, 
            title=paste("Calibrated no. of sequences of", lin, "per capita", "(calibrated over weeks and summed)", referenceDate, endDate), 
            legend_title = "Calibrated no. per capita", col = "orange", max_value = 
              max(data$lin.seq.calibared.per.capita) * 1.1, min_value = min(data$lin.seq.calibared.per.capita))

plot_on_map(data$county, data$lin.seq.norm, 
            title=paste("Normalized No. of sequences of", lin, "(calibrated over weeks and averaged)\n", referenceDate, endDate), 
            legend_title = "Normalized no.", col = "#00FF55", max_value = 
              max(data$lin.seq.norm) * 1.1)

print(knitr::kable(data %>% arrange(lin.seq.calibared.per.capita)))

max_value <- 120000
weeksInChart <- 4
for (ws in seq(0, calculateWeek(endDate, referenceDate), weeksInChart)) {
   
   # data <- deCountyWeeklyCalibrated %>% filter(week >= ws, week < ws + weeksInChart)%>%
   #    group_by(county) %>% dplyr::summarise(lin.seq.calibrated = sum(lin.seq.calibrated), lin.seq.norm=mean(lin.seq.norm)) %>%
   #    left_join(deCounty %>% dplyr::select(state, population), by=c("county"="state")) %>%
   #    mutate(lin.seq.calibared.per.capita = lin.seq.calibrated / population)
   data <- deCountyWeeklyCalibrated %>% filter(week >= ws, week < ws + weeksInChart)%>%
      group_by(county) %>% dplyr::summarise(lin.seq.calibrated = ifelse(sum(seq) == 0, 0, sum(lin.seq) / sum(seq) * sum(case)), 
                                            lin.seq.norm= ifelse(sum(seq) == 0, 0, sum(lin.seq)/sum(seq)),
                                            seq = sum(seq),
                                            lin.seq = sum(lin.seq)) %>%
      left_join(deCounty %>% dplyr::select(state, population), by=c("county"="state")) %>%
      mutate(lin.seq.calibared.per.capita = lin.seq.calibrated / population)
   
   plot_on_map(data$county, data$lin.seq.calibrated, 
               title=paste("Calibrated no. of ", lin, " seqs\n", referenceDate + 7 * ws, "to", 
                           referenceDate + 7 * (ws+weeksInChart)-1 ), legend_title = "Calibrated no.", col = pangoPal[lin], 
               max_value = max_value)

   plot_on_map(data$county, data$lin.seq.calibared.per.capita, 
            title=paste("Calibrated no. of ", lin, " seqs per capita", referenceDate + 7 * ws, "to", 
                        referenceDate + 7 * (ws+weeksInChart)-1 ), legend_title = "Calibrated no. per capita", col = "#f46d43", 
            max_value = 0.03)
   plot_on_map(data$county, data$lin.seq.norm, 
               title=paste("Norm. No. of seq ", lin, referenceDate + 7 * ws, "to", 
                        referenceDate + 7 * (ws+weeksInChart)-1), 
               legend_title = "Normalized no.", col = "#00FF55", max_value = 1)

   plot_on_map(data$county, data$lin.seq.norm, 
               title=paste("Norm. No. of seq ", lin, referenceDate + 7 * ws, "to", 
                        referenceDate + 7 * (ws+weeksInChart)-1), 
               legend_title = "Normalized no.", col = "#FF0055", min_value = min(data$lin.seq.norm), max_value = max(data$lin.seq.norm))

   
   print(knitr::kable(data %>% arrange(lin.seq.calibared.per.capita), caption=paste("Avg over", weeksInChart, "weeks", referenceDate + 7 * ws, "to", 
                        referenceDate + 7 * (ws+weeksInChart)-1)))
}

print(knitr::kable(metadataAllSequences %>% filter(country == "Germany") %>% mutate(week = calculateWeek(sample_date, referenceDate)) %>% group_by(week) %>% dplyr::summarise(seq=n()) %>% filter(week >= -5) %>% left_join(deCountyWeekly %>% group_by(week) %>% dplyr::summarise(case=sum(case))) %>% mutate(r=seq/case), caption="Sequencing rate"))
 
print(knitr::kable(metadataAllSequences %>% filter(country == "Germany") %>% group_by(sample_date) %>% dplyr::summarise(seq=n()) %>% filter(sample_date >= as.Date("2021-01-01")) %>% left_join(deCountyDaily %>% group_by(date) %>% dplyr::summarise(case=sum(case)), by=c("sample_date"="date")) %>% mutate(r=seq/case), caption="Sequencing rate"))

  
print(knitr::kable(metadataAllSequences %>% filter(country == "Germany", sample_date >= as.Date("2021-01-01"), sample_date <= as.Date("2021-03-31")) %>% group_by(adm1) %>% dplyr::summarise(seq=n()) %>% left_join(deCountyDaily %>% filter(date >= as.Date("2021-01-01"), date <= as.Date("2021-03-31")) %>% group_by(county) %>% dplyr::summarise(case=sum(case)), by=c("adm1"="county")) %>% mutate(r=seq/case) %>% arrange(r), caption="Sequencing rate"))


```
```{r b117-per-week-per-state, fig.width=6, fig.height=2.5}
sequenceCaseCountNonNAPangoli <- metadataAllSequences %>% 
   filter(country == "Germany") %>%
   mutate(adm1 = ifelse(adm1 == "Herzogenrath", "North Rhine-Westphalia", adm1)) %>%
   mutate(adm1 = ifelse(adm1 == "Sachsen", "Saxony", adm1)) %>%
   filter(adm1 != "NA" & !is.na(adm1)) %>%
   filter(Pango.lineage != "NA" & Pango.lineage != "None" & !is.na(Pango.lineage)) %>%
   mutate(week = as.numeric(sample_date - referenceDate)%/%7) %>%
   group_by(week, adm1) %>%
   dplyr::summarise(n = n()) 

deCountyWeeklyCalibratedNonNAPangoli <- deCountyWeekly %>% filter(!is.na(county)) %>%
   left_join(pangolinSequenceCaseCount %>% dplyr::rename(lin.seq=n), by=c("week"="week", "county"="adm1")) %>% 
   left_join(sequenceCaseCountNonNAPangoli %>% dplyr::rename(seq=n), by=c("week"="week", "county"="adm1")) %>% 
   mutate(lin.seq = ifelse(is.na(lin.seq), 0, lin.seq)) %>% 
   mutate(seq=ifelse(is.na(seq), 0, seq)) %>% 
   mutate(lin.seq.calibrated = ifelse(seq == 0, 0, lin.seq / seq * case)) %>%
   mutate(lin.seq.norm = ifelse(seq == 0, 0, lin.seq/seq)) %>%
   mutate(week_start = referenceDate + week * 7)

# ymax <- max(data) * 1.1
# plotShadedAxes(
#    xlim=c(sampleBreaks[1], sampleBreaks[length(sampleBreaks)-1]),
#    ylim=c(0, 1),
#              ylab="Rate of B.1.1.7", yaxs='i', xaxs='i')

countyImportant <- c("Bavaria", "Baden-Wurttemberg", "North Rhine-Westphalia")
data <- deCountyWeeklyCalibratedNonNAPangoli %>% mutate(county = ifelse(county %in% countyImportant, county, "Other")) %>% group_by(week, week_start, county) %>% dplyr::summarise(case = sum(case), lin.seq = sum(lin.seq), seq=sum(seq))  %>% 
    mutate(lin.seq.calibrated = ifelse(seq == 0, 0, lin.seq / seq * case)) %>%
    mutate(lin.seq.norm = ifelse(seq == 0, 0, lin.seq/seq))

p <- ggplot(data, aes(x=week_start, y=lin.seq.norm, color = county)) +
 geom_line() + 
 scale_x_date(date_labels="%b %d", date_breaks = "7 day", minor_breaks = "1 day", limits = c(as.Date("2020-12-09"), as.Date("2021-05-20")), expand = c(0, 0)) +
 scale_color_manual(values = unlist(sdePal[c(countyImportant, "Other")]), name = "State") +
 labs(y = 'Proportion of B.1.1.7', x= NULL) + 
 theme(axis.text.x = element_text(angle = 90, hjust = 1), 
       axis.title = element_text(size = 10),
     axis.line = element_line(color='black'), panel.grid.minor = element_blank())
print(p)

```

```{r Percentage of B.1.1.7 seqs from all seqs for each state, fig.width=5, fig.height=4}
# sequenceCaseCountNonNAPangoli <- metadataAllSequences %>% 
#    filter(country == "Germany") %>%
#    mutate(adm1 = ifelse(adm1 == "Herzogenrath", "North Rhine-Westphalia", adm1)) %>%
#    mutate(adm1 = ifelse(adm1 == "Sachsen", "Saxony", adm1)) %>%
#    filter(adm1 != "NA" & !is.na(adm1)) %>%
#    filter(Pango.lineage != "NA" & Pango.lineage != "None" & !is.na(Pango.lineage)) %>%
#    mutate(week = as.numeric(sample_date - referenceDate)%/%7) %>%
#    group_by(week, adm1) %>%
#    dplyr::summarise(n = n()) 
# 
# deCountyWeeklyCalibratedNonNAPangoli <- deCountyWeekly %>% filter(!is.na(county)) %>%
#    left_join(pangolinSequenceCaseCount %>% dplyr::rename(lin.seq=n), by=c("week"="week", "county"="adm1")) %>% 
#    left_join(sequenceCaseCountNonNAPangoli %>% dplyr::rename(seq=n), by=c("week"="week", "county"="adm1")) %>% 
#    mutate(lin.seq = ifelse(is.na(lin.seq), 0, lin.seq)) %>% 
#    mutate(seq=ifelse(is.na(seq), 0, seq)) %>% 
#    mutate(lin.seq.calibrated = ifelse(seq == 0, 0, lin.seq / seq * case)) %>%
#    mutate(lin.seq.norm = ifelse(seq == 0, 0, lin.seq/seq))

data <- deCountyWeeklyCalibratedNonNAPangoli %>% filter(week >= calculateWeek(as.Date("2021-02-01"), referenceDate), week <= calculateWeek(as.Date("2021-06-01"), referenceDate))%>%
   group_by(county) %>% dplyr::summarise(lin.seq.calibrated = ifelse(sum(seq) == 0, 0, sum(lin.seq) / sum(seq) * sum(case)), 
                                         lin.seq.norm= ifelse(sum(seq) == 0, 0, sum(lin.seq)/sum(seq)),
                                         seq = sum(seq),
                                         lin.seq = sum(lin.seq)) %>%
      left_join(deCounty %>% dplyr::select(state, population), by=c("county"="state")) %>%
      mutate(lin.seq.calibared.per.capita = lin.seq.calibrated / population)

print(knitr::kable(data, caption = "Normalized no of B.1.1.7/non-na-pangolin per state"))

weeksInChart <- 4
for (ws in seq(0, calculateWeek(endDate, referenceDate), weeksInChart)) {
   
   # data <- deCountyWeeklyCalibrated %>% filter(week >= ws, week < ws + weeksInChart)%>%
   #    group_by(county) %>% dplyr::summarise(lin.seq.calibrated = sum(lin.seq.calibrated), lin.seq.norm=mean(lin.seq.norm)) %>%
   #    left_join(deCounty %>% dplyr::select(state, population), by=c("county"="state")) %>%
   #    mutate(lin.seq.calibared.per.capita = lin.seq.calibrated / population)
   data <- deCountyWeeklyCalibrated %>% filter(week >= ws, week < ws + weeksInChart)%>%
      group_by(county) %>% dplyr::summarise(lin.seq.calibrated = ifelse(sum(seq) == 0, 0, sum(lin.seq) / sum(seq) * sum(case)), 
                                            lin.seq.norm= ifelse(sum(seq) == 0, 0, sum(lin.seq)/sum(seq)),
                                            seq = sum(seq),
                                            lin.seq = sum(lin.seq)) %>%
      left_join(deCounty %>% dplyr::select(state, population), by=c("county"="state")) %>%
      mutate(lin.seq.calibared.per.capita = lin.seq.calibrated / population)
   
   # plot_on_map(data$county, data$lin.seq.calibrated, 
   #             title=paste("Calibrated No. of sequences of ", lin, "\n", referenceDate + 7 * ws, "to", 
   #                         referenceDate + 7 * (ws+weeksInChart)-1 ), legend_title = "Calibrated no.", col = "#00FF00", 
   #             max_value = max_value)

   # plot_on_map(data$county, data$lin.seq.calibared.per.capita, 
   #          title=paste("Calibrated No. of sequences of", lin, "per capita", referenceDate + 7 * ws, "to", 
   #                      referenceDate + 7 * (ws+weeksInChart)-1 ), legend_title = "Calibrated no. per capita", col = "orange", 
   #          max_value = 0.03)
   #Normalized number of B.1.1.7 seqs, normalized by each state seqs
   plot_on_map(data$county, data$lin.seq.norm, 
               title=paste( referenceDate + 7 * ws, "to", 
                        referenceDate + 7 * (ws+weeksInChart)-1), 
               legend_title = "Normalized no.", col = pangoPal[lin], max_value = 1)

   
#   plot_on_map(data$county, data$lin.seq.norm, 
#               title=paste("Norm. No. of seq ", lin, referenceDate + 7 * ws, "to", 
#                        referenceDate + 7 * (ws+weeksInChart)-1), 
 #              legend_title = "Normalized no.", col = "#FF0055", min_value = min(data$lin.seq.norm), max_value = max(data$lin.seq.norm))

   
   print(knitr::kable(data %>% arrange(lin.seq.calibared.per.capita), caption=paste("Avg over", weeksInChart, "weeks", referenceDate + 7 * ws, "to", 
                        referenceDate + 7 * (ws+weeksInChart)-1)))
}

```

```{r B.1.1.7 sequences, calibrated, fig.width=5, fig.height=4}

referenceDate <- as.Date("2020-01-01")
lin <- "B.1.1.7"

deCountyWeekly <- deCountyDaily %>% mutate(week = as.numeric(date - referenceDate)%/%7) %>% group_by(week, county) %>% dplyr::summarise(case = sum(case))


pangolinSequenceCaseCount <- metadataAllSequences %>% 
   filter(country == "Germany") %>%
   mutate(adm1 = ifelse(adm1 == "Herzogenrath", "North Rhine-Westphalia", adm1)) %>%
   mutate(adm1 = ifelse(adm1 == "Sachsen", "Saxony", adm1)) %>%
   filter(Pango.lineage == lin | startsWith(Pango.lineage, paste0(lin, "."))) %>% 
   filter(adm1 != "NA" & !is.na(adm1)) %>%
   mutate(week = as.numeric(sample_date - referenceDate)%/%7) %>%
   group_by(week, adm1) %>%
   dplyr::summarise(n = n()) 
   # mutate(p =  round(n/sum(n) * 100, digits=1)) %>%
   # arrange(desc(n)) %>% left_join(deCounty, by = c("adm1" = "state")) %>%
   # mutate(n.pcapita = n / population * 1000000, n.pcase = n / case * 10000)
   
sequenceCaseCount <- metadataAllSequences %>% 
   filter(country == "Germany") %>%
   mutate(adm1 = ifelse(adm1 == "Herzogenrath", "North Rhine-Westphalia", adm1)) %>%
   mutate(adm1 = ifelse(adm1 == "Sachsen", "Saxony", adm1)) %>%
   # filter(Pango.lineage == lin | startsWith(Pango.lineage, paste0(lin, "."))) %>% 
   filter(adm1 != "NA" & !is.na(adm1)) %>%
   mutate(week = as.numeric(sample_date - referenceDate)%/%7) %>%
   group_by(week, adm1) %>%
   dplyr::summarise(n = n()) 
   # mutate(p =  round(n/sum(n) * 100, digits=1)) %>%
   # arrange(desc(n)) %>% left_join(deCounty, by = c("adm1" = "state")) %>%
   # mutate(n.pcapita = n / population * 1000000, n.pcase = n / case * 10000)

deCountyWeeklyCalibrated <- deCountyWeekly %>% filter(!is.na(county)) %>%
   left_join(pangolinSequenceCaseCount %>% dplyr::rename(lin.seq=n), by=c("week"="week", "county"="adm1")) %>% 
   left_join(sequenceCaseCount %>% dplyr::rename(seq=n), by=c("week"="week", "county"="adm1")) %>% 
   mutate(lin.seq = ifelse(is.na(lin.seq), 0, lin.seq)) %>% 
   mutate(seq=ifelse(is.na(seq), 0, seq)) %>% 
   mutate(lin.seq.calibrated = ifelse(seq == 0, 0, lin.seq / seq * case)) 

data <- deCountyWeeklyCalibrated %>%
   group_by(county) %>% dplyr::summarise(lin.seq.calibrated = sum(lin.seq.calibrated))%>%
      left_join(deCounty %>% dplyr::select(state, population), by=c("county"="state")) %>%
      mutate(lin.seq.calibared.per.capita = lin.seq.calibrated / population)

plot_on_map(data$county, data$lin.seq.calibrated, 
            title=paste("Calibrated No. of ", lin," seqs"), legend_title = "Calibrated no.", col = pangoPal[lin], max_value = 
              max(data$lin.seq.calibrated) * 1.1)
plot_on_map(data$county, data$lin.seq.calibared.per.capita, 
            title=paste("Calibrated no. of ", lin, "seqs per capita"), 
            legend_title = "Calibrated no. per capita", col = "#f46d43", max_value = 
              max(data$lin.seq.calibared.per.capita) * 1.1, min_value = min(data$lin.seq.calibared.per.capita) )

print(knitr::kable(data %>% arrange(lin.seq.calibared.per.capita)))

max_value <- 120000
weeksInChart <- 4
for (ws in seq(36, max(deCountyWeekly$week), weeksInChart)) {
   data <- deCountyWeeklyCalibrated %>% filter(week >= ws, week < ws + weeksInChart)%>%
      group_by(county) %>% dplyr::summarise(lin.seq.calibrated = sum(lin.seq.calibrated)) %>%
      left_join(deCounty %>% dplyr::select(state, population), by=c("county"="state")) %>%
      mutate(lin.seq.calibared.per.capita = lin.seq.calibrated / population)
   #calibrated b.1.177 (lin)
   plot_on_map(data$county, data$lin.seq.calibrated, 
               title=paste(referenceDate + 7 * ws, "to", 
                           referenceDate + 7 * (ws+weeksInChart)-1 ), legend_title = "Calibrated no.", col = pangoPal[lin], 
               max_value = max_value)

      plot_on_map(data$county, data$lin.seq.calibared.per.capita, 
               title=paste("Calibrated no. of ", lin, "seqs per capita", referenceDate + 7 * ws, "to", 
                           referenceDate + 7 * (ws+weeksInChart)-1 ), legend_title = "Calibrated no. per capita", col = "#f46d43", 
               max_value = 0.03)
}

```

```{r B.1.221 sequences, calibrated, fig.width=5, fig.height=4}

referenceDate <- as.Date("2020-01-01")
lin <- "B.1.221"

deCountyWeekly <- deCountyDaily %>% mutate(week = as.numeric(date - referenceDate)%/%7) %>% group_by(week, county) %>% dplyr::summarise(case = sum(case))


pangolinSequenceCaseCount <- metadataAllSequences %>% 
   filter(country == "Germany") %>%
   mutate(adm1 = ifelse(adm1 == "Herzogenrath", "North Rhine-Westphalia", adm1)) %>%
   mutate(adm1 = ifelse(adm1 == "Sachsen", "Saxony", adm1)) %>%
   filter(Pango.lineage == lin | startsWith(Pango.lineage, paste0(lin, "."))) %>% 
   filter(adm1 != "NA" & !is.na(adm1)) %>%
   mutate(week = as.numeric(sample_date - referenceDate)%/%7) %>%
   group_by(week, adm1) %>%
   dplyr::summarise(n = n()) 
   # mutate(p =  round(n/sum(n) * 100, digits=1)) %>%
   # arrange(desc(n)) %>% left_join(deCounty, by = c("adm1" = "state")) %>%
   # mutate(n.pcapita = n / population * 1000000, n.pcase = n / case * 10000)
   
sequenceCaseCount <- metadataAllSequences %>% 
   filter(country == "Germany") %>%
   mutate(adm1 = ifelse(adm1 == "Herzogenrath", "North Rhine-Westphalia", adm1)) %>%
   mutate(adm1 = ifelse(adm1 == "Sachsen", "Saxony", adm1)) %>%
   # filter(Pango.lineage == lin | startsWith(Pango.lineage, paste0(lin, "."))) %>% 
   filter(adm1 != "NA" & !is.na(adm1)) %>%
   mutate(week = as.numeric(sample_date - referenceDate)%/%7) %>%
   group_by(week, adm1) %>%
   dplyr::summarise(n = n()) 
   # mutate(p =  round(n/sum(n) * 100, digits=1)) %>%
   # arrange(desc(n)) %>% left_join(deCounty, by = c("adm1" = "state")) %>%
   # mutate(n.pcapita = n / population * 1000000, n.pcase = n / case * 10000)

deCountyWeeklyCalibrated <- deCountyWeekly %>% filter(!is.na(county)) %>%
   left_join(pangolinSequenceCaseCount %>% dplyr::rename(lin.seq=n), by=c("week"="week", "county"="adm1")) %>% 
   left_join(sequenceCaseCount %>% dplyr::rename(seq=n), by=c("week"="week", "county"="adm1")) %>% 
   mutate(lin.seq = ifelse(is.na(lin.seq), 0, lin.seq)) %>% 
   mutate(seq=ifelse(is.na(seq), 0, seq)) %>% 
   mutate(lin.seq.calibrated = ifelse(seq == 0, 0, lin.seq / seq * case)) 

data <- deCountyWeeklyCalibrated %>%
   group_by(county) %>% dplyr::summarise(lin.seq.calibrated = sum(lin.seq.calibrated))%>%
      left_join(deCounty %>% dplyr::select(state, population), by=c("county"="state")) %>%
      mutate(lin.seq.calibared.per.capita = lin.seq.calibrated / population)

plot_on_map(data$county, data$lin.seq.calibrated, 
            title=paste("Calibrated No. of ", lin," seqs"), legend_title = "Calibrated no.", col = pangoPal[lin], max_value = 
              max(data$lin.seq.calibrated) * 1.1)
plot_on_map(data$county, data$lin.seq.calibared.per.capita, 
            title=paste("Calibrated no. of ", lin, "seqs per capita"), 
            legend_title = "Calibrated no. per capita", col = "#f46d43", max_value = 
              max(data$lin.seq.calibared.per.capita) * 1.1, min_value = min(data$lin.seq.calibared.per.capita) )

print(knitr::kable(data %>% arrange(lin.seq.calibared.per.capita)))

max_value <- 120000
weeksInChart <- 4
for (ws in seq(36, max(deCountyWeekly$week), weeksInChart)) {
   data <- deCountyWeeklyCalibrated %>% filter(week >= ws, week < ws + weeksInChart)%>%
      group_by(county) %>% dplyr::summarise(lin.seq.calibrated = sum(lin.seq.calibrated)) %>%
      left_join(deCounty %>% dplyr::select(state, population), by=c("county"="state")) %>%
      mutate(lin.seq.calibared.per.capita = lin.seq.calibrated / population)
   #calibrated b.1.177 (lin)
   plot_on_map(data$county, data$lin.seq.calibrated, 
               title=paste(referenceDate + 7 * ws, "to", 
                           referenceDate + 7 * (ws+weeksInChart)-1 ), legend_title = "Calibrated no.", col = pangoPal[lin], 
               max_value = max_value)

      plot_on_map(data$county, data$lin.seq.calibared.per.capita, 
               title=paste("Calibrated no. of ", lin, "seqs per capita", referenceDate + 7 * ws, "to", 
                           referenceDate + 7 * (ws+weeksInChart)-1 ), legend_title = "Calibrated no. per capita", col = "#f46d43", 
               max_value = 0.03)
}

```


```{r B.1.177 sequences, calibrated, fig.width=5, fig.height=4}

referenceDate <- as.Date("2020-01-01")
lin <- "B.1.177"

deCountyWeekly <- deCountyDaily %>% mutate(week = as.numeric(date - referenceDate)%/%7) %>% group_by(week, county) %>% dplyr::summarise(case = sum(case))


pangolinSequenceCaseCount <- metadataAllSequences %>% 
   filter(country == "Germany") %>%
   mutate(adm1 = ifelse(adm1 == "Herzogenrath", "North Rhine-Westphalia", adm1)) %>%
   mutate(adm1 = ifelse(adm1 == "Sachsen", "Saxony", adm1)) %>%
   filter(Pango.lineage == lin | startsWith(Pango.lineage, paste0(lin, "."))) %>% 
   filter(adm1 != "NA" & !is.na(adm1)) %>%
   mutate(week = as.numeric(sample_date - referenceDate)%/%7) %>%
   group_by(week, adm1) %>%
   dplyr::summarise(n = n()) 
   # mutate(p =  round(n/sum(n) * 100, digits=1)) %>%
   # arrange(desc(n)) %>% left_join(deCounty, by = c("adm1" = "state")) %>%
   # mutate(n.pcapita = n / population * 1000000, n.pcase = n / case * 10000)
   
sequenceCaseCount <- metadataAllSequences %>% 
   filter(country == "Germany") %>%
   mutate(adm1 = ifelse(adm1 == "Herzogenrath", "North Rhine-Westphalia", adm1)) %>%
   mutate(adm1 = ifelse(adm1 == "Sachsen", "Saxony", adm1)) %>%
   # filter(Pango.lineage == lin | startsWith(Pango.lineage, paste0(lin, "."))) %>% 
   filter(adm1 != "NA" & !is.na(adm1)) %>%
   mutate(week = as.numeric(sample_date - referenceDate)%/%7) %>%
   group_by(week, adm1) %>%
   dplyr::summarise(n = n()) 
   # mutate(p =  round(n/sum(n) * 100, digits=1)) %>%
   # arrange(desc(n)) %>% left_join(deCounty, by = c("adm1" = "state")) %>%
   # mutate(n.pcapita = n / population * 1000000, n.pcase = n / case * 10000)

deCountyWeeklyCalibrated <- deCountyWeekly %>% filter(!is.na(county)) %>%
   left_join(pangolinSequenceCaseCount %>% dplyr::rename(lin.seq=n), by=c("week"="week", "county"="adm1")) %>% 
   left_join(sequenceCaseCount %>% dplyr::rename(seq=n), by=c("week"="week", "county"="adm1")) %>% 
   mutate(lin.seq = ifelse(is.na(lin.seq), 0, lin.seq)) %>% 
   mutate(seq=ifelse(is.na(seq), 0, seq)) %>% 
   mutate(lin.seq.calibrated = ifelse(seq == 0, 0, lin.seq / seq * case)) 

data <- deCountyWeeklyCalibrated %>%
   group_by(county) %>% dplyr::summarise(lin.seq.calibrated = sum(lin.seq.calibrated))%>%
      left_join(deCounty %>% dplyr::select(state, population), by=c("county"="state")) %>%
      mutate(lin.seq.calibared.per.capita = lin.seq.calibrated / population)

plot_on_map(data$county, data$lin.seq.calibrated, 
            title=paste("Calibrated No. of ", lin," seqs"), legend_title = "Calibrated no.", col = pangoPal[lin], max_value = 
              max(data$lin.seq.calibrated) * 1.1)
plot_on_map(data$county, data$lin.seq.calibared.per.capita, 
            title=paste("Calibrated no. of ", lin, "seqs per capita"), 
            legend_title = "Calibrated no. per capita", col = "#f46d43", max_value = 
              max(data$lin.seq.calibared.per.capita) * 1.1, min_value = min(data$lin.seq.calibared.per.capita) )

print(knitr::kable(data %>% arrange(lin.seq.calibared.per.capita)))

max_value <- 120000
weeksInChart <- 4
for (ws in seq(36, max(deCountyWeekly$week), weeksInChart)) {
   data <- deCountyWeeklyCalibrated %>% filter(week >= ws, week < ws + weeksInChart)%>%
      group_by(county) %>% dplyr::summarise(lin.seq.calibrated = sum(lin.seq.calibrated)) %>%
      left_join(deCounty %>% dplyr::select(state, population), by=c("county"="state")) %>%
      mutate(lin.seq.calibared.per.capita = lin.seq.calibrated / population)
   #calibrated b.1.177 (lin)
   plot_on_map(data$county, data$lin.seq.calibrated, 
               title=paste(referenceDate + 7 * ws, "to", 
                           referenceDate + 7 * (ws+weeksInChart)-1 ), legend_title = "Calibrated no.", col = pangoPal[lin], 
               max_value = max_value)

      plot_on_map(data$county, data$lin.seq.calibared.per.capita, 
               title=paste("Calibrated no. of ", lin, "seqs per capita", referenceDate + 7 * ws, "to", 
                           referenceDate + 7 * (ws+weeksInChart)-1 ), legend_title = "Calibrated no. per capita", col = "#f46d43", 
               max_value = 0.03)
}

```


```{r case-by-county-all-in-one, fig.width=10, fig.height=4}
sampleBreaks <- c(deCases$date, deCases$date[length(deCases$date)]+1)

pal <- dePal[levels(factor(deCountyDaily$county))] %>% unlist()


data <- NULL
for (countyIt in levels(factor(deCountyDaily$county))) {
   countyDaily <- deCountyDaily %>% dplyr::filter(county == countyIt) %>% dplyr::filter(date >= sampleBreaks[1] & date < sampleBreaks[length(sampleBreaks)])
   countyDaily$case <- average_(countyDaily$case)
   countyDaily$seqs <- average_(countyDaily$seqs)
   data <- rbind(data, countyDaily$seqs / countyDaily$case)
}
rownames(data) <- levels(factor(deCountyDaily$county))

ymax <- max(data) * 1.1
# plotShadedAxes(xlim=c(sampleBreaks[1], sampleBreaks[length(sampleBreaks)-1]), 
#              ylim=c(0, ymax), ylab="Rate of sequencing", yaxs='i', xaxs='i')
# 
# for (countyIt in levels(factor(deCountyDaily$county))) {
#    lines(sampleBreaks[1:(length(sampleBreaks)-1)], data[countyIt,], type='l', col=dePal[[countyIt]])
# }
# 
# 
# legend("top", horiz=FALSE, inset=c(0,-0.0), bty='n', xpd=TRUE, ncol=4,
#         fill=mPal(unlist(pal), 0.75), border = mPal(unlist(pal)),
#         legend = levels(factor(deCountyDaily$county)),
#         cex=0.8)
#  
for (adm.list in list(c("Baden-Wurttemberg", "Bavaria", "Saxony", "Hamburg", "Lower Saxony", "Bremen", "Berlin", "Saxony-Anhalt", "Hesse", "Saarland", "Thuringia", "Brandenburg", "Mecklenburg-Western Pomerania", "North Rhine-Westphalia", "Rhineland-Palatinate", "Schleswig-Holstein"), c("Baden-Wurttemberg", "Bavaria", "Saxony"), c("Hamburg", "Lower Saxony", "Bremen", "Berlin"), c("Saxony-Anhalt", "Hesse", "Saarland", "Thuringia"), c("Brandenburg", "Mecklenburg-Western Pomerania", "North Rhine-Westphalia", "Rhineland-Palatinate", "Schleswig-Holstein"))) {
   pal <- c()
   pal[adm.list] <- rainbow(length(adm.list))
      
   ymax <- max(data) * 1.1
   plotShadedAxes(xlim=c(sampleBreaks[1], sampleBreaks[length(sampleBreaks)-1]), 
                ylim=c(0, ymax), ylab="Rate of sequencing", yaxs='i', xaxs='i')
   
   for (countyIt in adm.list) {
      lines(sampleBreaks[1:(length(sampleBreaks)-1)], data[countyIt,], type='l', col=darken(pal[countyIt], 0.2))
   }
   
   
   legend("top", horiz=FALSE, inset=c(0,-0.0), bty='n', xpd=TRUE, ncol=4,
           fill=darken(pal[adm.list], 0.2), border = darken(pal[adm.list], 0.2),
           legend = adm.list,
           cex=0.8)
    
}

```
```{r seq-rate, fig.width=7, fig.height=3}

   data <- deCountyDaily %>% filter(date >= as.Date("2021-01-01")) %>% group_by(county) %>% dplyr::summarise(case = sum(case), seqs = sum(seqs)) %>% mutate(seq.rate = seqs/case) %>% 
      left_join(clusterSamplesMCC %>% group_by(adm1) %>% dplyr::summarise(analyzed.seq = n()), by = c("county" = "adm1")) %>%
      arrange(-seq.rate)

   print(kable(data, title="Seqencing rate per state, for sequences after 2021-01-01", col.names = c("State", "Case", "Sequence", "Sequencing rate", "Analyzed sequence")))
```


```{r case-by-county-important-county, fig.width=7, fig.height=3}

referenceDate <- as.Date("2021-02-01")
lin <- "B.1.1.7"
countyImportant <- c("Bavaria", "Baden-Wurttemberg", "North Rhine-Westphalia")

calculateWeek <- function(dates, referenceDate) {
   return(as.numeric(dates - referenceDate)%/%7)
}

inset_element <- function(p, left, bottom, right, top, align_to = 'panel', on_top = TRUE, clip = TRUE, ignore_tag = FALSE) {
  align_to <- match.arg(align_to, c('panel', 'plot', 'full'))
  if (!is.unit(left)) {
    left <- unit(left, 'npc')
  }
  if (!is.unit(bottom)) {
    bottom <- unit(bottom, 'npc')
  }
  if (!is.unit(right)) {
    right <- unit(right, 'npc')
  }
  if (!is.unit(top)) {
    top <- unit(top, 'npc')
  }
  if (!is.ggplot(p)) {
    p <- wrap_elements(full = p, clip = FALSE)
  }
  if (!is.ggplot(p)) {
    p <- wrap_elements(full = p, clip = clip)
  }
  clip <- if (clip) 'on' else 'off'
  attr(p, 'settings') <- list(left = left, bottom = bottom, right = right,
                           top = top, align_to = align_to, on_top = on_top,
                           clip = clip, ignore_tag = ignore_tag)
  class(p) <- c('inset_patch', class(p))
  p
}

legend.map.color <- sdePal
      
germany <- raster::getData("GADM", country = "DEU", level = 1)
germany.f <- fortify(germany, region = "CC_1")

mapNames <- germany$VARNAME_1
mapNames[is.na(mapNames)] <- germany$NAME_1[is.na(mapNames)]
mapNames[mapNames == "Baden-WÃ¼rttemberg"] <- "Baden-Wurttemberg"
mapNames[mapNames == "Mecklenburg-West Pomerania"] <- "Mecklenburg-Western Pomerania"

germany$NAME_1_EN <- germany$NAME_1
germany$NAME_1_EN[germany$NAME_1 == "Baden-WÃ¼rttemberg"] <- "Baden-Wurttemberg"
germany$NAME_1_EN[germany$NAME_1 == "Mecklenburg-Vorpommern"] <- "Mecklenburg-Western Pomerania"
germany$NAME_1_EN[germany$NAME_1 == "Bayern"] <- "Bavaria"
germany$NAME_1_EN[germany$NAME_1 == "Hessen"] <- "Hesse"
germany$NAME_1_EN[germany$NAME_1 == "Niedersachsen"] <- "Lower Saxony"
germany$NAME_1_EN[germany$NAME_1 == "Nordrhein-Westfalen"] <- "North Rhine-Westphalia"
germany$NAME_1_EN[germany$NAME_1 == "Rheinland-Pfalz"] <- "Rhineland-Palatinate"
germany$NAME_1_EN[germany$NAME_1 == "Sachsen"] <- "Saxony"
germany$NAME_1_EN[germany$NAME_1 == "Sachsen-Anhalt"] <- "Saxony-Anhalt"
germany$NAME_1_EN[germany$NAME_1 == "ThÃ¼ringen"] <- "Thuringia"

germany.f$value <- germany$NAME_1_EN[match(germany.f$id, germany$CC_1)]

pMap <- ggplot() + 
  geom_polygon(data = germany.f, aes(x = long, y = lat, group = group, fill = value), colour = "grey10", size = 0.1)+
  geom_polygon(data = germany.f[germany.f$id == "11",], aes(x = long, y = lat, group = group, fill = value), colour = "grey10", size = 0.1)+
  # scale_fill_gradient(low = lighten(col, 1), high = col, space = "Lab", limits=c(0, 1),
  #                     name = "legend_title")+
  # ggtitle("State colors") +
  # options(repr.plot.width=max(germany.f$lat) - min(germany.f$lat), repr.plot.height=max(germany.f$long) - min(germany.f$long)) +
  theme(axis.line=element_blank(), axis.text.x=element_blank(),
        axis.text.y=element_blank(), axis.ticks=element_blank(),
        axis.title.x=element_blank(),
        axis.title.y=element_blank(),
        panel.background=element_blank(), panel.grid.major=element_blank(),
        # panel.border = element_rect(colour = "black", fill=NA, size=0.1),
        panel.grid.minor=element_blank(), plot.background=element_blank(), 
        aspect.ratio = (max(germany.f$long) - min(germany.f$long))/(max(germany.f$lat) - min(germany.f$lat)),
        legend.position="none"
        ) + scale_fill_manual(values = legend.map.color)

stateImportant <- c("North Rhine-Westphalia", "Bavaria", "Baden-Wurttemberg")

data <- deCountyDaily %>% mutate(week = calculateWeek(as.Date(date), referenceDate)) %>% 
   mutate(county = ifelse(county %in% stateImportant, county, "Other")) %>%
   group_by(county, week) %>% dplyr::summarise(case = sum(case), seqs = sum(seqs)) %>%
   mutate(seq.rate = seqs / case, week_start = referenceDate + week * 7)
data2 <- deDaily %>% mutate(week = calculateWeek(as.Date(date), referenceDate)) %>% 
   group_by(week) %>% dplyr::summarise(case = sum(cases), seqs = sum(seqs)) %>%
   mutate(seq.rate = seqs / case, week_start = referenceDate + week * 7) %>% mutate(county = "Germany")
# marks__extended <- do.call(rbind.data.frame, marks_) %>% mutate(date = as.Date(date)) #%>% left_join(data, by=c("date" = "date"))

ymax <- 5

p <- ggplot(data %>% bind_rows(data2), aes(x=week_start, y=seq.rate, color = county)) +
 geom_line() + 
 scale_x_date(date_labels="%b %d", date_breaks = "7 day", minor_breaks = "1 day", limits = c(as.Date("2020-10-09"), as.Date("2021-05-20")), expand = c(0, 0)) +
 scale_color_manual(values = unlist(sdePal[c("Germany", countyImportant, "Other")]), name = "State") +
 labs(y = 'Sequencing rate\n(per week)', x= NULL) + 
 theme(axis.text.x = element_text(angle = 90, hjust = 1), 
       axis.title = element_text(size = 10),
     axis.line = element_line(color='black'), panel.grid.minor = element_blank(), legend.justification = "top", legend.spacing.y = unit(0, 'cm'), legend.key.size = unit(0.4, "cm")) +
  ylim(0, 0.20)

#+ annotation_custom(grob = textGrob("2020"), xmin = as.Date("2020-12-30"), xmax = as.Date("2020-12-30"), ymin = -0.01, ymax=-0.01)
print(p + inset_element(pMap, 1.0, -0.2, 1.5, 0.5))
grid.text("2020", x=unit(0.31, "npc"), y = unit(0.01, "npc"), just = c("left", "bottom"), gp = gpar(col="darkgray", fontsize=9))
grid.text("2021", x=unit(0.36, "npc"), y = unit(0.01, "npc"), just = c("left", "bottom"), gp = gpar(col="darkgray", fontsize=9))

```


```{r case-by-county-all-in-one-weekly, fig.width=5, fig.height=5, eval=TRUE}

hist.my <- function(x, breaks, weight = NULL) {
   if (is.null(weight)) {
      weight <- rep(1, length(breaks))
   }
   ret <- c();
   for (i in 1:(length(breaks)-1)) {
      ret <- c(ret, sum(weight[breaks[i] <= x & x < breaks[i+1]]))
   }
   return(ret);
}

chartBreakStart <- c(deCases$date[1], as.Date("2021-01-01"))
chartBreakEnd <- c(as.Date("2021-01-01"), deCases$date[length(deCases$date)]+7)

for (i in seq(2)) {
   # library(weights)
   # sampleBreaks <- seq.Date(deCases$date[1], deCases$date[length(deCases$date)]+7, by="week")
   sampleBreaks <- seq.Date(chartBreakStart[i], chartBreakEnd[i], by="week")
   
   
   pal <- dePal[levels(factor(deCountyDaily$county))] %>% unlist() %>% unname()
   
   data <- NULL
   dataSum <- c()
   for (countyIt in levels(factor(deCountyDaily$county))) {
      countyDaily <- deCountyDaily %>% dplyr::filter(county == countyIt) %>% dplyr::filter(date >= sampleBreaks[1] & date < sampleBreaks[length(sampleBreaks)])
      countyDaily_case <- hist.my(countyDaily$date, weight = countyDaily$case, breaks=sampleBreaks)
      countyDaily_seqs <- hist.my(countyDaily$date, weight = countyDaily$seqs, breaks=sampleBreaks)
      data <- rbind(data, countyDaily_seqs / countyDaily_case)
      dataSum <- c(dataSum, sum(countyDaily_seqs)/sum(countyDaily_case))
   }
   rownames(data) <- levels(factor(deCountyDaily$county))

   ymax <- max(data) * 1.1
   plotShadedAxes(xlim=c(sampleBreaks[1], sampleBreaks[length(sampleBreaks)-1]),
                ylim=c(0, ymax), ylab="Rate of sequencing", yaxs='i', xaxs='i')

   for (countyIt in levels(factor(deCountyDaily$county))) {
      lines(sampleBreaks[1:(length(sampleBreaks)-1)], data[countyIt,], type='l', col=dePal[[countyIt]])
   }


   legend("top", horiz=FALSE, inset=c(0,-0.0), bty='n', xpd=TRUE, ncol=4,
           fill=mPal(unlist(pal), 0.75), border = mPal(unlist(pal)),
           legend = levels(factor(deCountyDaily$county)),
           cex=0.8)
   
   data <- round(data * 1000, digits=2)
   colnames(data) <- sampleBreaks[1:(length(sampleBreaks)-1)]
   data <- as.data.frame(data) %>% cbind(round(dataSum * 1000, digits=2))

   print(knitr::kable(data, caption = paste("Weekly sequencing rate overal=", sum(countyDaily$seqs) / sum(countyDaily$case)) ))

   plot_on_map(rownames(data), dataSum * 1000, title=paste("sequncing rate for", chartBreakStart[i], chartBreakEnd[i]), legend_title = "Rate * 1000", col = "#3CB371", max_value = max(dataSum * 1000))

}


 
```
```{r case-by-county-this-year-table, fig.width=4, fig.height=4, eval=TRUE}
# library(weights)
sampleBreaks <- c(as.Date("2020-10-01"), deCases$date[length(deCases$date)])


pal <- dePal[levels(factor(deCountyDaily$county))] %>% unlist() %>% unname()

data <- NULL
for (countyIt in levels(factor(deCountyDaily$county))) {
   countyDaily <- deCountyDaily %>% dplyr::filter(county == countyIt) %>% dplyr::filter(date >= sampleBreaks[1] & date < sampleBreaks[length(sampleBreaks)])
   countyDaily_case <- hist.my(countyDaily$date, weight = countyDaily$case, breaks=sampleBreaks)
   countyDaily_seqs <- hist.my(countyDaily$date, weight = countyDaily$seqs, breaks=sampleBreaks)
   data <- rbind(data, countyDaily_seqs / countyDaily_case)
}
rownames(data) <- levels(factor(deCountyDaily$county))
# 
# ymax <- max(data) * 1.1
# plotShadedAxes(xlim=c(sampleBreaks[1], sampleBreaks[length(sampleBreaks)-1]), 
#              ylim=c(0, ymax), ylab="Rate of sequencing", yaxs='i', xaxs='i')
# 
# for (countyIt in levels(factor(deCountyDaily$county))) {
#    lines(sampleBreaks[1:(length(sampleBreaks)-1)], data[countyIt,], type='l', col=dePal[[countyIt]])
# }
# 
# 
# legend("top", horiz=FALSE, inset=c(0,-0.0), bty='n', xpd=TRUE, ncol=4,
#         fill=mPal(unlist(pal), 0.75), border = mPal(unlist(pal)),
#         legend = levels(factor(deCountyDaily$county)),
#         cex=0.8)

kable(round(100*data[order(-data[,1]),], 1), caption="Rate of sequenced genomes since 2021", col.names = c("Sequencing rate"))


plot_on_map(rownames(data), data, "Sequencing rate", "rate", col = "#3CB371") 


```

```{r confirmed cases, fig.width=4, fig.height=4}

startDate = as.Date("2021-02-01")
endDate = as.Date("2021-05-30")

for (m_d in c(0, 1, 2, 3)) {
   data <- deCountyDaily %>% dplyr::filter(date >= startDate + months(m_d),
                                           date <= startDate + months(m_d+1) - days(1)) %>%
      group_by(county) %>% dplyr::summarise(n = sum(case)) %>% filter(county != "NA") %>%
      left_join(deCounty %>% dplyr::select(state, population), by=c("county"="state")) %>% mutate(n.per.capita = n/population * 1e5)

   #confirmed cases
   plot_on_map(data$county, data$n, paste( startDate + months(m_d), " - ", startDate + months(m_d+1) - days(1)) ,
               "Count", col = "#2b83ba", max_value = 2e5)

   #confirmed cases per kapita
   plot_on_map(data$county, data$n.per.capita, paste( startDate + months(m_d) , " - ", startDate + months(m_d+1) - days(1) ) ,
            "case per capita * 100K", col = "#fdae61", max_value = 3000)

}


   data <- deCountyDaily %>% dplyr::filter(date >= startDate, 
                                           date <= endDate ) %>% 
      group_by(county) %>% dplyr::summarise(n = sum(case)) %>% filter(county != "NA") %>%
      left_join(deCounty %>% dplyr::select(state, population), by=c("county"="state")) %>% mutate(n.per.capita = n/population * 1e5)

   
   # paste("A) confirmed cases feb to may\n" )
   plot_on_map(data$county, data$n / 10000, "A", 
               "Count\n(x 10,000)", col = "#2b83ba", max_value = 320000 / 10000, legend.position = "bottom", text.font.size = NULL) 

    #confirmed cases per kapita
   plot_on_map(data$county, data$n.per.capita, paste( startDate , " - ", endDate ) ,
            "case per capita * 100K", col = "#fdae61", max_value = 3000)


```
```{r case-by-county-per-capita, fig.width=4, fig.height=4, eval=TRUE}

# for (m_d in c(0, 1, 2, 3)) {
#    data <- deCountyDaily %>% 
#       dplyr::filter(date >= as.Date("2021-02-01") + months(m_d), 
#                                            date <= as.Date("2021-02-01") + months(m_d+1) - days(1)) %>% 
#       group_by(county) %>% 
#       dplyr::summarise(n = sum(case)) %>% 
#       filter(county != "NA") %>% 
#       left_join(deCounty %>% dplyr::select(state, population), by=c("county"="state")) %>% 
#       mutate(n.per.capita = n/population)
#    
#    plot_on_map(data$county, data$n.per.capita, 
#                paste("confirmed cases per capita", endDate," -- ", m_d) , "Count per capita", col = "#00FFFF", 
#                min_value = min(data$n.per.capita), max_value = 0.015) 
# }

```


```{r sample-density, fig.width=6, fig.height=3, fig.cap = "Top row: Proportions of laborotory-confirmed cases sequenced. Bottom row: Proportions of the estimated number of infections (estimate from Flaxman et al. 2020)."}

#    layout(matrix(1:4, nrow = 2, byrow=FALSE))
#
#    idx <- which(ukWeekly$date == as.Date("2020-04-05"))
#
#    # Sequencing proportions
#    par(mar=c(0,0,1,2))
#    plotPieProp(ukWeekly$seqsCum[idx], ukWeekly$casesCum[idx], title="Reported cases by 5 April", col=ukPal$sct, line=0)
#    
#    par(mar=c(0,0,1,2))
#    plotPieProp(ukWeekly$seqsCum[idx], ukWeekly$infectionsCum[idx], title="Estimated infections by 5 April", col=ukPal$sct, line=0)
#    
#    idx <- which(ukWeekly$date == as.Date("2020-05-03"))
#
#    # Sequencing proportions
#    par(mar=c(0,0,1,2))
#    plotPieProp(ukWeekly$seqsCum[idx], ukWeekly$casesCum[idx], title="Reported cases by May 3", col=ukPal$sct, line=0)
#    
#    par(mar=c(0,0,1,2))
#    plotPieProp(ukWeekly$seqsCum[idx], ukWeekly$infectionsCum[idx], title="Estimated infections by May 3", col=ukPal$sct, line=0)
#

```

```{r sampling-proportion-weekly, fig.width=7, fig.height=3, fig.cap = "Proportion of weekly reported cases (solid line) and estimated infections (dotted line; Flaxman et al. 2020) included in our genome sequence dataset."}

#    cleanProp <- function(x) {
#        x[is.nan(x)] <- NA
#        x[is.infinite(x)] <- NA
#        x[x > 1] <- 1
#        return(x)
#    }
#
#    caseProp <- cleanProp(ukWeekly$seqs/ukWeekly$cases)
#    infProp  <- cleanProp(ukWeekly$seqs/ukWeekly$infections)
#    infMask  <- !is.na(infProp)
#
#    par(mar=c(4,6,2.5,6), cex.axis=0.7, cex.lab=0.8, mgp=c(3,0.75,0))
#
#    plotShadedAxes(xlim=c(startDate, as.Date("2020-06-21")), ylim=c(0, 1.015), yaxs='i', ylab="Proportion")
#  
#    #polygon(c(ukWeekly$date[infMask], rev(ukWeekly$date[infMask])), c(cleanProp(ukWeekly$seqs/ukWeekly$infectionsLower)[infMask], rev(cleanProp(ukWeekly$seqs/ukWeekly$infectionsUpper)[infMask])), 
#    #        col = mPal(ukPal$oth, 0.75), border=NA)
#    infPropLower <- cleanProp(ukWeekly$seqs/ukWeekly$infectionsLower)
#    infPropUpper <- cleanProp(ukWeekly$seqs/ukWeekly$infectionsUpper)
#    for (i in 2:length(infMask)) {
#        rect(ukWeekly$date[i-1], infPropLower[i], ukWeekly$date[i], infPropUpper[i], col = mPal(ukPal$oth, 0.75), border=NA)
#    }
#    lines(ukWeekly$date, infProp, lty=3, lwd=2, type='S')
#    idx <- min(which(infMask))
#    lines(ukWeekly$date[(idx-1):idx], rep(infProp[idx],2), lty=3, lwd=2)
#    lines(ukWeekly$date, caseProp, lty=1, lwd=2, type='S')
#    
#    
#    legend("bottom", horiz=FALSE, inset=c(0,1), bty='n', xpd=TRUE, ncol=2,
#           lty=c(1,3), lwd=2,
#           legend = c("reported cases", "estimated infections"), title="Sequenced proportion of weekly", cex=par("cex.lab"))
#    
#    # Inset start
#    ymax <- 0.1
#    insetStart <- as.Date("2020-02-16")
#    insetEnd   <- as.Date("2020-05-10")
#    
#    rect(insetStart, 0, insetEnd, ymax, lty=2)
#
#    par(mar=c(2,2,0.5,0.5), cex.axis=0.7, cex.lab=0.8, mgp=c(3,0.75,0), fig=c(0.445, 0.875, 0.45, 0.88), new=TRUE)
#    
#    plotShadedAxes(xlim=c(insetStart, insetEnd), ylim=c(0, ymax), yaxs='i', side=4)
#  
#    #polygon(c(ukWeekly$date[infMask], rev(ukWeekly$date[infMask])), c(cleanProp(ukWeekly$seqs/ukWeekly$infectionsLower)[infMask], rev(cleanProp(ukWeekly$seqs/ukWeekly$infectionsUpper)[infMask])), 
#    #        col = mPal(ukPal$oth, 0.75), border=NA)
#    for (i in 2:length(infMask)) {
#        rect(ukWeekly$date[i-1], infPropLower[i], ukWeekly$date[i], infPropUpper[i], col = mPal(ukPal$oth, 0.75), border=NA)
#    }
#    lines(ukWeekly$date, infProp, lty=3, lwd=2, type='S')
#    idx <- min(which(infMask))
#    lines(ukWeekly$date[(idx-1):idx], rep(infProp[idx],2), lty=3, lwd=2)
#    lines(ukWeekly$date, caseProp, lty=1, lwd=2, type='S')
#
#    rect(insetStart, 0, insetEnd, ymax, xpd=TRUE)
#
#
#    #plotShadedAxes(xlim=c(startDate, as.Date("2020-06-21")), ylim=c(0, 10000), yaxs='i')
#    #lines(ukCases$date, ukCases$newCasesBySpecimenDate)
#    
#    #dateFreqDistribution(rev(ukCases$newCasesBySpecimenDate[2:nrow(ukCases)]), rev(ukCases$date), startDate="2020-01-31", endDate="2020-06-21", barplot=TRUE)
    
```


```{r sampling-proportion-weekly-flipped, fig.width=7, fig.height=3, fig.cap = "Proportion of weekly reported cases (solid line) and estimated infections (dotted line; Flaxman et al. 2020) included in our genome sequence dataset."}

#    cleanProp <- function(x) {
#        x[is.nan(x)] <- NA
#        x[is.infinite(x)] <- NA
#        x[x > 1] <- 1
#        return(x)
#    }
#
#    caseProp <- cleanProp(ukWeekly$seqs/ukWeekly$cases)
#    infProp  <- cleanProp(ukWeekly$seqs/ukWeekly$infections)
#    infMask  <- !is.na(infProp)
#
#    par(mar=c(4,6,2.5,6), cex.axis=0.7, cex.lab=0.8, mgp=c(3,0.75,0))
#
#    plotShadedAxes(xlim=c(startDate, as.Date("2020-06-21")), ylim=c(0, 0.1), yaxs='i', ylab="Proportion")
#  
#    infPropLower <- cleanProp(ukWeekly$seqs/ukWeekly$infectionsLower)
#    infPropUpper <- cleanProp(ukWeekly$seqs/ukWeekly$infectionsUpper)
#    for (i in 2:length(infMask)) {
#        rect(ukWeekly$date[i-1], infPropLower[i], ukWeekly$date[i], infPropUpper[i], col = mPal(ukPal$oth, 0.75), border=NA)
#    }
#    lines(ukWeekly$date, infProp, lty=3, lwd=2, type='S')
#    idx <- min(which(infMask))
#    lines(ukWeekly$date[(idx-1):idx], rep(infProp[idx],2), lty=3, lwd=2)
#    lines(ukWeekly$date, caseProp, lty=1, lwd=2, type='S')
#    
#    
#    legend("bottomleft", horiz=FALSE, inset=c(0,1), bty='n', xpd=TRUE, ncol=2,
#           lty=c(1,3), lwd=2,
#           legend = c("reported cases", "estimated infections"), title="Sequenced proportion of weekly", cex=par("cex.lab"))
#
#    # Inset start
#    ymax <- 1
#    insetStart <- as.Date("2020-01-19")
#    insetEnd   <- as.Date("2020-06-21")
#    
#    #rect(insetStart, 0, insetEnd, ymax, lty=2)
#    
#    par(mar=c(2,2,0.5,0.5), cex.axis=0.7, cex.lab=0.8, mgp=c(3,0.75,0), fig=c(0.65, 0.95, 0.55, 0.95), new=TRUE)
#    
#    plotShadedAxes(xlim=c(insetStart, insetEnd), ylim=c(0, ymax), yaxs='i', side=2, smallBreaks = "weeks", thinXLabel = 4, thinYLabel=5)
#    
#    #polygon(c(ukWeekly$date[infMask], rev(ukWeekly$date[infMask])), c(cleanProp(ukWeekly$seqs/ukWeekly$infectionsLower)[infMask], rev(cleanProp(ukWeekly$seqs/ukWeekly$infectionsUpper)[infMask])),
#    #        col = mPal(ukPal$oth, 0.75), border=NA)
#    for (i in 2:length(infMask)) {
#        rect(ukWeekly$date[i-1], infPropLower[i], ukWeekly$date[i], infPropUpper[i], col = mPal(ukPal$oth, 0.75), border=NA)
#    }
#    lines(ukWeekly$date, infProp, lty=3, lwd=2, type='S')
#    idx <- min(which(infMask))
#    lines(ukWeekly$date[(idx-1):idx], rep(infProp[idx],2), lty=3, lwd=2)
#    lines(ukWeekly$date, caseProp, lty=1, lwd=2, type='S')
#    
#    rect(insetStart, 0, insetEnd, ymax, xpd=TRUE)
    
```


```{r sampling-proportion-weekly-infections, fig.width=7, fig.height=3, fig.cap = "Proportion of weekly estimated infections (Flaxman et al. 2020) included in our genome sequence dataset."}
#
#    cleanProp <- function(x) {
#        x[is.nan(x)] <- NA
#        x[is.infinite(x)] <- NA
#        x[x > 1] <- 1
#        return(x)
#    }
#
#
#    par(mar=c(4,6,2.5,6), cex.axis=0.7, cex.lab=0.8, mgp=c(3,0.75,0))
#
#    plotShadedAxes(xlim=c(startDate, as.Date("2020-06-21")), ylim=c(0, 0.1), yaxs='i', ylab="Proportion")
#
#    infProp  <- cleanProp(ukWeekly$seqs/ukWeekly$infections)
#    infMask  <- !is.na(infProp)
#    infPropLower <- cleanProp(ukWeekly$seqs/ukWeekly$infectionsLower)
#    infPropUpper <- cleanProp(ukWeekly$seqs/ukWeekly$infectionsUpper)
#    for (i in 2:length(infMask)) {
#        rect(ukWeekly$date[i-1], infPropLower[i], ukWeekly$date[i], infPropUpper[i], col = mPal(ukPal$oth, 0.75), border=NA)
#    }
#    lines(ukWeekly$date, infProp, lty=3, lwd=2, type='S')
#    idx <- min(which(infMask))
#    lines(ukWeekly$date[(idx-1):idx], rep(infProp[idx],2), lty=3, lwd=2)
#    
#    #legend("bottomleft", horiz=FALSE, inset=c(0,1), bty='n', xpd=TRUE, ncol=2,
#    #       lty=c(1,3), lwd=2,
#    #       legend = c("reported cases", "estimated infections"), title="Sequenced proportion of weekly", cex=par("cex.lab"))
#
#    
#    
```



```{r sampling-proportion-cumulative, fig.width=7, fig.height=3, fig.cap = "Proportion of the cumulative weekly reported cases (solid line) and estimated infections (dotted line; Flaxman et al. 2020) included in our genome sequence dataset over time."}
#
#    getCumulativeSequences <- function(dateRange, seqDates) {
#        
#        return <- data.frame(date = dateRange, 
#                             seqs = sapply(dateRange, function(x) sum(seqDates <= x)))
#    
#    }
#    
#    seqsCum     <- getCumulativeSequences(ukCases$date, metadata$sample_date[metadata$country == "UK"])
#    cumCaseProp <- cleanProp(seqsCum$seqs/ukCases$cumCasesBySpecimenDate)
#    
#    seqsCum     <- getCumulativeSequences(europeInfections$time[europeInfections$country == "United_Kingdom"], metadata$sample_date[metadata$country == "UK"])
#    cumInfProp  <- cleanProp(seqsCum$seqs/europeInfections$predicted_infections_mean_cumulative[europeInfections$country == "United_Kingdom"])
#    cumInfPropL <- cleanProp(seqsCum$seqs/europeInfections$predicted_infections_lower_CI_95_cumulative[europeInfections$country == "United_Kingdom"])
#    cumInfPropU <- cleanProp(seqsCum$seqs/europeInfections$predicted_infections_higher_CI_95_cumulative[europeInfections$country == "United_Kingdom"])  
#    
#    par(mar=c(4,6,2.5,6), cex.axis=0.7, cex.lab=0.8, mgp=c(3,0.75,0))
#    
#    plotShadedAxes(xlim=c(startDate, as.Date("2020-06-21")), ylim=c(0, 1.015), yaxs='i', ylab="Cumulative proportion")
#    
#    polygon(c(seqsCum$date, rev(seqsCum$date)), c(cumInfPropL, rev(cumInfPropU)), col = mPal(ukPal$oth, 0.75), border=NA)
#    lines(seqsCum$date, cumInfProp, lty=3, lwd=2)
#    lines(ukCases$date, cumCaseProp, lty=1, lwd=2)
#    
#    legend("bottom", horiz=FALSE, inset=c(0,1), bty='n', xpd=TRUE, ncol=2,
#           lty=c(1,3), lwd=2,
#           legend = c("reported cases", "estimated infections"), title="Sequenced proportion of cumulative", cex=par("cex.lab"))
#    
#    # Inset start
#    ymax <- 0.05
#    insetStart <- as.Date("2020-02-16")
#    insetEnd   <- as.Date("2020-05-10")
#    
#    rect(insetStart, 0, insetEnd, ymax, lty=2)
#    
#    par(mar=c(2,2,0.5,0.5), cex.axis=0.7, cex.lab=0.8, mgp=c(3,0.75,0), fig=c(0.445, 0.875, 0.45, 0.88), new=TRUE)
#    
#    plotShadedAxes(xlim=c(insetStart, insetEnd), ylim=c(0, ymax), yaxs='i', side=4)
#    
#    polygon(c(seqsCum$date, rev(seqsCum$date)), c(cumInfPropL, rev(cumInfPropU)), col = mPal(ukPal$oth, 0.75), border=NA)
#    lines(seqsCum$date, cumInfProp, lty=3, lwd=2)
#    lines(ukCases$date, cumCaseProp, lty=1, lwd=2)
#    
#    rect(insetStart, 0, insetEnd, ymax, xpd=TRUE)
#
```





```{r travel-cases-all, fig.width=5, fig.height=3, fig.cap="Estimated number of inbound travellers to the per day (black) and estimated number of infectious cases worldwide (dashed red, 7-day rolling average). Arrows here shows from left to right the first self-isolation advice for returning travellers from China, Italy, and the start of the national lockdown."}
#
#    par(mar=c(4,6,2.5,6), cex.axis=0.7, cex.lab=0.8, mgp=c(3.25,0.75,0))
#    plotArrivalsInfections(arrivals, infections, location="all", startDate = startDate, endDate = endDate, cex.lab=0.8)
#    
#    # Mark lockdown    
#    points(x=travelDates$lockdown, y=0.1*1E6, pch=175, font=5, cex=1.5, xpd=TRUE, col=mPal(ukPal$eng))
#    
#    # Mark self-isolation advice
#    points(x=travelDates$china, y=0.1*1E6, pch=175, font=5, cex=1.5, xpd=TRUE, col=mPal(countryPal$China))
#    points(x=travelDates$italy, y=0.1*1E6, pch=175, font=5, cex=1.5, xpd=TRUE, col=mPal(countryPal$Italy))
```



```{r travel-cases-countries-top12, fig.width=15, fig.height=12, fig.cap="Estimated numbers of inbound travellers to the `r state` per day, and estimated number of new infections per day, for the 12 countries we estimate to have been responsible for the most importations to the (see Table 3). We estimate that these 12 countries contributed 97.6% of importations to the `r states`"}
#
#    layout(matrix(c(1:12), nrow=4, byrow=TRUE))
#    par(mar=c(4,6,2.5,6), cex.axis=0.8, cex.lab=1.2, cex.main=1.5, mgp=c(3.25,0.5,0))
#
#    countries1 <- c("Spain", 
#                    "France", 
#                    "Italy",
#                    "US",
#                    "Netherlands",
#                    "Belgium",
#                    "Ireland", 
#                    "Germany",
#                    "Switzerland",
#                    "Portugal",
#                    "Sweden", 
#                    "China")
#    
#    # Specific countries
#    for (i in 1:length(countries1)) {
#        plotArrivalsInfections(arrivals, infections, location=countries1[i], startDate = startDate, endDate = endDate, cex.lab=0.8, label=LETTERS[i])
#        title(capitalise(countries1[i]))
#    }
    
```

```{r travel-cases-countries-other, fig.width=15, fig.height=12, fig.cap="Estimated numbers of inbound travellers to the `r states` per day, and estimated number of new infections per day, for a range of countries. (A-F) shows the 6 countries that made the largest contribution to importations after the 12 in the previous figure (see Table 3). Together these 6 countries contributed 1.19% of estimated importations to the `r states` (G-L) 6 countries with large epidemics that did not contribute many importations to the `r states`, either because of low numbers of inbound travellers or because their epidemics started later. These 6 countries combined contributed less than 0.5% of importations into `r states`."}
#
#    layout(matrix(c(1:12), nrow=4, byrow=TRUE))
#    par(mar=c(4,6,2.5,6), cex.axis=0.7, cex.lab=1.2, cex.main=1.5, mgp=c(3.25,0.5,0))
#
#    countries2 <- c("Denmark", "Austria", "Romania", "Norway", "Poland", "Canada", "Iran", "Brazil", "India", "Russia", "Mexico", "South Africa") # Japan, Korea, South
#    
#    # Specific countries
#    for (i in 1:length(countries2)) {
#        plotArrivalsInfections(arrivals, infections, location=countries2[i], startDate = startDate, endDate = endDate, cex.lab=0.8, label=LETTERS[i])
#        title(capitalise(countries2[i]))
#    }
#    
    
```


```{r eii-tmrca-all, fig.width=5, fig.height=3, fig.cap="Estimated importation intensity (EII) curve (black) and the histogram of lineage TMRCAs (grey). Arrows here shows from left to right the first self-isolation advice for returning travellers from China, Italy, and the start of the `r states` national lockdown."}


    #tmrcaBreaks <- seq.Date(as.Date("2019-12-01"), as.Date("2020-06-26"), by="days")
    # tmrcaBreaks <- seq.Date(min(clusterStatsMCC$tmrca_shifted_calendar), max(clusterStatsMCC$tmrca_calendar), by="1 days")
    # tmrca_hist  <- hist(clusterStatsMCC$tmrca_calendar, breaks=tmrcaBreaks, plot=FALSE, right=FALSE)   
    

    # par(mar=c(4,6,2.5,6), cex.axis=0.7, cex.lab=0.8, mgp=c(3,0.75,0))
    # dateFreqDistribution(tmrca_hist$counts, tmrcaBreaks, plot.ci=FALSE, side=4, ylab="",
    #                      #startDate = startDate, endDate = endDate, col=mPal(ukPal$oth), ymax=70)
    #                      startDate = tmrcaBreaks[1], endDate = tmrcaBreaks[length(tmrcaBreaks)-1], col=mPal(ukPal$oth), ymax=30)
    # mtext(side=4, text="Frequency of TMRCAs\n(per day)", line=3, cex=par("cex.lab"))
    # 
    # par(new=TRUE)
    # ymax <- 1200
    # 
    # plot(1, type='n', xlim=c(startDate, endDate), ylim=c(0,1200), axes=FALSE, 
    #      xaxs='i', yaxs='i', xlab="", ylab="")
    # lines(eii$date[eii$location == "all"], eii$num_intros[eii$location == "all"], lwd=2)
    # axis(2, las=1)
    # mtext(side=2, text="Estimated importation intensity\n(solid line)", line=2, cex=par("cex.lab"))
    # 
    # # Mark lockdown    
    # points(x=travelDates$lockdown, y=0.1*ymax, pch=175, font=5, cex=1.5, xpd=TRUE, col=mPal(ukPal$eng))
    # 
    # # Mark self-isolation advice
    # points(x=travelDates$china, y=0.1*ymax, pch=175, font=5, cex=1.5, xpd=TRUE, col=mPal(countryPal$China))
    # points(x=travelDates$italy, y=0.1*ymax, pch=175, font=5, cex=1.5, xpd=TRUE, col=mPal(countryPal$Italy))

```




```{r eii-tmrca-countries, fig.width=10, fig.height=8, fig.cap="Estimated importation intensity (EII) curves for the 12 countries estimated to have contributed the most importations to the `r states` epidemic (see Table 3). Panel A shows the EII for all countries. The red arrows indicate the start of the `r states` lockdown."}
#    
#    layout(matrix(c(1,2,5,6,3,4,7,8), nrow=4, byrow=TRUE), heights=c(3,1,3,1))
#    par(mar=c(4,6,2.5,6), cex.axis=1, cex.lab=1.2, cex.main=1.5, mgp=c(3,0.75,0))
#  
#    plotShadedAxes(xlim=c(startDate, endDate), ylim=c(0, 1200), axes=FALSE, label="A", line=0, yaxs='i', 
#                   ylab = "Estimated importation intensity")
#    lines(eii$date[eii$location == "all"], eii$num_intros[eii$location == "all"], lwd=2)
#    abline(v=as.Date(c("2020-03-12", "2020-03-16", "2020-03-20")), lty=3, col="black")
#    abline(v=as.Date("2020-03-23"), lty=1, col=ukPal$eng)
#    
#    #points(x=travelDates$lockdown, y=0.075*1200, pch=175, font=5, cex=1.5, xpd=TRUE, col=mPal(ukPal$eng))
#
#    
#    ymax <- list(B=500, C=100, D=20)
#    panelCountries <- list(B=c("Spain", "France", "Italy", "Belgium"), 
#                           C=c("Netherlands", "Ireland", "Switzerland", "US"), 
#                           D=c("Germany", "Sweden", "Portugal", "China", "Other"))
#    for (i in names(panelCountries)) {
#      
#      
#        plotCountries <- panelCountries[[i]]
#        
#        plotShadedAxes(xlim=c(startDate, endDate), ylim=c(0, ymax[[i]]), axes=FALSE, label=i, line=0, yaxs='i', 
#                       ylab = "Estimated importation intensity")
#    
#        for (country in plotCountries) {
#            lines(eii$date[eii$location == country], eii$num_intros[eii$location == country], col=mPal(countryPal[[country]]), lwd=2)
#            #points(eii$date[eii$location == country], eii$num_intros[eii$location == country], col=mPal(countryPal[[country]]), pch=20)
#        }
#        
#        legend('bottom', horiz=FALSE, inset=c(0, 1), bty='n', 
#               col = sapply(plotCountries, function(x) countryPal[[x]]), 
#               legend=plotCountries, 
#               ncol=ceiling(length(plotCountries)/2), seg.len=1, lwd=2, lty=1, xpd=TRUE, cex=par("cex.axis"))
#        
#        # Mark lockdown    
#        #points(x=travelDates$lockdown, y=0.075*ymax[[i]], pch=175, font=5, cex=1.5, xpd=TRUE, col=mPal(ukPal$eng))
#        abline(v=as.Date("2020-03-23"), lty=1, col=ukPal$eng)
#        
#        if (i == "B") { 
#            abline(v=as.Date("2020-02-25"), lty=3, col=countryPal$Italy)
#        } else 
#        if (i == "D") {
#            abline(v=as.Date("2020-01-28"), lty=3, col=countryPal$China)
#        }
#
#    }
#    
#    
#    
#    ###################################
#    # NPIs and travel recommendations #
#    ###################################
#    par(mar=c(1,6,0,6))
#
#    plot(1, type='n', ylim=c(0,8.5), xlim=c(startDate, endDate),
#         xaxs='i', yaxs='i', bty='n', axes=FALSE, xlab="", ylab="", las=2)
#    
#    # Self isolate if symptomatic (experiencing a cough or fever symptoms)
#    rect(as.Date("2020-03-12"), 6, endDate, 7, border=NA, col=mPal(ukPal$oth))
#    
#    # Social distancing encouraged (advice against non-essential travel and contact with others, 
#    # avoid pubs, clubs, theatres and work from home if possible)
#    rect(as.Date("2020-03-16"), 4.5, endDate, 5.5, border=NA, col=mPal(ukPal$oth))
#    
#    # School closure ordered, closure of public venues (pubs, restaurants, gyms, leisure centres, nightclubs, theatres, cinemas)
#    rect(as.Date("2020-03-20"), 3, endDate, 4, border=NA, col=mPal(ukPal$oth))
#    
#    # Lockdown
#    rect(as.Date("2020-03-23"), 1.5, endDate, 2.5, border=NA, col=mPal(ukPal$eng))
#    
#    text(x=endDate, y=7.5, "Non-pharmaceutical interventions ", cex=par("cex.lab"), pos=2)
#    text(x=endDate, y=c(2, 3.5, 5, 6.5)-0.1,
#           c("Lockdown", 
#             "School closure", 
#             "Social distancing", 
#             "Self-isolation"),
#         pos=2, srt=0, cex=par("cex.axis"), col="white", srt=0, xpd=TRUE)
#
#    
#    
#    
#    
#    plot(1, type='n', ylim=c(0,8.5), xlim=c(startDate, endDate),
#         xaxs='i', yaxs='i', bty='n', axes=FALSE, xlab="", ylab="", las=2)
#    
#    # Italy, Iran, Vietnam, Cambodia, Laos, Myanmar
#    rect(as.Date("2020-02-25"), 6, endDate, 7, border=NA, col=mPal(countryPal$Italy))
#    rect(as.Date("2020-02-25"), 6, as.Date("2020-03-05"), 7, border=NA, angle=45, density = 50, col="white")
#
#
#    text(x=endDate, y=7.5, "Self-isolation advice", cex=par("cex.lab"), pos=2)
#    text(x=endDate, y=6.5, "Italy", pos=2, srt=0, cex=par("cex.axis"), col="white", srt=0, xpd=TRUE)
#
#    
#        
#    plot(1, type='n', axes=FALSE, ylab="", xlab="")
#    
#    
#    
#    plot(1, type='n', ylim=c(0,8.5), xlim=c(startDate, endDate),
#         xaxs='i', yaxs='i', bty='n', axes=FALSE, xlab="", ylab="", las=2)
#
#    # China
#    rect(as.Date("2020-01-28"), 6, endDate, 7, border=NA, col=mPal(countryPal$China))
#    rect(as.Date("2020-01-28"), 6, as.Date("2020-01-31"), 7, border=NA, angle=45, density = 50, col="white")
#    
#    text(x=endDate, y=7.5, "Self-isolation advice", cex=par("cex.lab"), pos=2)
#    text(x=endDate, y=6.5, "China", pos=2, srt=0, cex=par("cex.axis"), col="white", srt=0, xpd=TRUE)
#
```


\clearpage


# Lineage importation distribution (shifted TMRCA distribution)
- GISAID tree until `r endDate` as initial tree.
- The tree is time-collibrated by TreeTime.
- Sankoff algorithm is used to assign location (`r states` and non-`r states`) to inner vertices of the tree, for each state sparately.
- Dataset contains 
  `r rsumstate(function(state, i, clusterStatsMCC) length(levels(as.factor(clusterStatsMCC$cluster))))` 
  transmission lineages (2 or more sequences), comprising 
  `r rsumstate(function(state, i, clusterStatsMCC)  sum(clusterStatsMCC$seqs))` 
  sequences from the `r states`, as well as a further 
  `r rsumstate(function(state, i, clusterStatsMCC)  sum(stateInfo$metadata_instate[,i]) - sum(clusterStatsMCC$seqs))` 
  singletons.
- Mean and SD of the importation (shifted TMRCA) distribution: 
  `r rsumstate(function(state, i, clusterStatsMCC) paste(round_date(date_decimal(mean(clusterStatsMCC$tmrca_shifted)), unit="day"), "Â±",  round(sd(clusterStatsMCC$tmrca_shifted)*366,3) ) )` days (singletons excluded).
- Median and interquartile range of the importation (shifted TMRCA) distribution `r rsumstate(function(state, i, clusterStatsMCC) round_date(date_decimal(median(clusterStatsMCC$tmrca_shifted)), unit="day") )` [`r rsumstate(function(state, i, clusterStatsMCC) round_date(date_decimal(quantile(clusterStatsMCC$tmrca_shifted, c(0.25, 0.75), na.rm=TRUE)), unit="day") )`] (singletons excluded).
- 80% of importations fall in [`r rsumstate(function(state, i, clusterStatsMCC) round_date(date_decimal(quantile(clusterStatsMCC$tmrca_shifted, c(0.1, 0.9), na.rm=TRUE)), unit="day") )`].



```{r shift-distribution, results="asis"}

  sizeShiftTable <- data.frame(size = c("All", "2 to 10", "11 to 100", "101 to 1000", "Bigger than 1000"))
  colnames(sizeShiftTable) <- c("Lineages of size")
  
  weekInfo <- list()

  for (s in 1:nrow(stateFiles)) {
    state <- stateFiles$state[s]
    clusterStatsMCC <- stateInfo$clusterStatsMCC[[s]] 
    clusterSamplesMCC <- stateInfo$clusterSamplesMCC[[s]] 

    sizeShifts <- list(all   = clusterStatsMCC$shift, 
                       small = clusterStatsMCC$shift[clusterStatsMCC$seqs <= 10],
                       med   = clusterStatsMCC$shift[clusterStatsMCC$seqs > 10 & clusterStatsMCC$seqs <= 100],
                       big   = clusterStatsMCC$shift[clusterStatsMCC$seqs > 100 & clusterStatsMCC$seqs <= 1000],
                       huge  = clusterStatsMCC$shift[clusterStatsMCC$seqs > 1000])

    sizeLags <- list(all   = clusterStatsMCC$detection_lag, 
                     small = clusterStatsMCC$detection_lag[clusterStatsMCC$seqs <= 10],
                     med   = clusterStatsMCC$detection_lag[clusterStatsMCC$seqs > 10 & clusterStatsMCC$seqs <= 100],
                     big   = clusterStatsMCC$detection_lag[clusterStatsMCC$seqs > 100 & clusterStatsMCC$seqs <= 1000],
                     huge  = clusterStatsMCC$detection_lag[clusterStatsMCC$seqs > 1000])


    weekShifts <- weekLags <- weekSizes <- list()
    weekBreaks <- seq.Date(startDate, endDate, by="weeks")
    for (i in 2:length(weekBreaks)) {
        weekShifts[[format.Date(weekBreaks[i-1], format="%y %b %d")]] <- clusterStatsMCC$shift[clusterStatsMCC$tmrca_shifted_calendar >=  weekBreaks[i-1] & 
                                                                      clusterStatsMCC$tmrca_shifted_calendar < weekBreaks[i]]
        weekLags[[format.Date(weekBreaks[i-1], format="%y %b %d")]]   <- clusterStatsMCC$detection_lag[clusterStatsMCC$tmrca_shifted_calendar >=  weekBreaks[i-1] & 
                                                                      clusterStatsMCC$tmrca_shifted_calendar < weekBreaks[i]]
        weekSizes[[format.Date(weekBreaks[i-1], format="%y %b %d")]]  <- clusterStatsMCC$seqs[clusterStatsMCC$tmrca_shifted_calendar >=  weekBreaks[i-1] & 
                                                                      clusterStatsMCC$tmrca_shifted_calendar < weekBreaks[i]]
    }
    
    sizeShiftTable <- cbind(sizeShiftTable, 
                            lineages = sapply(sizeShifts, length), 
                                 shiftMeanSD   = sapply(sizeShifts, function(x) paste0(round(mean(x),2), " Â± ", round(sd(x),2))), 
                                 ShiftMedIQR   = sapply(sizeShifts, function(x) paste0(round(median(x),2), " [", paste(round(quantile(x, c(0.25, 0.75), na.rm=TRUE),2), collapse="-"), "]")),
                                 lagMeanSD   = sapply(sizeLags, function(x) paste0(round(mean(x),2), " Â± ", round(sd(x),2))), 
                                 #lagMedIQR   = sapply(sizeLags, function(x) paste0(round(median(x),2), " [", paste(round(quantile(x, c(0.25, 0.75)),2), collapse="-"), "]")) )
                                 lagMedIQR   = sapply(sizeLags, function(x) paste0(round(median(x),2), " [", paste(round(quantile(x, c(0.25, 0.75), na.rm=TRUE),2), collapse="-"), "]")) )
    
    colnames(sizeShiftTable)[(ncol(sizeShiftTable)-5+1):ncol(sizeShiftTable)] <- c(paste("No. of lineages of ", state), 
                                  paste("Importation lag (mean Â± SD)", state), paste("Importation lag (median and IQR)", state), 
                                  paste("Detection lag (mean Â± SD)", state),   paste("Detection lag (median and IQR)", state))
    
    weekInfo[[s]] = list(weekShifts = weekShifts, weekLags = weekLags, weekSizes = weekSizes)
    weekShiftNames = names(weekShifts)

  }

    
    capSizeShifts            <- paste0("Estimated importation lags for ", "multistate", " transmission lineages of different sizes. Importation lag is the waiting time between importation date and the TMRCA of the sampled genomes in the transmission lineage. Detection lag is the waiting time from the importation date to the sampling time of the oldest (first) sampled genome in the transmission lineage.")
    
    kable(sizeShiftTable, row.names=FALSE, caption = capSizeShifts)
    cat(knitr::kable(sizeShiftTable, row.names=FALSE, caption = capSizeShifts, format="latex"), file = paste0(figpath, "shift-size-distribution.tex"))
    cat(knitr::kable(sizeShiftTable, row.names=FALSE, caption = capSizeShifts, format="html"),  file = paste0(figpath, "shift-size-distribution.html"))
    # write.csv(sizeShiftTable, file = paste0(figpath, "shift-size-distribution.csv"), row.names=FALSE, quote=FALSE)
    
    # cat(kable(sizeShiftTable[,c(1, seq(2, ncol(sizeShiftTable), 5))], row.names=FALSE, caption = capSizeShifts, format="html"))
    

    getMeanSDText <- function(x) {
        if (length(x) > 1) {
            paste0(round(mean(x),2), " Â± ", round(sd(x),2))
        } else 
        if (length(x) > 0) {
            round(x,2)
        } else {
            "-"
        }
    }
    
    getMedianIQRText <- function(x) {
        if (length(x) > 1) {
            paste0(round(median(x),2), " [", paste(round(quantile(x, c(0.25, 0.75), na.rm=TRUE),2), collapse="-"), "]")
        } else 
        if (length(x) > 0) {
            round(x,2)
        } else {
            "-"
        }
    }
    
    cat("\n\\clearpage\n")
    
    
    weekShiftTable <- data.frame(week = weekShiftNames, 
                                 epiweek  = date_epiweek(weekBreaks[1:(length(weekBreaks)-1)]))
    colnames(weekShiftTable) <- c("Week starting", "Epi-week")

  for (s in 1:nrow(stateFiles)) {
    state <- stateFiles$state[s]

    weekShifts <- weekInfo[[s]]$weekShifts
    weekLags <- weekInfo[[s]]$weekLags
    weekSizes <- weekInfo[[s]]$weekSizes
    
    weekShiftTable <- cbind(weekShiftTable, 
                                 lineages = sapply(weekShifts, length), 
                                 #seqs     = sapply(weekSizes, getMeanSDText),
                                 seqs     = sapply(weekSizes, getMedianIQRText),
                                 shifts   = sapply(weekShifts, getMeanSDText),
                                 lags     = sapply(weekLags,   getMeanSDText))
                                 #medIQR   = sapply(weekShifts, function(x) {
                                  #                  if (length(x) > 0) {
                                  #                      paste0(round(median(x),2), " [", paste(round(quantile(x, c(0.25, 0.75)),2), collapse=", "), "]")
                                  #                  } else {
                                  #                      "-"
                                  #                  }}))
                                 
    colnames(weekShiftTable)[(ncol(weekShiftTable)-4+1):ncol(weekShiftTable)] <- c(
        paste("Estimated no. of importations of", state), 
        paste("Lineage sizes (median and IQR)", state), 
        paste("Importation lag (mean Â± SD)", state), paste("Detection lag (mean Â± SD)", state))

  }
    capWeekShifts            <- paste0("3. Estimated importation and detection lags for ", state, " transmission lineages ordered by importation date and aggregated by epi-week. Importation lag is the waiting time between importation date and the TMRCA of the sampled genomes in the transmission lineage. Detection lag is the waiting time from the importation date to the sampling time of the oldest (first) sampled genome in the transmission lineage. All statistics show means and standard deviations computed from the MCC trees.")
    
    kable(weekShiftTable, row.names=FALSE, caption = capWeekShifts)
    cat(knitr::kable(weekShiftTable, row.names=FALSE, caption = capWeekShifts, format="latex"), file = paste0(figpath, "shift-week-distribution.tex"))
    cat(knitr::kable(weekShiftTable, row.names=FALSE, caption = capWeekShifts, format="html"),  file = paste0(figpath, "shift-week-distribution.html"))
    # write.csv(weekShiftTable, file = paste0(figpath, "shift-week-distribution.csv"), row.names=FALSE, quote=FALSE)


```

```{r importation-distribution-weekly, fig.width=7, fig.height=5, fig.cap="Boxplots of the estimated importation lags for `r states` transmission lineages ordered by importation date and aggregated by epi-week."}
  for (s in 1:nrow(stateFiles)) {
    state <- stateFiles$state[s]
    weekShifts <- weekInfo[[s]]$weekShifts
    par(mar=c(5,6,2.5,6), cex.axis=0.7, cex.lab=0.8, mgp=c(3,0.75,0))
    plotStats(weekShifts, ylim=c(0,20), names=names(weekShifts), ylab="Importation lag", las=2, ny=16, xlab=paste("TMRCAs for week starting on", "(", state, ")"))
  }
```

```{r detection-distribution-weekly, fig.width=7, fig.height=5, fig.cap="Boxplots of the estimated detection lags for `r states` transmission lineages ordered by importation date and aggregated by epi-week."}
  for (s in 1:nrow(stateFiles)) {
    state <- stateFiles$state[s]
    weekLags <- weekInfo[[s]]$weekLags

    par(mar=c(5,6,2.5,6), cex.axis=0.7, cex.lab=0.8, mgp=c(3,0.75,0))
    plotStats(weekLags, ylim=c(0,110), names=names(weekLags), ylab="Detection lag", las=2, ny=16, xlab=paste("TMRCAs for week starting on", "(", state, ")"))
}
```



```{r tmrca-shift-comparison, fig.width=5, fig.height=3, fig.cap="Estimated importation intensity (EII) curve (black) and the histogram of lineage TMRCAs (grey) and shifted TMRCAs representing importaitons (red). Arrow here shows the start of the `r states` lockdown."}

    # tmrca_hist         <- hist(clusterStatsMCC$tmrca_calendar, breaks=tmrcaBreaks, plot=FALSE, right=FALSE)   
    # tmrca_hist_shifted <- hist(clusterStatsMCC$tmrca_shifted_calendar, breaks=tmrcaBreaks, plot=FALSE, right=FALSE)   
    
#     plotEnd <- endDate
#     
#     par(mar=c(4,6,2.5,6), cex.axis=0.7, cex.lab=0.8, mgp=c(3,0.75,0))
#     
#     dateFreqDistribution(tmrca_hist$counts, tmrcaBreaks, plot.ci=FALSE, side=4, ylab="", 
#                          #startDate = startDate, endDate = plotEnd, col=mPal(ukPal$oth), ymax=70)
#                          startDate = tmrcaBreaks[1], endDate = tmrcaBreaks[length(tmrcaBreaks)-1], col=mPal(ukPal$oth), ymax=1300)
#     
#     dateFreqDistribution(tmrca_hist_shifted$counts, tmrcaBreaks, plot.ci=FALSE, add=TRUE, 
#                          #startDate = startDate, endDate = plotEnd, col=mPal(ukPal$eng, 0.25), ymax=70)
#                          startDate = tmrcaBreaks[1], endDate = tmrcaBreaks[length(tmrcaBreaks)-1], col=mPal(ukPal$oth), ymax=1300)
#     
#     mtext(side=4, text="Frequency of TMRCAs\n(per day)", line=3, cex=par("cex.lab"))
# 
#     par(new=TRUE)
#     ymax <- 1200
#     plot(1, type='n', xlim=c(startDate, plotEnd), ylim=c(0,ymax), axes=FALSE, 
#          xaxs='i', yaxs='i', xlab="", ylab="")
# #    lines(eii$date[eii$location == "all"], eii$num_intros[eii$location == "all"], lwd=2)
#     axis(2, las=1)
#     mtext(side=2, text="Estimated importation intensity\n(solid line)", line=3, cex=par("cex.lab"))
#     
#     
#     # Mark lockdown    
#     points(x=travelDates$lockdown, y=0.1*ymax, pch=175, font=5, cex=1.5, xpd=TRUE, col=mPal(ukPal$eng))
```
    
        
```{r TMRCAs and shifted TMRCAs, fig.width=7, fig.height=4, fig.cap="TMRCAs and shifted TMRCAs", eval=TRUE}

#   for (s in stateInfo$stateOrder ) {
#     state <- stateFiles$state[s]
#     clusterStatsMCC <- stateInfo$clusterStatsMCC[[s]] 
#     
#     tmrcaBreaks <- seq.Date(min(clusterStatsMCC$tmrca_shifted_calendar), max(clusterStatsMCC$tmrca_calendar), by="week")
# 
# #    layout(matrix(1:2, nrow=2, byrow=TRUE))
#     par(mar=c(4,6,2.5,6), cex.axis=0.7, cex.lab=0.8, cex.main=1.5, mgp=c(3,0.75,0))
# 
#     tmrcaStat <- c("tmrca_calendar", "tmrca_shifted_calendar")
# 
#     plotStart <- tmrcaBreaks[31]
#     plotEnd <- tmrcaBreaks[length(tmrcaBreaks)-1]
#     ylabs <- c("Frequency of TMRCAs\n(per week)", "Frequency of importation events\n(per week)")
#     
#     
#     for (i in 1:length(tmrcaStat)) {
#    
#         cond <- clusterStatsMCC[, tmrcaStat[i]] >= tmrcaBreaks[1] & clusterStatsMCC[, tmrcaStat[i]] <= tmrcaBreaks[length(tmrcaBreaks)]
# 
#         tmrca_hist_small <- hist(clusterStatsMCC[cond , tmrcaStat[i]], breaks=tmrcaBreaks, plot=FALSE, right=FALSE)   
#         tmrca_hist_breakdown <- data.frame( small = tmrca_hist_small$counts)
#         
#          dateFreqDistribution(t(tmrca_hist_breakdown), tmrcaBreaks, plot.ci=FALSE, barplot=TRUE,  ylab=ylabs[i],
#                              startDate = plotStart, endDate = plotEnd, 
#                                      col="#c51b7d", border="#969696", ymax=25)
# 
#     }
#   }
    
```



\clearpage

# Session info

```{r sessionInfo, results='markup'}
    sessionInfo()
```
