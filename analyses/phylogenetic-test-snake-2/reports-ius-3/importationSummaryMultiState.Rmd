---
title: "SARS-CoV-2 State Introductions"
subtitle: "Importation Summary for states"
date: '`r format(Sys.time(), "Last modified: %d %b %Y")`'
output:
  pdf_document:
    toc: true
    toc_depth: 3
    number_sections: true
    keep_tex: false
    fig_crop: false
layout: page
editor_options: 
  chunk_output_type: inline
params: 
  inputpath       :  "../../../data/phylogenetic/"
  casefile        : "../data/cases-rki-by-state.csv"
  infectionfile   : "../../../data/epidemiological/flaxman-results.csv"
  epimobilitypath : "../../epidemiological/results/"
  asymptomatic    : 31
  cluster_f       : "DTA"
  alpha           : 0.7189865
  beta            : 28.91369
  startDate       : "2020-10-01"
  endDate         : "2021-06-01"
  device          : "pdf"
  metadata        : "../../../../data/data/gisaid-20210602-metadata.tsv"
  outputfolder    : "../results/beast/run/lin-ius-3/"
  metadataAllSequences   : "../../../../data/data/gisaid-20210602-metadata.tsv"
---


```{r rsetup, include=FALSE}

  # metadata        : "../results/gisaid-20210602-metadata-sampled-unsampled.tsv"
  # outputpath      : "../results/trees-gisaid-Hamburg-20210417-lin-rich/"
  # state           : "Hamburg"
  
    library(lubridate)
    library(plyr)
    library(gplots)
    library(beastio)
    library(knitr)
    library(tictoc)
    library(stringr)
    library(tidyr)
    source("../reports/palettes.R")
    source("../reports/plotutils.R")
    source("../reports/clusterutils.R")
    source("../reports/reportutils.R")
    library(shape)
    library(dplyr)
    library(colorspace)

    library(gridBase)
    library(grid)

    inputpath    <- params$inputpath
    casefile     <- params$casefile
    infectionfile<- params$infectionfile
    epipath      <- params$epimobilitypath
    mobilitypath <- params$epimobilitypath
    asymptomatic <- params$asymptomatic
    cluster_f    <- params$cluster_f
    alpha        <- params$alpha
    beta         <- params$beta
    
    startDate    <- as.Date(params$startDate)
    endDate      <- as.Date(params$endDate)
  
    outputfolder <- params$outputfolder
    # outputpath   <- params$outputpath
    # state        <- params$state

    figpath      <- paste0(outputfolder, "figures/importation_figures_", params$device, "/")
    dir.create(figpath, recursive = TRUE, showWarnings = FALSE)
    
    cachepath  <- paste0(outputfolder, "figures/cache/importationSummary_", params$device, "/")


    knitr::opts_chunk$set(tidy=FALSE, cache=FALSE, cache.path = cachepath,
                          dev=params$device, fig.path=figpath, dpi=300,
                          message=FALSE, error=TRUE, warning=TRUE, echo=FALSE)
    
    plotList     <- c("China",
                      "Italy",
                      "Spain", 
                      "France", 
                      "Belgium",
                      "Netherlands",
                      "Ireland", 
                      "Switzerland", 
                      "US")

    travelDates <- list(china    = as.Date("2020-01-28"), 
                        italy    = as.Date("2020-02-25"), 
                        lockdown = as.Date("2020-03-23"))

    ############
    # Metadata #
    ############
    #metadata              <- read.csv(paste0(inputpath, "metadata.csv"))
    metadata <- read.table(params$metadata, sep="\t", head=TRUE, na.strings=c("NA", ""), fill=TRUE, stringsAsFactors=FALSE, quote="|")
    metadata <- metadata[metadata$Virus.name != "Virus.name",]
    metadata$sample_date_orig  <- ymd(metadata$Collection.date)
    # metadata$sample_date  <- ymd(metadata$date_corrected)
    metadata$sample_date  <- metadata$sample_date_orig
    metadata$decimal_date <- decimal_date(metadata$sample_date)    
    metadata$taxon_label  <- metadata$Accession.ID
    metadata$country  <- str_trim(sapply(str_split(metadata$Location, "/"), "[[", 2))
    # metadata$state    <- str_trim(sapply(str_split(paste0(metadata$Location,"/",metadata$Additional.location.information), "/"), "[[", 3))
    metadata$adm1 <- sapply(str_split(paste0(metadata$Location,"/",metadata$Additional.location.information), "/"), function(x) str_trim(x[3]) )

    set_instate <- function(metadata, state) {
      return(sapply(str_split(paste0(metadata$Location,"/",metadata$Additional.location.information), "/"), function(x) {return(str_trim(x[2]) == "Germany" & (grepl(state, x[3], fixed=TRUE) | ( length(x) >= 4 & grepl(state, x[4], fixed=TRUE) )) );}))
    }
    # metadata$instate      <- set_instate(metadata, state)

    metadataAllSequences <- load_metadata(params$metadataAllSequences)
    

    smooth <- function(cs) {
      x <- cs
      x[8:length(x)] <- (cs[8:length(x)] - cs[1:(length(x)-7)])/7
      x[1:7] <- cs[1:7] / 1:7
      return(x);
    }
    
    # case_data <- read.csv(params$casefile)
    # case_data$case <- smooth(case_data$sum_cases)
    # case_data$date <- ymd(as.POSIXct(case_data$time_iso8601))
    # case_data$seq <- sapply(case_data$date, function(x) sum(!is.na(metadata$sample_date_orig) & metadata$sample_date_orig == x & metadata$instate))
    # case_data$seq_smooth <- smooth(cumsum(case_data$seq))

    stateFiles = data.frame(state = c("Germany"), 
                            state.name = c("Germany"),
                            adm.level = c(2),
                            outputpath=c("../results/beast/run/lin-ius-3/") )
                            # outputpath=c("../results/beast/run/lin/") )
                            # outputpath=c("../results/beast/run/lin-rich-sk/") )
    stateInfo <- list()
    stateInfo$metadata_instate <- data.frame(matrix(0, nrow=nrow(metadata), ncol=0))
    for (i in 1:nrow(stateFiles)) {
      state <- stateFiles$state[i]
      state.name <- stateFiles$state.name[i]
      # DEBUG TODO
      #stateInfo$metadata_instate <- cbind(stateInfo$metadata_instate, rep(FALSE, nrow(metadata)))
      if (stateFiles$adm.level[i] == 3)
        stateInfo$metadata_instate <- cbind(stateInfo$metadata_instate, set_instate(metadata, state.name))
      else if (stateFiles$adm.level[i] == 2)
        stateInfo$metadata_instate <- cbind(stateInfo$metadata_instate, metadata$country == state)
      colnames(stateInfo$metadata_instate)[ncol(stateInfo$metadata_instate)] <- state
    }

    stateInfo$stateOrder <- c(1)
    
    # for comments and documents before codes.
    states <- paste(stateFiles$state)

    rsumstate <- function(f) {
      return(sapply(seq(nrow(stateFiles)), function(s) { return (paste(stateFiles$state[s], ":", f(stateFiles$state[s], s, stateInfo$clusterStatsMCC[[s]]))); }))
    }
    
    shortStateName = list(
       # 'North Rhine-Westphalia' = 'NRW', 
       "Baden-Wurttemberg" = "BW", 
       # "Baden-Württemberg" = "BW",
       "Bavaria" = "BY",
       "Berlin" = "BE",
       "Brandenburg" = "BB",
       "Bremen" = "HB",
       "Hamburg" = "HH",
       "Hesse" = "HE",
       "Lower Saxony" = "NI",
       "Mecklenburg-Western Pomerania" = "MV",
       "North Rhine-Westphalia" = "NW",
       "Rhineland-Palatinate" = "RP",
       "Saarland" = "SL",
       "Saxony" = "SN",
       "Saxony-Anhalt" = "ST",
       "Schleswig-Holstein" = "SH",
       "Thuringia" = "TH",
       "NA" = "NA")
    
```


# Summary
This notebook plots figures about the dataset, applies the importation lag model to the `r states` transmission lineage TMRCAs and plots figures with lineage importations. 

## Data and Method
- GISAID tree until ???? as initial tree.
- The tree contains ??? `r state` sequences.
- The tree is time-calibrated by TreeTime.
- Sankoff algorithm is used to assign location (`r states` and non-`r states`) to inner vertices of the tree.




```{r load-data, cache=TRUE}

stateInfo$clusterStatsMCC <- stateInfo$clusterSamplesMCC <- list()
for (i in 1:nrow(stateFiles)) {
   state <- stateFiles$state[i]
   outputpath <- stateFiles$outputpath[i]
   
   
   #################################
   # Load and shift lineage TMRCAs #
   #################################
   #clusterStats      <- read.csv(paste0(outputpath, "clusters_", cluster_f, ".csv"))
   #clusterStatsMCC   <- read.csv(paste0(outputpath, "clusters_", cluster_f, "_MCC_0.5.csv"))
   # clusterStatsMCC   <- read.csv(paste0(outputpath, "clusters_", cluster_f, "_MCC.csv"))
   clusterStatsMCC   <- read.table(paste0(outputpath, "clusters_", cluster_f, "_MCC_0.5.tsv"), sep="\t", head=TRUE, na.strings=c("NA", ""), fill=TRUE, stringsAsFactors=FALSE, quote="|")
   #clusterSamplesMCC <- read.csv(paste0(outputpath, "clusterSamples_", cluster_f, "_MCC_0.5.csv"))
   # clusterSamplesMCC <- read.csv(paste0(outputpath, "clusterSamples_", cluster_f, "_MCC.csv"))
   clusterSamplesMCC <- read.table(paste0(outputpath, "clusterSamples_", cluster_f, "_MCC_0.5.tsv"), sep="\t", head=TRUE, na.strings=c("NA", ""), fill=TRUE, stringsAsFactors=FALSE, quote="|")
   
   clusterStatsMCC$cluster <- sapply(clusterStatsMCC$cluster, function(cluster) paste(strsplit( gsub("-", "_", cluster), split="_")[[1]][c(3,6,7)], collapse="_"))
   clusterSamplesMCC$cluster <- sapply(clusterSamplesMCC$cluster, function(cluster) paste(strsplit( gsub("-", "_", cluster), split="_")[[1]][c(3,6,7)], collapse="_"))
   
   clusterSamplesMCC$country  <- str_trim(sapply(str_split(clusterSamplesMCC$Location, "/"), "[[", 2))
   lineageSizes <- sort(table(clusterSamplesMCC$cluster))
   clusterSamplesMCC$lineage_seqs            <- sapply(as.character(clusterSamplesMCC$cluster), function(x) lineageSizes[x])
   clusterSamplesMCC$lineage_oldest          <- sapply(seq_len(nrow(clusterSamplesMCC)), function(x) 
      ifelse(clusterSamplesMCC$lineage_seqs[x] == 1, NA, clusterStatsMCC$oldest[clusterStatsMCC$cluster == as.character(clusterSamplesMCC$cluster[x])]))
   clusterSamplesMCC$adm1 <- sapply(
  str_split(paste0(clusterSamplesMCC$Location,"/",clusterSamplesMCC$Additional.location.information), "/"), function(x) str_trim(x[3]) )
   clusterSamplesMCC$adm1 <- ifelse(clusterSamplesMCC$adm1 == "Baden-Württemberg", "Baden-Wurttemberg", clusterSamplesMCC$adm1)
   
   # clusterStats$tmrca_calendar    <- ymd(clusterStats$tmrca_calendar)
   clusterStatsMCC$tmrca_calendar <- ymd(clusterStatsMCC$tmrca_calendar)
   #clusterSamplesMCC$sample_date  <- ymd(clusterSamplesMCC$sample_date)
   
   clusterStatsMCC$shift <- alpha + beta/clusterStatsMCC$seqs
   clusterStatsMCC$tmrca_shifted <- clusterStatsMCC$tmrca - (clusterStatsMCC$shift/366)
   clusterStatsMCC$tmrca_shifted_calendar <- as.Date(round_date(date_decimal(clusterStatsMCC$tmrca_shifted), unit = "day"))
   clusterStatsMCC$detection_lag <- as.Date(round_date(date_decimal(clusterStatsMCC$oldest), unit = "day")) - clusterStatsMCC$tmrca_shifted_calendar
   
   # #write.csv(clusterStatsMCC, paste0(outputpath, "clusters_", cluster_f, "_MCC_0.5_shifted.csv"), quote=FALSE, row.names=FALSE)
   # write.csv(clusterStatsMCC, paste0(outputpath, "clusters_", cluster_f, "_MCC_shifted.csv"), quote=FALSE, row.names=FALSE)
   
   
   stateInfo$clusterStatsMCC[[i]] = clusterStatsMCC
   stateInfo$clusterSamplesMCC[[i]] = clusterSamplesMCC
   
   
   #    ############################################
   #    # Germany weekly cases and estimated infections #
   #    ############################################
   #    
   #    ukCases      <- read.csv(casefile)
   #    ukCases$date <- as.Date(ukCases$date)
   #
   #    europeInfections      <- read.csv(infectionfile)
   #    europeInfections$time <- as.Date(europeInfections$time)
   #    
   #    weekBreaks <- seq.Date(as.Date("2020-01-19"), as.Date("2020-06-28"), by="weeks")
   #    ukWeekly   <- data.frame(date       = weekBreaks[2:length(weekBreaks)], 
   #                             seqs       = hist(metadata$sample_date[metadata$country == "UK"], breaks=weekBreaks, plot=FALSE, right=FALSE)$counts, 
   #                             cases      = getHistogram(ukCases$date, ukCases$newCasesBySpecimenDate,  
   #                                                       breaks=weekBreaks)$counts,
   #                             infections = getHistogram(europeInfections$time[europeInfections$country == "United_Kingdom"], 
   #                                                       europeInfections$predicted_infections_mean[europeInfections$country == "United_Kingdom"],
   #                                                       breaks=weekBreaks)$counts,
   #                             infectionsLower = getHistogram(europeInfections$time[europeInfections$country == "United_Kingdom"], 
   #                                                            europeInfections$predicted_infections_lower_CI_95[europeInfections$country == "United_Kingdom"],
   #                                                            breaks=weekBreaks)$counts,
   #                             infectionsUpper = getHistogram(europeInfections$time[europeInfections$country == "United_Kingdom"], 
   #                                                            europeInfections$predicted_infections_higher_CI_95_cumulative.1[europeInfections$country == "United_Kingdom"],
   #                                                            breaks=weekBreaks)$counts)
   #    ukWeekly$seqsCum       <- cumsum(ukWeekly$seqs)
   #    ukWeekly$casesCum      <- cumsum(ukWeekly$cases)
   #    ukWeekly$infectionsCum <- cumsum(ukWeekly$infections)
   #    ukWeekly$infectionsLowerCum <- cumsum(ukWeekly$infectionsLower)
   #    ukWeekly$infectionsUpperCum <- cumsum(ukWeekly$infectionsUpper)
   #    
   #    
   #    # dayBreaks <- seq.Date(as.Date("2020-01-19"), as.Date("2020-06-28"), by="day")
   #    # ukDaily   <- data.frame(date       = dayBreaks[2:length(dayBreaks)], 
   #    #                          seqs       = hist(metadata$sample_date[metadata$country == "UK"], breaks=dayBreaks, plot=FALSE, right=FALSE)$counts, 
   #    #                          cases      = getHistogram(ukCases$date, ukCases$newCasesBySpecimenDate,  
   #    #                                                    breaks=dayBreaks)$counts,
   #    #                          infections = getHistogram(europeInfections$time[europeInfections$country == "United_Kingdom"], 
   #    #                                                    europeInfections$predicted_infections_mean[europeInfections$country == "United_Kingdom"],
   #    #                                                    breaks=dayBreaks)$counts,
   #    #                          infectionsLower = getHistogram(europeInfections$time[europeInfections$country == "United_Kingdom"], 
   #    #                                                         europeInfections$predicted_infections_lower_CI_95[europeInfections$country == "United_Kingdom"],
   #    #                                                         breaks=dayBreaks)$counts,
   #    #                          infectionsUpper = getHistogram(europeInfections$time[europeInfections$country == "United_Kingdom"], 
   #    #                                                         europeInfections$predicted_infections_higher_CI_95_cumulative.1[europeInfections$country == "United_Kingdom"],
   #    #                                                         breaks=dayBreaks)$counts)
   #    # ukDaily$seqsCum       <- cumsum(ukDaily$seqs)
   #    # ukDaily$casesCum      <- cumsum(ukDaily$cases)
   #    # ukDaily$infectionsCum <- cumsum(ukDaily$infections)
   #    # ukDaily$infectionsLowerCum <- cumsum(ukDaily$infectionsLower)
   #    # ukDaily$infectionsUpperCum <- cumsum(ukDaily$infectionsUpper)
   #    
   #    
   #    
   #    #######
   #    # EII #
   #    #######
   #    
   #    eii      <- read.csv(paste0(epipath, "estimated-introduction-index-", asymptomatic, ".csv"))
   #    eii$date <- as.Date(eii$date)
   #    colnames(eii)[2] <- "location"
   #    eii$location <- revalue(eii$location, c("other"="Other"))
   #
   #    countryList <- levels(eii$location)
   #    countryList <- countryList[-which(countryList == "Other")]
   #    
   #    dates  <- sort(unique(eii$date))
   #    eiiAll <- data.frame(date       = dates, 
   #                         location   = rep("all", length(dates)),
   #                         num_intros = sapply(dates, function(x) sum(eii$num_intros[eii$date == x])))
   #    
   #    eii <- rbind(eiiAll, eii)
   #
   #    # plot(eii$date[eii$location == "all"], eii$num_intros[eii$location == "all"], type='l')
   #    # lines(eii$date[eii$location == "Spain"], eii$num_intros[eii$location == "Spain"], type='l', lty=2)
   #    # lines(eii$date[eii$location == "France"], eii$num_intros[eii$location == "France"], type='l', lty=2)
   #    
   #    
   #    #########################################
   #    # Estimated daily numbers of infections #
   #    #########################################
   #    
   #    infections <- read.csv(paste0(epipath, "estimated-daily-infections.csv"))
   #    infections$date <- as.Date(infections$date)
   #    
   #    infectionsSpecific <- remove <- c()
   #    for (country in countryList) {
   #      mask   <- which(infections$location == country)
   #      remove <- c(remove, mask)
   #      infectionsSpecific <- rbind(infectionsSpecific, infections[mask, ])
   #    }
   #    infectionsSpecific$location <- as.character(infectionsSpecific$location)
   #    
   #    dates <- sort(unique(infections$date))
   #    infectionsAll <- data.frame(date     = dates, 
   #                                num_infs = sapply(dates, function(x) sum(infections$num_infs[infections$date == x])),
   #                                location = rep("all", length(dates)))
   #    
   #    infections <- infections[-remove, ]
   #    infectionsOther <- data.frame(date     = dates, 
   #                                  num_infs = sapply(dates, function(x) sum(infections$num_infs[infections$date == x])),
   #                                  location = rep("Other", length(dates)))
   #    
   #    infections <- rbind(infectionsAll, rbind(infectionsSpecific, infectionsOther))
   #    
   #    # Smooth with 7-day rolling mean
   #    infections$num_infs_smoothed <- rep(0, nrow(infections))
   #    for (country in levels(infections$location)) {
   #      
   #      mask      <- which(infections$location == country)
   #      dateOrder <- mask[order(infections$date[mask])]
   #      
   #      infections$num_infs_smoothed[dateOrder] <- sapply(1:length(dateOrder), function(i) mean(infections$num_infs[dateOrder[max(i-3,1):min(i+3, length(dateOrder))]], na.rm = TRUE))
   #    }
   #    
   #    # Total number of infected in each country by the end of the dataset
   #    totalInfected <- sort(sapply(levels(infections$location), function(x) sum(infections$num_infs[infections$location == x], na.rm=TRUE)), decreasing = TRUE)
   #    
   #    # loc <- "Switzerland"
   #    # plot(infections$date[infections$location == loc], infections$num_infs[infections$location == loc], type='l', lty=2)
   #    # lines(infections$date[infections$location == loc], infections$num_infs_smoothed[infections$location == loc])
   #    
   #    
   #    ############################
   #    # Estimated daily arrivals #
   #    ############################
   #       
   #    arrivals <- read.csv(paste0(epipath, "estimated-arrivals.csv"))
   #    arrivals$date    <- as.Date(arrivals$date)
   #    arrivals$location <- revalue(arrivals$location, c("United States"  = "US",
   #                                                      "Czech Republic" = "Czechia",
   #                                                      "Dominican Rep"  = "Dominican Republic", 
   #                                                      "Korea (South)"  = "Korea, South"))
   #    
   #    arrivalsSpecific <- remove <- c()
   #    for (country in countryList) {
   #      mask   <- which(arrivals$location == country)
   #      remove <- c(remove, mask)
   #      arrivalsSpecific <- rbind(arrivalsSpecific, arrivals[mask, c("date", "location", "estimate")])
   #    }
   #    arrivalsSpecific$location <- as.character(arrivalsSpecific$location)
   #    
   #    dates <- sort(unique(arrivals$date))
   #    arrivalsAll <- data.frame(date     = dates, 
   #                              location = rep("all", length(dates)),
   #                              estimate = sapply(dates, function(x) sum(arrivals$estimate[arrivals$date == x])))
   #    
   #    arrivals <- arrivals[-remove, ]
   #    arrivalsOther <- data.frame(date     = dates, 
   #                                location = rep("Other", length(dates)),
   #                                estimate = sapply(dates, function(x) sum(arrivals$estimate[arrivals$date == x])))
   #    
   #    arrivals <- rbind(arrivalsAll, rbind(arrivalsSpecific, arrivalsOther))
   #    
   #    # Smooth with 7-day rolling mean
   #    arrivals$estimate_smoothed <- rep(0, nrow(arrivals))
   #    for (country in levels(arrivals$location)) {
   #      
   #      mask      <- which(arrivals$location == country)
   #      dateOrder <- mask[order(arrivals$date[mask])]
   #      
   #      arrivals$estimate_smoothed[dateOrder] <- sapply(1:length(dateOrder), function(i) mean(arrivals$estimate[dateOrder[max(i-3,1):min(i+3, length(dateOrder))]], na.rm = TRUE))
   #    }
   #    
   #    # plot(arrivals$date[arrivals$location == "Spain"], arrivals$estimate[arrivals$location == "Spain"], type='l')
   #    #lines(arrivals$date[arrivals$location == "Spain"], arrivals$estimate_smoothed[arrivals$location == "Spain"], type='l', lty=2)
   #    #lines(arrivals$date[arrivals$location == "France"], arrivals$estimate[arrivals$location == "France"], type='l', lty=2)
   #    
   #    
   #    #################################
   #    # Lag model parameter estimates #
   #    #################################
   
   # lagmodel <- read.csv(paste0(epipath, "tree-varying-lag-estimates.csv"))
   
}

```

\clearpage

# `r states` Sequenced Genomes


```{r sample-histogram, fig.width=7, fig.height=3, fig.cap = "Collection dates of the `nrow(metadata)` genomes analysed here (left-hand axis). Genomes are coloured by sampling location."}

   sampleBreaks <- seq.Date(startDate, 
                            max(metadata$sample_date_orig, na.rm = TRUE)+1, by="1 day")

   seq_hist_oth <- hist(metadata$sample_date_orig[metadata$sample_date_orig> startDate],  
                        breaks=sampleBreaks, plot=FALSE, right=FALSE)
   
   seq_hist_names <- c()
   seq_hist_breakdown <- data.frame(matrix(0, nrow=length(seq_hist_oth$counts), ncol=0))
   
   # seq_hist_names <- c(seq_hist_names, "all")
   # seq_hist_breakdown <- cbind(seq_hist_breakdown, seq_hist_oth$counts)
   
   for (s in 1:nrow(stateFiles)) {
      state <- stateFiles$state[s]
      seq_hist_state <- hist(metadata$sample_date_orig[stateInfo$metadata_instate[s] & metadata$sample_date_orig> startDate], 
                       breaks=sampleBreaks, plot=FALSE, right=FALSE)
      
      seq_hist_breakdown <- cbind(seq_hist_breakdown, seq_hist_state$count)
      seq_hist_names <- c(seq_hist_names, state)

      seq_hist_state <- hist(metadata$sample_date_orig[!stateInfo$metadata_instate[s] & metadata$sample_date_orig> startDate], 
                       breaks=sampleBreaks, plot=FALSE, right=FALSE)
      
      seq_hist_breakdown <- cbind(seq_hist_breakdown, seq_hist_state$count)
      seq_hist_names <- c(seq_hist_names, paste("Non", state))
   }
   
   colnames(seq_hist_breakdown) <- seq_hist_names
   
   # seq_hist_eng <- hist(metadata$sample_date[metadata$adm1 == "UK-ENG"], breaks=sampleBreaks, plot=FALSE, right=FALSE)
   # seq_hist_sct <- hist(metadata$sample_date[metadata$adm1 == "UK-SCT"], breaks=sampleBreaks, plot=FALSE, right=FALSE)
   # seq_hist_wls <- hist(metadata$sample_date[metadata$adm1 == "UK-WLS"], breaks=sampleBreaks, plot=FALSE, right=FALSE)
   # seq_hist_nir <- hist(metadata$sample_date[metadata$adm1 == "UK-NIR"], breaks=sampleBreaks, plot=FALSE, right=FALSE)
   # seq_hist_oth <- hist(metadata$sample_date[metadata$country != "UK"],  breaks=sampleBreaks, plot=FALSE, right=FALSE)

                                    
   # seq_hist_breakdown <- data.frame("eng" = seq_hist_eng$counts,
   #                                  "sct" = seq_hist_sct$counts,
   #                                  "wls" = seq_hist_wls$counts,
   #                                  "nir" = seq_hist_nir$counts,
   #                                  "oth" = seq_hist_oth$counts)
   
   draw_seq_freq_states <- function(selected_names, ymax = NA) {
     
     selected_columns <- seq_hist_names %in% selected_names
     if (is.na(ymax)) {
        if (sum(selected_columns) > 1) {
           ymax = max(rowSums(seq_hist_breakdown[,selected_columns])) * 1.05
        } else {
           ymax = max(seq_hist_breakdown[,selected_columns]) * 1.05
        }
     }
     
     if (sum(selected_columns) == 1)
       pal <- dePal[which(names(dePal) == seq_hist_names[selected_columns])]
     else {
       pal <- dePal[match(seq_hist_names, names(dePal))]
       pal <- pal[selected_columns]
     }
     
     cat(paste(pal))
     
     dateFreqDistribution(t(seq_hist_breakdown[,selected_columns]), sampleBreaks, plot.ci=FALSE, barplot=TRUE,
                          startDate = sampleBreaks[1], 
                          endDate = sampleBreaks[length(sampleBreaks)-1],    
                          col=mPal(unlist(pal), 0.75), border=mPal(unlist(pal)), ymax=ymax,
                          ylab = "Frequency of genomes\n(per day)")
     
     
     legend("top", horiz=FALSE, inset=c(0,-0.3), bty='n', xpd=TRUE, ncol=3,
            fill=mPal(unlist(pal), 0.75), border = mPal(unlist(pal)),
            legend = seq_hist_names[selected_columns],
            # legend = c("Germany", "Other countries"),
            #legend = c("England", "Scotland", "Wales"#FF7F00, "Northern Ireland", "Other countries"),
            cex=0.8)
     
   }
   
   # Sequence histogram
   par(mar=c(4,6,2.5,6), cex.axis=0.7, cex.lab=0.8, mgp=c(3,0.75,0))
   draw_seq_freq_states(c("Germany", "Non Germany"))
   draw_seq_freq_states(c("Germany"), ymax=max(seq_hist_breakdown[, "Germany"]) * 1.05)
   ymax=400 * 1.05
   # draw_seq_freq_states(c("Hamburg"), ymax=ymax)
   # draw_seq_freq_states(c("Bavaria"), ymax=ymax)
   # draw_seq_freq_states(c("North_Rhine-Westphalia"), ymax=ymax)
   # draw_seq_freq_states(c("Saarland"), ymax=ymax)
   # # draw_seq_freq_states(c("Saxony"))
   # draw_seq_freq_states(c("Lower_Saxony"), ymax=ymax)
   # 
   # draw_seq_freq_states(c("Munich"), ymax=ymax)
   # draw_seq_freq_states(c("Dusseldorf"), ymax=ymax)

   # # dateFreqDistribution(t(seq_hist_breakdown), sampleBreaks, plot.ci=FALSE, barplot=TRUE,
   # #                      startDate = sampleBreaks[1], endDate = sampleBreaks[length(sampleBreaks)-1], col=mPal(unlist(ukPal)[1], 0.75), border=mPal(unlist(ukPal))[1], ymax=1100,
   # #                      ylab = "Frequency of genomes\n(per day)")
   # 
   # dateFreqDistribution(t(seq_hist_breakdown), sampleBreaks, plot.ci=FALSE, barplot=TRUE,
   #                      startDate = sampleBreaks[1], 
   #                      endDate = sampleBreaks[length(sampleBreaks)-1],    
   #                      col=mPal(unlist(dePal), 0.75), border=mPal(unlist(dePal)), ymax=max(seq_hist_breakdown)+2,
   #                      ylab = "Frequency of genomes\n(per day)")
   # 
   

      # 
   # legend("top", horiz=FALSE, inset=c(0,-0.3), bty='n', xpd=TRUE, ncol=3,
   #        fill=mPal(unlist(ukPal), 0.75), border = mPal(unlist(ukPal)),
   #        legend = seq_hist_names,
   #        # legend = c("Germany", "Other countries"),
   #        #legend = c("England", "Scotland", "Wales", "Northern Ireland", "Other countries"),
   #        cex=0.8)
   # 
   # dateFreqDistribution(t(seq_hist_breakdown), sampleBreaks, plot.ci=FALSE, barplot=TRUE,
   #                      startDate = sampleBreaks[1], 
   #                      endDate = sampleBreaks[length(sampleBreaks)-1],    
   #                      col=mPal(unlist(dePal), 0.75), border=mPal(unlist(dePal)), ymax=max(seq_hist_breakdown)+2,
   #                      ylab = "Frequency of genomes\n(per day)")
   # 
   # 
   # 
   # legend("top", horiz=FALSE, inset=c(0,-0.3), bty='n', xpd=TRUE, ncol=3,
   #        fill=mPal(unlist(ukPal), 0.75), border = mPal(unlist(ukPal)),
   #        legend = seq_hist_names,
   #        # legend = c("Germany", "Other countries"),
   #        #legend = c("England", "Scotland", "Wales", "Northern Ireland", "Other countries"),
   #        cex=0.8)

   
   
   #   seq_hist_breakdown <- data.frame("de" = seq_hist_de$counts)  
   #   
   #   dateFreqDistribution(t(seq_hist_breakdown), sampleBreaks, plot.ci=FALSE, barplot=TRUE,
   #                      startDate = sampleBreaks[1], endDate = sampleBreaks[length(sampleBreaks)-1], col=mPal(unlist(dePal)[1], 0.75), border=mPal(unlist(dePal))[1], ymax=max(seq_hist_breakdown)+2,
   #                      ylab = "Frequency of genomes\n(per day)")
   # 
   # 
   # legend("top", horiz=FALSE, inset=c(0,-0.3), bty='n', xpd=TRUE, ncol=3,
   #        fill=mPal(unlist(ukPal), 0.75), border = mPal(unlist(ukPal)),
   #        legend = c(state, "Other places"),
   #        # legend = c("Germany", "Other countries"),
   #        #legend = c("England", "Scotland", "Wales", "Northern Ireland", "Other countries"),
   #        cex=0.8)

   normalize_hist <- function(counts, breaks, normalization_break, normalization_value) {
     hist_index <- match(breaks[-length(breaks)], normalization_break)
     hist_weighted <- counts * normalization_value[hist_index]
     valid_index <- !is.na(hist_weighted) & !is.nan(hist_weighted)
     hist_weighted <- hist_weighted[valid_index]
     valid_index[max(which(valid_index))+1] <- TRUE
     hist_breaks <- breaks[valid_index]
     return (list("hist"=hist_weighted, "breaks"=hist_breaks));
   }
   
   # x <- normalize_hist(seq_hist_de$counts, sampleBreaks, case_data$date, case_data$case / case_data$seq_smooth)
   # seq_hist_de_weighted = x$hist;
   # sampleBreaks_weighted = x$breaks;
   # 
   # # hist_index <- match(sampleBreaks[-length(sampleBreaks)], case_data$date)
   # # seq_hist_de_weighted <- seq_hist_de$counts / case_data$seq_smooth[hist_index] * case_data$case[hist_index]
   # # 
   # # valid_index <- !is.na(seq_hist_de_weighted) & !is.nan(seq_hist_de_weighted)
   # # seq_hist_de_weighted <- seq_hist_de_weighted[valid_index]
   # # valid_index[max(which(valid_index))+1] <- TRUE
   # # sampleBreaks_weighted <- sampleBreaks[valid_index]
   # 
   # seq_hist_breakdown <- data.frame("de" = seq_hist_de_weighted)  
   # 
   # # dateFreqDistribution(t(seq_hist_breakdown), sampleBreaks_weighted, plot.ci=FALSE, barplot=TRUE,
   # #                      startDate = sampleBreaks_weighted[1], endDate = sampleBreaks_weighted[length(sampleBreaks_weighted)-1], col=mPal(unlist(dePal)[1], 0.75), border=mPal(unlist(dePal))[1], ymax=50000,
   # #                      ylab = "Frequency of genomes\n(per day)")
   # # 
   # # 
   # # legend("top", horiz=FALSE, inset=c(0,-0.3), bty='n', xpd=TRUE, ncol=3,
   # #        fill=mPal(unlist(ukPal), 0.75), border = mPal(unlist(ukPal)),
   # #        legend = c("Germany", "Other countries"),
   # #        #legend = c("England", "Scotland", "Wales", "Northern Ireland", "Other countries"),
   # #        cex=0.8)
   # # 
   # # Cumulative sequences, cases and infections
   # # par(new = TRUE)
   # # ylims <- c(1,1E7)
   # # plot(1, type='n', xlim=c(startDate, as.Date("2020-06-21")), ylim=ylims,
   # #      axes=FALSE, xlab="", ylab="", log='y', yaxs='i', xaxs='i')
   # # 
   # # #axis(4, las=1, at=axTicks(4), labels=format(axTicks(4), scientific=FALSE))
   # # plotLogAxis(lim=ylims, side=4)
   # # mtext(side=4, text="Cumulative cases and genomes", line=2, cex=0.8)
   # 
   # 
   # #ukseqs_daily <- data.frame(date = sampleBreaks[1:(length(sampleBreaks)-1)],
   # #                          seqs = rowSums(seq_hist_breakdown[, -c(5)]))
   # #lines(ukseqs_daily$date, cumsum(ukseqs_daily$seqs), lwd=2)
   # 
   # # polygon(c(europeInfections$time[europeInfections$country == "United_Kingdom"],
   # #           rev(europeInfections$time[europeInfections$country == "United_Kingdom"])),
   # #         c(europeInfections$predicted_infections_higher_CI_95_cumulative[europeInfections$country == "United_Kingdom"],
   # #           rev(europeInfections$predicted_infections_lower_CI_95_cumulative[europeInfections$country == "United_Kingdom"])),
   # #           border=NA, col = mPal(ukPal$oth, 0.75))
   # # lines(europeInfections$time[europeInfections$country == "United_Kingdom"], europeInfections$predicted_infections_mean_cumulative[europeInfections$country == "United_Kingdom"],
   # #       lty=3, lwd=2)
   # #lines(c(ukCases$date, min(ukCases$date)-1), c(ukCases$cumCasesBySpecimenDate, 1E-10), lwd=2, lty=2)
   # 
   # # idx <- which(ukWeekly$date == as.Date("2020-05-17"))
   # # text(x = as.Date("2020-05-17"), y = ukWeekly$infectionsCum[idx]+5E6, "Estimated UK\ninfections",
   # #      pos=1, xpd=TRUE, cex=0.6)
   # # text(x = as.Date("2020-05-17"), y = ukWeekly$casesCum[idx]+1.5E5, "Reported UK\ncases",
   # #      pos=1, xpd=TRUE, cex=0.6)
   # # text(x = as.Date("2020-05-17"), y = ukWeekly$seqsCum[idx], "UK genomes\nsequenced",
   # #      pos=1, xpd=TRUE, cex=0.6)
   # 

```



```{r info, fig.width=6, fig.height=3}
   #First case of lineages with samples after 2021-02-01
   min(as.Date(round_date(date_decimal(clusterStatsMCC$oldest), unit="day"))[as.Date(round_date(date_decimal(clusterStatsMCC$mostrecent), unit="day")) > as.Date("2021-02-01")])

```



```{r sample-density, fig.width=6, fig.height=3, fig.cap = "Top row: Proportions of laborotory-confirmed cases sequenced. Bottom row: Proportions of the estimated number of infections (estimate from Flaxman et al. 2020)."}

#    layout(matrix(1:4, nrow = 2, byrow=FALSE))
#
#    idx <- which(ukWeekly$date == as.Date("2020-04-05"))
#
#    # Sequencing proportions
#    par(mar=c(0,0,1,2))
#    plotPieProp(ukWeekly$seqsCum[idx], ukWeekly$casesCum[idx], title="Reported cases by 5 April", col=ukPal$sct, line=0)
#    
#    par(mar=c(0,0,1,2))
#    plotPieProp(ukWeekly$seqsCum[idx], ukWeekly$infectionsCum[idx], title="Estimated infections by 5 April", col=ukPal$sct, line=0)
#    
#    idx <- which(ukWeekly$date == as.Date("2020-05-03"))
#
#    # Sequencing proportions
#    par(mar=c(0,0,1,2))
#    plotPieProp(ukWeekly$seqsCum[idx], ukWeekly$casesCum[idx], title="Reported cases by May 3", col=ukPal$sct, line=0)
#    
#    par(mar=c(0,0,1,2))
#    plotPieProp(ukWeekly$seqsCum[idx], ukWeekly$infectionsCum[idx], title="Estimated infections by May 3", col=ukPal$sct, line=0)
#

```

```{r sampling-proportion-weekly, fig.width=7, fig.height=3, fig.cap = "Proportion of weekly reported cases (solid line) and estimated infections (dotted line; Flaxman et al. 2020) included in our genome sequence dataset."}

#    cleanProp <- function(x) {
#        x[is.nan(x)] <- NA
#        x[is.infinite(x)] <- NA
#        x[x > 1] <- 1
#        return(x)
#    }
#
#    caseProp <- cleanProp(ukWeekly$seqs/ukWeekly$cases)
#    infProp  <- cleanProp(ukWeekly$seqs/ukWeekly$infections)
#    infMask  <- !is.na(infProp)
#
#    par(mar=c(4,6,2.5,6), cex.axis=0.7, cex.lab=0.8, mgp=c(3,0.75,0))
#
#    plotShadedAxes(xlim=c(startDate, as.Date("2020-06-21")), ylim=c(0, 1.015), yaxs='i', ylab="Proportion")
#  
#    #polygon(c(ukWeekly$date[infMask], rev(ukWeekly$date[infMask])), c(cleanProp(ukWeekly$seqs/ukWeekly$infectionsLower)[infMask], rev(cleanProp(ukWeekly$seqs/ukWeekly$infectionsUpper)[infMask])), 
#    #        col = mPal(ukPal$oth, 0.75), border=NA)
#    infPropLower <- cleanProp(ukWeekly$seqs/ukWeekly$infectionsLower)
#    infPropUpper <- cleanProp(ukWeekly$seqs/ukWeekly$infectionsUpper)
#    for (i in 2:length(infMask)) {
#        rect(ukWeekly$date[i-1], infPropLower[i], ukWeekly$date[i], infPropUpper[i], col = mPal(ukPal$oth, 0.75), border=NA)
#    }
#    lines(ukWeekly$date, infProp, lty=3, lwd=2, type='S')
#    idx <- min(which(infMask))
#    lines(ukWeekly$date[(idx-1):idx], rep(infProp[idx],2), lty=3, lwd=2)
#    lines(ukWeekly$date, caseProp, lty=1, lwd=2, type='S')
#    
#    
#    legend("bottom", horiz=FALSE, inset=c(0,1), bty='n', xpd=TRUE, ncol=2,
#           lty=c(1,3), lwd=2,
#           legend = c("reported cases", "estimated infections"), title="Sequenced proportion of weekly", cex=par("cex.lab"))
#    
#    # Inset start
#    ymax <- 0.1
#    insetStart <- as.Date("2020-02-16")
#    insetEnd   <- as.Date("2020-05-10")
#    
#    rect(insetStart, 0, insetEnd, ymax, lty=2)
#
#    par(mar=c(2,2,0.5,0.5), cex.axis=0.7, cex.lab=0.8, mgp=c(3,0.75,0), fig=c(0.445, 0.875, 0.45, 0.88), new=TRUE)
#    
#    plotShadedAxes(xlim=c(insetStart, insetEnd), ylim=c(0, ymax), yaxs='i', side=4)
#  
#    #polygon(c(ukWeekly$date[infMask], rev(ukWeekly$date[infMask])), c(cleanProp(ukWeekly$seqs/ukWeekly$infectionsLower)[infMask], rev(cleanProp(ukWeekly$seqs/ukWeekly$infectionsUpper)[infMask])), 
#    #        col = mPal(ukPal$oth, 0.75), border=NA)
#    for (i in 2:length(infMask)) {
#        rect(ukWeekly$date[i-1], infPropLower[i], ukWeekly$date[i], infPropUpper[i], col = mPal(ukPal$oth, 0.75), border=NA)
#    }
#    lines(ukWeekly$date, infProp, lty=3, lwd=2, type='S')
#    idx <- min(which(infMask))
#    lines(ukWeekly$date[(idx-1):idx], rep(infProp[idx],2), lty=3, lwd=2)
#    lines(ukWeekly$date, caseProp, lty=1, lwd=2, type='S')
#
#    rect(insetStart, 0, insetEnd, ymax, xpd=TRUE)
#
#
#    #plotShadedAxes(xlim=c(startDate, as.Date("2020-06-21")), ylim=c(0, 10000), yaxs='i')
#    #lines(ukCases$date, ukCases$newCasesBySpecimenDate)
#    
#    #dateFreqDistribution(rev(ukCases$newCasesBySpecimenDate[2:nrow(ukCases)]), rev(ukCases$date), startDate="2020-01-31", endDate="2020-06-21", barplot=TRUE)
    
```


```{r sampling-proportion-weekly-flipped, fig.width=7, fig.height=3, fig.cap = "Proportion of weekly reported cases (solid line) and estimated infections (dotted line; Flaxman et al. 2020) included in our genome sequence dataset."}

#    cleanProp <- function(x) {
#        x[is.nan(x)] <- NA
#        x[is.infinite(x)] <- NA
#        x[x > 1] <- 1
#        return(x)
#    }
#
#    caseProp <- cleanProp(ukWeekly$seqs/ukWeekly$cases)
#    infProp  <- cleanProp(ukWeekly$seqs/ukWeekly$infections)
#    infMask  <- !is.na(infProp)
#
#    par(mar=c(4,6,2.5,6), cex.axis=0.7, cex.lab=0.8, mgp=c(3,0.75,0))
#
#    plotShadedAxes(xlim=c(startDate, as.Date("2020-06-21")), ylim=c(0, 0.1), yaxs='i', ylab="Proportion")
#  
#    infPropLower <- cleanProp(ukWeekly$seqs/ukWeekly$infectionsLower)
#    infPropUpper <- cleanProp(ukWeekly$seqs/ukWeekly$infectionsUpper)
#    for (i in 2:length(infMask)) {
#        rect(ukWeekly$date[i-1], infPropLower[i], ukWeekly$date[i], infPropUpper[i], col = mPal(ukPal$oth, 0.75), border=NA)
#    }
#    lines(ukWeekly$date, infProp, lty=3, lwd=2, type='S')
#    idx <- min(which(infMask))
#    lines(ukWeekly$date[(idx-1):idx], rep(infProp[idx],2), lty=3, lwd=2)
#    lines(ukWeekly$date, caseProp, lty=1, lwd=2, type='S')
#    
#    
#    legend("bottomleft", horiz=FALSE, inset=c(0,1), bty='n', xpd=TRUE, ncol=2,
#           lty=c(1,3), lwd=2,
#           legend = c("reported cases", "estimated infections"), title="Sequenced proportion of weekly", cex=par("cex.lab"))
#
#    # Inset start
#    ymax <- 1
#    insetStart <- as.Date("2020-01-19")
#    insetEnd   <- as.Date("2020-06-21")
#    
#    #rect(insetStart, 0, insetEnd, ymax, lty=2)
#    
#    par(mar=c(2,2,0.5,0.5), cex.axis=0.7, cex.lab=0.8, mgp=c(3,0.75,0), fig=c(0.65, 0.95, 0.55, 0.95), new=TRUE)
#    
#    plotShadedAxes(xlim=c(insetStart, insetEnd), ylim=c(0, ymax), yaxs='i', side=2, smallBreaks = "weeks", thinXLabel = 4, thinYLabel=5)
#    
#    #polygon(c(ukWeekly$date[infMask], rev(ukWeekly$date[infMask])), c(cleanProp(ukWeekly$seqs/ukWeekly$infectionsLower)[infMask], rev(cleanProp(ukWeekly$seqs/ukWeekly$infectionsUpper)[infMask])),
#    #        col = mPal(ukPal$oth, 0.75), border=NA)
#    for (i in 2:length(infMask)) {
#        rect(ukWeekly$date[i-1], infPropLower[i], ukWeekly$date[i], infPropUpper[i], col = mPal(ukPal$oth, 0.75), border=NA)
#    }
#    lines(ukWeekly$date, infProp, lty=3, lwd=2, type='S')
#    idx <- min(which(infMask))
#    lines(ukWeekly$date[(idx-1):idx], rep(infProp[idx],2), lty=3, lwd=2)
#    lines(ukWeekly$date, caseProp, lty=1, lwd=2, type='S')
#    
#    rect(insetStart, 0, insetEnd, ymax, xpd=TRUE)
    
```


```{r sampling-proportion-weekly-infections, fig.width=7, fig.height=3, fig.cap = "Proportion of weekly estimated infections (Flaxman et al. 2020) included in our genome sequence dataset."}
#
#    cleanProp <- function(x) {
#        x[is.nan(x)] <- NA
#        x[is.infinite(x)] <- NA
#        x[x > 1] <- 1
#        return(x)
#    }
#
#
#    par(mar=c(4,6,2.5,6), cex.axis=0.7, cex.lab=0.8, mgp=c(3,0.75,0))
#
#    plotShadedAxes(xlim=c(startDate, as.Date("2020-06-21")), ylim=c(0, 0.1), yaxs='i', ylab="Proportion")
#
#    infProp  <- cleanProp(ukWeekly$seqs/ukWeekly$infections)
#    infMask  <- !is.na(infProp)
#    infPropLower <- cleanProp(ukWeekly$seqs/ukWeekly$infectionsLower)
#    infPropUpper <- cleanProp(ukWeekly$seqs/ukWeekly$infectionsUpper)
#    for (i in 2:length(infMask)) {
#        rect(ukWeekly$date[i-1], infPropLower[i], ukWeekly$date[i], infPropUpper[i], col = mPal(ukPal$oth, 0.75), border=NA)
#    }
#    lines(ukWeekly$date, infProp, lty=3, lwd=2, type='S')
#    idx <- min(which(infMask))
#    lines(ukWeekly$date[(idx-1):idx], rep(infProp[idx],2), lty=3, lwd=2)
#    
#    #legend("bottomleft", horiz=FALSE, inset=c(0,1), bty='n', xpd=TRUE, ncol=2,
#    #       lty=c(1,3), lwd=2,
#    #       legend = c("reported cases", "estimated infections"), title="Sequenced proportion of weekly", cex=par("cex.lab"))
#
#    
#    
```



```{r sampling-proportion-cumulative, fig.width=7, fig.height=3, fig.cap = "Proportion of the cumulative weekly reported cases (solid line) and estimated infections (dotted line; Flaxman et al. 2020) included in our genome sequence dataset over time."}
#
#    getCumulativeSequences <- function(dateRange, seqDates) {
#        
#        return <- data.frame(date = dateRange, 
#                             seqs = sapply(dateRange, function(x) sum(seqDates <= x)))
#    
#    }
#    
#    seqsCum     <- getCumulativeSequences(ukCases$date, metadata$sample_date[metadata$country == "UK"])
#    cumCaseProp <- cleanProp(seqsCum$seqs/ukCases$cumCasesBySpecimenDate)
#    
#    seqsCum     <- getCumulativeSequences(europeInfections$time[europeInfections$country == "United_Kingdom"], metadata$sample_date[metadata$country == "UK"])
#    cumInfProp  <- cleanProp(seqsCum$seqs/europeInfections$predicted_infections_mean_cumulative[europeInfections$country == "United_Kingdom"])
#    cumInfPropL <- cleanProp(seqsCum$seqs/europeInfections$predicted_infections_lower_CI_95_cumulative[europeInfections$country == "United_Kingdom"])
#    cumInfPropU <- cleanProp(seqsCum$seqs/europeInfections$predicted_infections_higher_CI_95_cumulative[europeInfections$country == "United_Kingdom"])  
#    
#    par(mar=c(4,6,2.5,6), cex.axis=0.7, cex.lab=0.8, mgp=c(3,0.75,0))
#    
#    plotShadedAxes(xlim=c(startDate, as.Date("2020-06-21")), ylim=c(0, 1.015), yaxs='i', ylab="Cumulative proportion")
#    
#    polygon(c(seqsCum$date, rev(seqsCum$date)), c(cumInfPropL, rev(cumInfPropU)), col = mPal(ukPal$oth, 0.75), border=NA)
#    lines(seqsCum$date, cumInfProp, lty=3, lwd=2)
#    lines(ukCases$date, cumCaseProp, lty=1, lwd=2)
#    
#    legend("bottom", horiz=FALSE, inset=c(0,1), bty='n', xpd=TRUE, ncol=2,
#           lty=c(1,3), lwd=2,
#           legend = c("reported cases", "estimated infections"), title="Sequenced proportion of cumulative", cex=par("cex.lab"))
#    
#    # Inset start
#    ymax <- 0.05
#    insetStart <- as.Date("2020-02-16")
#    insetEnd   <- as.Date("2020-05-10")
#    
#    rect(insetStart, 0, insetEnd, ymax, lty=2)
#    
#    par(mar=c(2,2,0.5,0.5), cex.axis=0.7, cex.lab=0.8, mgp=c(3,0.75,0), fig=c(0.445, 0.875, 0.45, 0.88), new=TRUE)
#    
#    plotShadedAxes(xlim=c(insetStart, insetEnd), ylim=c(0, ymax), yaxs='i', side=4)
#    
#    polygon(c(seqsCum$date, rev(seqsCum$date)), c(cumInfPropL, rev(cumInfPropU)), col = mPal(ukPal$oth, 0.75), border=NA)
#    lines(seqsCum$date, cumInfProp, lty=3, lwd=2)
#    lines(ukCases$date, cumCaseProp, lty=1, lwd=2)
#    
#    rect(insetStart, 0, insetEnd, ymax, xpd=TRUE)
#
```





```{r travel-cases-all, fig.width=5, fig.height=3, fig.cap="Estimated number of inbound travellers to the per day (black) and estimated number of infectious cases worldwide (dashed red, 7-day rolling average). Arrows here shows from left to right the first self-isolation advice for returning travellers from China, Italy, and the start of the national lockdown."}
#
#    par(mar=c(4,6,2.5,6), cex.axis=0.7, cex.lab=0.8, mgp=c(3.25,0.75,0))
#    plotArrivalsInfections(arrivals, infections, location="all", startDate = startDate, endDate = endDate, cex.lab=0.8)
#    
#    # Mark lockdown    
#    points(x=travelDates$lockdown, y=0.1*1E6, pch=175, font=5, cex=1.5, xpd=TRUE, col=mPal(ukPal$eng))
#    
#    # Mark self-isolation advice
#    points(x=travelDates$china, y=0.1*1E6, pch=175, font=5, cex=1.5, xpd=TRUE, col=mPal(countryPal$China))
#    points(x=travelDates$italy, y=0.1*1E6, pch=175, font=5, cex=1.5, xpd=TRUE, col=mPal(countryPal$Italy))
```



```{r travel-cases-countries-top12, fig.width=15, fig.height=12, fig.cap="Estimated numbers of inbound travellers to the `r state` per day, and estimated number of new infections per day, for the 12 countries we estimate to have been responsible for the most importations to the (see Table 3). We estimate that these 12 countries contributed 97.6% of importations to the `r states`"}
#
#    layout(matrix(c(1:12), nrow=4, byrow=TRUE))
#    par(mar=c(4,6,2.5,6), cex.axis=0.8, cex.lab=1.2, cex.main=1.5, mgp=c(3.25,0.5,0))
#
#    countries1 <- c("Spain", 
#                    "France", 
#                    "Italy",
#                    "US",
#                    "Netherlands",
#                    "Belgium",
#                    "Ireland", 
#                    "Germany",
#                    "Switzerland",
#                    "Portugal",
#                    "Sweden", 
#                    "China")
#    
#    # Specific countries
#    for (i in 1:length(countries1)) {
#        plotArrivalsInfections(arrivals, infections, location=countries1[i], startDate = startDate, endDate = endDate, cex.lab=0.8, label=LETTERS[i])
#        title(capitalise(countries1[i]))
#    }
    
```

```{r travel-cases-countries-other, fig.width=15, fig.height=12, fig.cap="Estimated numbers of inbound travellers to the `r states` per day, and estimated number of new infections per day, for a range of countries. (A-F) shows the 6 countries that made the largest contribution to importations after the 12 in the previous figure (see Table 3). Together these 6 countries contributed 1.19% of estimated importations to the `r states` (G-L) 6 countries with large epidemics that did not contribute many importations to the `r states`, either because of low numbers of inbound travellers or because their epidemics started later. These 6 countries combined contributed less than 0.5% of importations into `r states`."}
#
#    layout(matrix(c(1:12), nrow=4, byrow=TRUE))
#    par(mar=c(4,6,2.5,6), cex.axis=0.7, cex.lab=1.2, cex.main=1.5, mgp=c(3.25,0.5,0))
#
#    countries2 <- c("Denmark", "Austria", "Romania", "Norway", "Poland", "Canada", "Iran", "Brazil", "India", "Russia", "Mexico", "South Africa") # Japan, Korea, South
#    
#    # Specific countries
#    for (i in 1:length(countries2)) {
#        plotArrivalsInfections(arrivals, infections, location=countries2[i], startDate = startDate, endDate = endDate, cex.lab=0.8, label=LETTERS[i])
#        title(capitalise(countries2[i]))
#    }
#    
    
```


```{r eii-tmrca-all, fig.width=5, fig.height=3, fig.cap="Estimated importation intensity (EII) curve (black) and the histogram of lineage TMRCAs (grey). Arrows here shows from left to right the first self-isolation advice for returning travellers from China, Italy, and the start of the `r states` national lockdown."}


    #tmrcaBreaks <- seq.Date(as.Date("2019-12-01"), as.Date("2020-06-26"), by="days")
    # tmrcaBreaks <- seq.Date(min(clusterStatsMCC$tmrca_shifted_calendar), max(clusterStatsMCC$tmrca_calendar), by="1 days")
    # tmrca_hist  <- hist(clusterStatsMCC$tmrca_calendar, breaks=tmrcaBreaks, plot=FALSE, right=FALSE)   
    

    # par(mar=c(4,6,2.5,6), cex.axis=0.7, cex.lab=0.8, mgp=c(3,0.75,0))
    # dateFreqDistribution(tmrca_hist$counts, tmrcaBreaks, plot.ci=FALSE, side=4, ylab="",
    #                      #startDate = startDate, endDate = endDate, col=mPal(ukPal$oth), ymax=70)
    #                      startDate = tmrcaBreaks[1], endDate = tmrcaBreaks[length(tmrcaBreaks)-1], col=mPal(ukPal$oth), ymax=30)
    # mtext(side=4, text="Frequency of TMRCAs\n(per day)", line=3, cex=par("cex.lab"))
    # 
    # par(new=TRUE)
    # ymax <- 1200
    # 
    # plot(1, type='n', xlim=c(startDate, endDate), ylim=c(0,1200), axes=FALSE, 
    #      xaxs='i', yaxs='i', xlab="", ylab="")
    # lines(eii$date[eii$location == "all"], eii$num_intros[eii$location == "all"], lwd=2)
    # axis(2, las=1)
    # mtext(side=2, text="Estimated importation intensity\n(solid line)", line=2, cex=par("cex.lab"))
    # 
    # # Mark lockdown    
    # points(x=travelDates$lockdown, y=0.1*ymax, pch=175, font=5, cex=1.5, xpd=TRUE, col=mPal(ukPal$eng))
    # 
    # # Mark self-isolation advice
    # points(x=travelDates$china, y=0.1*ymax, pch=175, font=5, cex=1.5, xpd=TRUE, col=mPal(countryPal$China))
    # points(x=travelDates$italy, y=0.1*ymax, pch=175, font=5, cex=1.5, xpd=TRUE, col=mPal(countryPal$Italy))

```




```{r eii-tmrca-countries, fig.width=10, fig.height=8, fig.cap="Estimated importation intensity (EII) curves for the 12 countries estimated to have contributed the most importations to the `r states` epidemic (see Table 3). Panel A shows the EII for all countries. The red arrows indicate the start of the `r states` lockdown."}
#    
#    layout(matrix(c(1,2,5,6,3,4,7,8), nrow=4, byrow=TRUE), heights=c(3,1,3,1))
#    par(mar=c(4,6,2.5,6), cex.axis=1, cex.lab=1.2, cex.main=1.5, mgp=c(3,0.75,0))
#  
#    plotShadedAxes(xlim=c(startDate, endDate), ylim=c(0, 1200), axes=FALSE, label="A", line=0, yaxs='i', 
#                   ylab = "Estimated importation intensity")
#    lines(eii$date[eii$location == "all"], eii$num_intros[eii$location == "all"], lwd=2)
#    abline(v=as.Date(c("2020-03-12", "2020-03-16", "2020-03-20")), lty=3, col="black")
#    abline(v=as.Date("2020-03-23"), lty=1, col=ukPal$eng)
#    
#    #points(x=travelDates$lockdown, y=0.075*1200, pch=175, font=5, cex=1.5, xpd=TRUE, col=mPal(ukPal$eng))
#
#    
#    ymax <- list(B=500, C=100, D=20)
#    panelCountries <- list(B=c("Spain", "France", "Italy", "Belgium"), 
#                           C=c("Netherlands", "Ireland", "Switzerland", "US"), 
#                           D=c("Germany", "Sweden", "Portugal", "China", "Other"))
#    for (i in names(panelCountries)) {
#      
#      
#        plotCountries <- panelCountries[[i]]
#        
#        plotShadedAxes(xlim=c(startDate, endDate), ylim=c(0, ymax[[i]]), axes=FALSE, label=i, line=0, yaxs='i', 
#                       ylab = "Estimated importation intensity")
#    
#        for (country in plotCountries) {
#            lines(eii$date[eii$location == country], eii$num_intros[eii$location == country], col=mPal(countryPal[[country]]), lwd=2)
#            #points(eii$date[eii$location == country], eii$num_intros[eii$location == country], col=mPal(countryPal[[country]]), pch=20)
#        }
#        
#        legend('bottom', horiz=FALSE, inset=c(0, 1), bty='n', 
#               col = sapply(plotCountries, function(x) countryPal[[x]]), 
#               legend=plotCountries, 
#               ncol=ceiling(length(plotCountries)/2), seg.len=1, lwd=2, lty=1, xpd=TRUE, cex=par("cex.axis"))
#        
#        # Mark lockdown    
#        #points(x=travelDates$lockdown, y=0.075*ymax[[i]], pch=175, font=5, cex=1.5, xpd=TRUE, col=mPal(ukPal$eng))
#        abline(v=as.Date("2020-03-23"), lty=1, col=ukPal$eng)
#        
#        if (i == "B") { 
#            abline(v=as.Date("2020-02-25"), lty=3, col=countryPal$Italy)
#        } else 
#        if (i == "D") {
#            abline(v=as.Date("2020-01-28"), lty=3, col=countryPal$China)
#        }
#
#    }
#    
#    
#    
#    ###################################
#    # NPIs and travel recommendations #
#    ###################################
#    par(mar=c(1,6,0,6))
#
#    plot(1, type='n', ylim=c(0,8.5), xlim=c(startDate, endDate),
#         xaxs='i', yaxs='i', bty='n', axes=FALSE, xlab="", ylab="", las=2)
#    
#    # Self isolate if symptomatic (experiencing a cough or fever symptoms)
#    rect(as.Date("2020-03-12"), 6, endDate, 7, border=NA, col=mPal(ukPal$oth))
#    
#    # Social distancing encouraged (advice against non-essential travel and contact with others, 
#    # avoid pubs, clubs, theatres and work from home if possible)
#    rect(as.Date("2020-03-16"), 4.5, endDate, 5.5, border=NA, col=mPal(ukPal$oth))
#    
#    # School closure ordered, closure of public venues (pubs, restaurants, gyms, leisure centres, nightclubs, theatres, cinemas)
#    rect(as.Date("2020-03-20"), 3, endDate, 4, border=NA, col=mPal(ukPal$oth))
#    
#    # Lockdown
#    rect(as.Date("2020-03-23"), 1.5, endDate, 2.5, border=NA, col=mPal(ukPal$eng))
#    
#    text(x=endDate, y=7.5, "Non-pharmaceutical interventions ", cex=par("cex.lab"), pos=2)
#    text(x=endDate, y=c(2, 3.5, 5, 6.5)-0.1,
#           c("Lockdown", 
#             "School closure", 
#             "Social distancing", 
#             "Self-isolation"),
#         pos=2, srt=0, cex=par("cex.axis"), col="white", srt=0, xpd=TRUE)
#
#    
#    
#    
#    
#    plot(1, type='n', ylim=c(0,8.5), xlim=c(startDate, endDate),
#         xaxs='i', yaxs='i', bty='n', axes=FALSE, xlab="", ylab="", las=2)
#    
#    # Italy, Iran, Vietnam, Cambodia, Laos, Myanmar
#    rect(as.Date("2020-02-25"), 6, endDate, 7, border=NA, col=mPal(countryPal$Italy))
#    rect(as.Date("2020-02-25"), 6, as.Date("2020-03-05"), 7, border=NA, angle=45, density = 50, col="white")
#
#
#    text(x=endDate, y=7.5, "Self-isolation advice", cex=par("cex.lab"), pos=2)
#    text(x=endDate, y=6.5, "Italy", pos=2, srt=0, cex=par("cex.axis"), col="white", srt=0, xpd=TRUE)
#
#    
#        
#    plot(1, type='n', axes=FALSE, ylab="", xlab="")
#    
#    
#    
#    plot(1, type='n', ylim=c(0,8.5), xlim=c(startDate, endDate),
#         xaxs='i', yaxs='i', bty='n', axes=FALSE, xlab="", ylab="", las=2)
#
#    # China
#    rect(as.Date("2020-01-28"), 6, endDate, 7, border=NA, col=mPal(countryPal$China))
#    rect(as.Date("2020-01-28"), 6, as.Date("2020-01-31"), 7, border=NA, angle=45, density = 50, col="white")
#    
#    text(x=endDate, y=7.5, "Self-isolation advice", cex=par("cex.lab"), pos=2)
#    text(x=endDate, y=6.5, "China", pos=2, srt=0, cex=par("cex.axis"), col="white", srt=0, xpd=TRUE)
#
```


\clearpage


# Lineage importation distribution (shifted TMRCA distribution)
- GISAID tree until `r endDate` as initial tree.
- The tree is time-collibrated by TreeTime.
- Sankoff algorithm is used to assign location (`r states` and non-`r states`) to inner vertices of the tree, for each state sparately.
- Dataset contains 
  `r rsumstate(function(state, i, clusterStatsMCC) length(levels(as.factor(clusterStatsMCC$cluster))))` 
  transmission lineages (2 or more sequences), comprising 
  `r rsumstate(function(state, i, clusterStatsMCC)  sum(clusterStatsMCC$seqs))` 
  sequences from the `r states`, as well as a further 
  `r rsumstate(function(state, i, clusterStatsMCC)  sum(stateInfo$metadata_instate[,i]) - sum(clusterStatsMCC$seqs))` 
  singletons.
- Mean and SD of the importation (shifted TMRCA) distribution: 
  `r rsumstate(function(state, i, clusterStatsMCC) paste(round_date(date_decimal(mean(clusterStatsMCC$tmrca_shifted)), unit="day"), "±",  round(sd(clusterStatsMCC$tmrca_shifted)*366,3) ) )` days (singletons excluded).
- Median and interquartile range of the importation (shifted TMRCA) distribution `r rsumstate(function(state, i, clusterStatsMCC) round_date(date_decimal(median(clusterStatsMCC$tmrca_shifted)), unit="day") )` [`r rsumstate(function(state, i, clusterStatsMCC) round_date(date_decimal(quantile(clusterStatsMCC$tmrca_shifted, c(0.25, 0.75), na.rm=TRUE)), unit="day") )`] (singletons excluded).
- 80% of importations fall in [`r rsumstate(function(state, i, clusterStatsMCC) round_date(date_decimal(quantile(clusterStatsMCC$tmrca_shifted, c(0.1, 0.9), na.rm=TRUE)), unit="day") )`].

- Number of importation lineages, singletones  = `sum(clusterSamplesMCC$lineage_seqs == 1)` non-singletone = `nrow(clusterStatsMCC)`, sum = `nrow(clusterStatsMCC) + sum(clusterSamplesMCC$lineage_seqs == 1)`


```{r shift-distribution, results="asis"}

  sizeShiftTable <- data.frame(size = c("All", "2 to 10", "11 to 100", "101 to 1000", "Bigger than 1000"))
  colnames(sizeShiftTable) <- c("Lineages of size")
  
  weekInfo <- list()

  for (s in 1:nrow(stateFiles)) {
    state <- stateFiles$state[s]
    clusterStatsMCC <- stateInfo$clusterStatsMCC[[s]] 
    clusterSamplesMCC <- stateInfo$clusterSamplesMCC[[s]] 

    sizeShifts <- list(all   = clusterStatsMCC$shift, 
                       small = clusterStatsMCC$shift[clusterStatsMCC$seqs <= 10],
                       med   = clusterStatsMCC$shift[clusterStatsMCC$seqs > 10 & clusterStatsMCC$seqs <= 100],
                       big   = clusterStatsMCC$shift[clusterStatsMCC$seqs > 100 & clusterStatsMCC$seqs <= 1000],
                       huge  = clusterStatsMCC$shift[clusterStatsMCC$seqs > 1000])

    sizeLags <- list(all   = clusterStatsMCC$detection_lag, 
                     small = clusterStatsMCC$detection_lag[clusterStatsMCC$seqs <= 10],
                     med   = clusterStatsMCC$detection_lag[clusterStatsMCC$seqs > 10 & clusterStatsMCC$seqs <= 100],
                     big   = clusterStatsMCC$detection_lag[clusterStatsMCC$seqs > 100 & clusterStatsMCC$seqs <= 1000],
                     huge  = clusterStatsMCC$detection_lag[clusterStatsMCC$seqs > 1000])

     sizeSeqs <- list(all   = clusterStatsMCC$seqs, 
                     small = clusterStatsMCC$seqs[clusterStatsMCC$seqs <= 10],
                     med   = clusterStatsMCC$seqs[clusterStatsMCC$seqs > 10 & clusterStatsMCC$seqs <= 100],
                     big   = clusterStatsMCC$seqs[clusterStatsMCC$seqs > 100 & clusterStatsMCC$seqs <= 1000],
                     huge  = clusterStatsMCC$seqs[clusterStatsMCC$seqs > 1000])


    weekShifts <- weekLags <- weekSizes <- list()
    weekBreaks <- seq.Date(startDate, endDate, by="weeks")
    for (i in 2:length(weekBreaks)) {
        weekShifts[[format.Date(weekBreaks[i-1], format="%y %b %d")]] <- clusterStatsMCC$shift[clusterStatsMCC$tmrca_shifted_calendar >=  weekBreaks[i-1] & 
                                                                      clusterStatsMCC$tmrca_shifted_calendar < weekBreaks[i]]
        weekLags[[format.Date(weekBreaks[i-1], format="%y %b %d")]]   <- clusterStatsMCC$detection_lag[clusterStatsMCC$tmrca_shifted_calendar >=  weekBreaks[i-1] & 
                                                                      clusterStatsMCC$tmrca_shifted_calendar < weekBreaks[i]]
        weekSizes[[format.Date(weekBreaks[i-1], format="%y %b %d")]]  <- clusterStatsMCC$seqs[clusterStatsMCC$tmrca_shifted_calendar >=  weekBreaks[i-1] & 
                                                                      clusterStatsMCC$tmrca_shifted_calendar < weekBreaks[i]]
    }
    
    sizeShiftTable <- cbind(sizeShiftTable, 
                            lineages = sapply(sizeShifts, length), 
                                 shiftMeanSD   = sapply(sizeShifts, function(x) paste0(round(mean(x),2), " ± ", round(sd(x),2))), 
                                 ShiftMedIQR   = sapply(sizeShifts, function(x) paste0(round(median(x),2), " [", paste(round(quantile(x, c(0.25, 0.75), na.rm=TRUE),2), collapse="-"), "]")),
                                 lagMeanSD   = sapply(sizeLags, function(x) paste0(round(mean(x),2), " ± ", round(sd(x),2))), 
                                 #lagMedIQR   = sapply(sizeLags, function(x) paste0(round(median(x),2), " [", paste(round(quantile(x, c(0.25, 0.75)),2), collapse="-"), "]")) )
                                 lagMedIQR   = sapply(sizeLags, function(x) paste0(round(median(x),2), " [", paste(round(quantile(x, c(0.25, 0.75), na.rm=TRUE),2), collapse="-"), "]")),
                                 seqs = sapply(sizeSeqs, sum),
                                 seqsRatio = round(sapply(sizeSeqs, sum) / sum(sapply(sizeSeqs, sum)) * 2 * 100)

                            )
    
    colnames(sizeShiftTable)[(ncol(sizeShiftTable)-5-2+1):ncol(sizeShiftTable)] <- c(paste("No. of lineages of ", state), 
                                  paste("Importation lag (mean ± SD)", state), paste("Importation lag (median and IQR)", state), 
                                  paste("Detection lag (mean ± SD)", state),   paste("Detection lag (median and IQR)", state),
                                  "No sequences", "% of sequences")
    
    weekInfo[[s]] = list(weekShifts = weekShifts, weekLags = weekLags, weekSizes = weekSizes)
    weekShiftNames = names(weekShifts)

  }

    
    capSizeShifts            <- paste0("Estimated importation lags for ", "multistate", " transmission lineages of different sizes. Importation lag is the waiting time between importation date and the TMRCA of the sampled genomes in the transmission lineage. Detection lag is the waiting time from the importation date to the sampling time of the oldest (first) sampled genome in the transmission lineage.")
    
    kable(sizeShiftTable, row.names=FALSE, caption = capSizeShifts)
    cat(knitr::kable(sizeShiftTable, row.names=FALSE, caption = capSizeShifts, format="latex"), file = paste0(figpath, "shift-size-distribution.tex"))
    cat(knitr::kable(sizeShiftTable, row.names=FALSE, caption = capSizeShifts, format="html"),  file = paste0(figpath, "shift-size-distribution.html"))
    # write.csv(sizeShiftTable, file = paste0(figpath, "shift-size-distribution.csv"), row.names=FALSE, quote=FALSE)
    
    # cat(kable(sizeShiftTable[,c(1, seq(2, ncol(sizeShiftTable), 5))], row.names=FALSE, caption = capSizeShifts, format="html"))
    

    getMeanSDText <- function(x) {
        if (length(x) > 1) {
            paste0(round(mean(x),2), " ± ", round(sd(x),2))
        } else 
        if (length(x) > 0) {
            round(x,2)
        } else {
            "-"
        }
    }
    
    getMedianIQRText <- function(x) {
        if (length(x) > 1) {
            paste0(round(median(x),2), " [", paste(round(quantile(x, c(0.25, 0.75), na.rm=TRUE),2), collapse="-"), "]")
        } else 
        if (length(x) > 0) {
            round(x,2)
        } else {
            "-"
        }
    }
    
    cat("\n\\clearpage\n")
    
    
    weekShiftTable <- data.frame(week = weekShiftNames, 
                                 epiweek  = date_epiweek(weekBreaks[1:(length(weekBreaks)-1)]))
    colnames(weekShiftTable) <- c("Week starting", "Epi-week")

  for (s in 1:nrow(stateFiles)) {
    state <- stateFiles$state[s]

    weekShifts <- weekInfo[[s]]$weekShifts
    weekLags <- weekInfo[[s]]$weekLags
    weekSizes <- weekInfo[[s]]$weekSizes
    
    weekShiftTable <- cbind(weekShiftTable, 
                                 lineages = sapply(weekShifts, length), 
                                 #seqs     = sapply(weekSizes, getMeanSDText),
                                 seqs     = sapply(weekSizes, getMedianIQRText),
                                 shifts   = sapply(weekShifts, getMeanSDText),
                                 lags     = sapply(weekLags,   getMeanSDText))
                                 #medIQR   = sapply(weekShifts, function(x) {
                                  #                  if (length(x) > 0) {
                                  #                      paste0(round(median(x),2), " [", paste(round(quantile(x, c(0.25, 0.75)),2), collapse=", "), "]")
                                  #                  } else {
                                  #                      "-"
                                  #                  }}))
                                 
    colnames(weekShiftTable)[(ncol(weekShiftTable)-4+1):ncol(weekShiftTable)] <- c(
        paste("Estimated no. of importations of", state), 
        paste("Lineage sizes (median and IQR)", state), 
        paste("Importation lag (mean ± SD)", state), paste("Detection lag (mean ± SD)", state))

  }
    capWeekShifts            <- paste0("3. Estimated importation and detection lags for ", state, " transmission lineages ordered by importation date and aggregated by epi-week. Importation lag is the waiting time between importation date and the TMRCA of the sampled genomes in the transmission lineage. Detection lag is the waiting time from the importation date to the sampling time of the oldest (first) sampled genome in the transmission lineage. All statistics show means and standard deviations computed from the MCC trees.")
    
    kable(weekShiftTable, row.names=FALSE, caption = capWeekShifts)
    cat(knitr::kable(weekShiftTable, row.names=FALSE, caption = capWeekShifts, format="latex"), file = paste0(figpath, "shift-week-distribution.tex"))
    cat(knitr::kable(weekShiftTable, row.names=FALSE, caption = capWeekShifts, format="html"),  file = paste0(figpath, "shift-week-distribution.html"))
    # write.csv(weekShiftTable, file = paste0(figpath, "shift-week-distribution.csv"), row.names=FALSE, quote=FALSE)


```

- Among `sum(metadata$country == "Germany")` initial samples from Germany, `dim(clusterSamplesMCC)[1]` samples have been kept in the final lineages (after removing incomplete information and small sub-trees) and `sum(clusterStatsMCC$seqs)` appear in non-singleton lineages. 



```{r size-distribution, results="asis"}

  # weekInfo <- list()
  sizeTable <- data.frame(size = c("All", "2 to 10", "11 to 100", "101 to 1000", "Bigger than 1000"))
  colnames(sizeTable) <- c("Lineages of size")

  for (s in 1:nrow(stateFiles)) {
    state <- stateFiles$state[s]
    clusterStatsMCC <- stateInfo$clusterStatsMCC[[s]] 
    clusterSamplesMCC <- stateInfo$clusterSamplesMCC[[s]] 

    sizes <- list(all   = c(clusterStatsMCC$seqs, clusterSamplesMCC$lineage_seqs[clusterSamplesMCC$lineage_seqs == 1]), 
                       small = clusterStatsMCC$seqs[clusterStatsMCC$seqs <= 10],
                       med   = clusterStatsMCC$seqs[clusterStatsMCC$seqs > 10 & clusterStatsMCC$seqs <= 100],
                       big   = clusterStatsMCC$seqs[clusterStatsMCC$seqs > 100 & clusterStatsMCC$seqs <= 1000],
                       huge  = clusterStatsMCC$seqs[clusterStatsMCC$seqs > 1000])


    sizeTable <- cbind(sizeTable, 
                            lineages = sapply(sizes, length), 
                           size = sapply(sizes, sum),
                           size_percent = sapply(sizes, sum) / sum(sizes$all)
                       )
    
    # weekInfo[[s]] = list(weekShifts = weekShifts, weekLags = weekLags, weekSizes = weekSizes)
    # weekShiftNames = names(weekShifts)

  }

    
    capSizeShifts            <- paste0("Population of each linege size.")
    
    kable(sizeTable, row.names=FALSE, caption = capSizeShifts)
    # cat(knitr::kable(sizeTable, row.names=FALSE, caption = capSizeShifts, format="latex"), file = paste0(figpath, "shift-size-distribution.tex"))
    # cat(knitr::kable(sizeTable, row.names=FALSE, caption = capSizeShifts, format="html"),  file = paste0(figpath, "shift-size-distribution.html"))
    
    clusterStatSizeOrder <- order(-clusterStatsMCC$seqs)
    
   bigestLineages <- cbind(cluster = clusterStatsMCC$cluster[clusterStatSizeOrder[1:8]],
                           size = clusterStatsMCC$seqs[clusterStatSizeOrder[1:8]],
                           oldest = as.character(as.Date(date_decimal(clusterStatsMCC$oldest[clusterStatSizeOrder[1:8]]))),
                           state_of_oldest = sapply(  clusterStatsMCC$cluster[clusterStatSizeOrder[1:8]] , function(cluster) toString( str_trim(sapply(str_split(paste0(clusterSamplesMCC[clusterSamplesMCC$sample_date == min(clusterSamplesMCC$sample_date[clusterSamplesMCC$cluster == cluster]) & clusterSamplesMCC$cluster == cluster,"Location"], "/") , "/"), "[[", 3)) ) )
                           )
    kable(bigestLineages, row.names=FALSE, caption = "Bigest lineages")

```

- Number of sequences in 8 largest lineage = `sum(clusterStatsMCC[order(-clusterStatsMCC$seqs)[1:8],"seqs"])`
- Percentage of sequences in 8 largest lineage = `sum(clusterStatsMCC[order(-clusterStatsMCC$seqs)[1:8],"seqs"]) / dim(clusterSamplesMCC)[1]` including singletones
- The largest lineage contains `clusterStatsMCC$seqs[clusterStatSizeOrder[1]]` sequences hand has duration of `difftime(as.Date(date_decimal(clusterStatsMCC$mostrecent[clusterStatSizeOrder[1]])),  clusterStatsMCC$tmrca_calendar[clusterStatSizeOrder[1]], units = "day")` days
- The second largest lineage contains `clusterStatsMCC$seqs[clusterStatSizeOrder[2]]` sequences hand has duration of `difftime(as.Date(date_decimal(clusterStatsMCC$mostrecent[clusterStatSizeOrder[2]])),  clusterStatsMCC$tmrca_calendar[clusterStatSizeOrder[2]], units = "day")` days


```{r importation-distribution-weekly, fig.width=7, fig.height=5, fig.cap="Boxplots of the estimated importation lags for `r states` transmission lineages ordered by importation date and aggregated by epi-week."}
  for (s in 1:nrow(stateFiles)) {
    state <- stateFiles$state[s]
    weekShifts <- weekInfo[[s]]$weekShifts
    par(mar=c(5,6,2.5,6), cex.axis=0.7, cex.lab=0.8, mgp=c(3,0.75,0))
    plotStats(weekShifts, ylim=c(0,20), names=names(weekShifts), ylab="Importation lag", las=2, ny=16, xlab=paste("TMRCAs for week starting on", "(", state, ")"))
  }
```

```{r detection-distribution-weekly, fig.width=7, fig.height=5, fig.cap="Boxplots of the estimated detection lags for `r states` transmission lineages ordered by importation date and aggregated by epi-week."}
  for (s in 1:nrow(stateFiles)) {
    state <- stateFiles$state[s]
    weekLags <- weekInfo[[s]]$weekLags

    par(mar=c(5,6,2.5,6), cex.axis=0.7, cex.lab=0.8, mgp=c(3,0.75,0))
    plotStats(weekLags, ylim=c(0,110), names=names(weekLags), ylab="Detection lag", las=2, ny=16, xlab=paste("TMRCAs for week starting on", "(", state, ")"))
}
```



```{r tmrca-shift-comparison, fig.width=5, fig.height=3, fig.cap="Estimated importation intensity (EII) curve (black) and the histogram of lineage TMRCAs (grey) and shifted TMRCAs representing importaitons (red). Arrow here shows the start of the `r states` lockdown."}

    # tmrca_hist         <- hist(clusterStatsMCC$tmrca_calendar, breaks=tmrcaBreaks, plot=FALSE, right=FALSE)   
    # tmrca_hist_shifted <- hist(clusterStatsMCC$tmrca_shifted_calendar, breaks=tmrcaBreaks, plot=FALSE, right=FALSE)   
    
#     plotEnd <- endDate
#     
#     par(mar=c(4,6,2.5,6), cex.axis=0.7, cex.lab=0.8, mgp=c(3,0.75,0))
#     
#     dateFreqDistribution(tmrca_hist$counts, tmrcaBreaks, plot.ci=FALSE, side=4, ylab="", 
#                          #startDate = startDate, endDate = plotEnd, col=mPal(ukPal$oth), ymax=70)
#                          startDate = tmrcaBreaks[1], endDate = tmrcaBreaks[length(tmrcaBreaks)-1], col=mPal(ukPal$oth), ymax=1300)
#     
#     dateFreqDistribution(tmrca_hist_shifted$counts, tmrcaBreaks, plot.ci=FALSE, add=TRUE, 
#                          #startDate = startDate, endDate = plotEnd, col=mPal(ukPal$eng, 0.25), ymax=70)
#                          startDate = tmrcaBreaks[1], endDate = tmrcaBreaks[length(tmrcaBreaks)-1], col=mPal(ukPal$oth), ymax=1300)
#     
#     mtext(side=4, text="Frequency of TMRCAs\n(per day)", line=3, cex=par("cex.lab"))
# 
#     par(new=TRUE)
#     ymax <- 1200
#     plot(1, type='n', xlim=c(startDate, plotEnd), ylim=c(0,ymax), axes=FALSE, 
#          xaxs='i', yaxs='i', xlab="", ylab="")
# #    lines(eii$date[eii$location == "all"], eii$num_intros[eii$location == "all"], lwd=2)
#     axis(2, las=1)
#     mtext(side=2, text="Estimated importation intensity\n(solid line)", line=3, cex=par("cex.lab"))
#     
#     
#     # Mark lockdown    
#     points(x=travelDates$lockdown, y=0.1*ymax, pch=175, font=5, cex=1.5, xpd=TRUE, col=mPal(ukPal$eng))
```
    
        
```{r tmrca-shift-comparison-sizes-large-ones, fig.width=7, fig.height=6, fig.cap="LARGE (A) Histogram of lineage TMRCAs, coloured by lineage size. (B) Histogram of lineage importations, coloured by lineage size.", eval=TRUE}

  for (s in stateInfo$stateOrder ) {
    state <- stateFiles$state[s]
    clusterStatsMCC <- stateInfo$clusterStatsMCC[[s]] 
    
    # tmrcaBreaks <- seq.Date(as.Date("2019-01-01"), as.Date("2021-06-20"), by="days")
    tmrcaBreaks <- seq.Date(min(clusterStatsMCC$tmrca_shifted_calendar), max(clusterStatsMCC$tmrca_calendar), by="week")

    layout(matrix(1:2, nrow=2, byrow=TRUE))
    par(mar=c(4,6,2.5,6), cex.axis=0.7, cex.lab=0.8, cex.main=1.5, mgp=c(3,0.75,0))

    tmrcaStat <- c("tmrca_calendar", "tmrca_shifted_calendar")
    # plotStart <- as.Date("2020-02-20")
    # plotEnd <- as.Date("2020-12-20")
    plotStart <- tmrcaBreaks[1]
    plotEnd <- tmrcaBreaks[length(tmrcaBreaks)-1]
    ylabs <- c("Frequency of TMRCAs\n(per day)", "Frequency of importations\n(per day)")
    
    
    for (i in 1:length(tmrcaStat)) {
   
        cond <- clusterStatsMCC[, tmrcaStat[i]] >= tmrcaBreaks[1] & clusterStatsMCC[, tmrcaStat[i]] <= tmrcaBreaks[length(tmrcaBreaks)]

        tmrca_hist_small <- hist(clusterStatsMCC[cond & clusterStatsMCC$seqs <= 5, tmrcaStat[i]], breaks=tmrcaBreaks, plot=FALSE, right=FALSE)   
        tmrca_hist_med   <- hist(clusterStatsMCC[cond & clusterStatsMCC$seqs > 5  & clusterStatsMCC$seqs <= 25, tmrcaStat[i]], breaks=tmrcaBreaks, plot=FALSE, right=FALSE)   
        tmrca_hist_big   <- hist(clusterStatsMCC[cond & clusterStatsMCC$seqs > 25 & clusterStatsMCC$seqs <= 125, tmrcaStat[i]], breaks=tmrcaBreaks, plot=FALSE, right=FALSE)   
        tmrca_hist_huge  <- hist(clusterStatsMCC[cond & clusterStatsMCC$seqs > 125, tmrcaStat[i]], breaks=tmrcaBreaks, plot=FALSE, right=FALSE)   
        
        # Stacked barplot
        tmrca_hist_breakdown <- data.frame(huge  = tmrca_hist_huge$counts,
                                           big   = tmrca_hist_big$counts,
                                           med   = tmrca_hist_med$counts,
                                           small = tmrca_hist_small$counts)
	
	#tmrca_hist_breakdown = log(tmrca_hist_breakdown + 1)
	#tmrca_hist_breakdown[tmrca_hist_breakdown <= 0] = NA

#         dateFreqDistribution(t(tmrca_hist_breakdown[,1:2]), tmrcaBreaks, plot.ci=FALSE, barplot=TRUE, label=LETTERS[i], ylab=ylabs[i],
#                              startDate = plotStart, endDate = plotEnd, 
#                         # startDate = plotStart, endDate = tmrcaBreaks[length(tmrcaBreaks)-1], 
# 				col=mPal(unlist(ukPal), 0.75), border=mPal(unlist(ukPal)), ymax=1.5)
        
        
         dateFreqDistribution(t(tmrca_hist_breakdown), tmrcaBreaks, plot.ci=FALSE, barplot=TRUE, label=LETTERS[i], ylab=ylabs[i],
                             startDate = plotStart, endDate = plotEnd, 
                        # startDate = plotStart, endDate = tmrcaBreaks[length(tmrcaBreaks)-1], 
				col=mPal(unlist(ukPal), 0.75), border=mPal(unlist(ukPal)), ymax=max(rowSums(tmrca_hist_breakdown))+2)
         #ymax=max(rowSums(tmrca_hist_breakdown))+2
        
        
        # legend("top", horiz=FALSE, inset=c(0,-0.33), bty='n', xpd=TRUE, ncol=2,
        #        fill=mPal(unlist(ukPal, 0.75)), border = mPal(unlist(ukPal)), 
        #        legend = c("Bigger than 1000", "101 to 1000"), title = "Transmission lineage size for big size lineages",
        #        cex=0.8)
        legend("top", horiz=FALSE, inset=c(0,-0.33), bty='n', xpd=TRUE, ncol=2,
               fill=mPal(unlist(ukPal, 0.75)), border = mPal(unlist(ukPal)), 
               legend = c("Bigger than 125", "25 to 125", "5 to 25", "5 or smaller"), title = paste("Transmission lineage size of", state),
               cex=0.8)
    }
  }
    
```


        
```{r tmrca-shift-comparison-sizes, fig.width=7, fig.height=6, fig.cap="(A) Histogram of lineage TMRCAs, coloured by lineage size. (B) Histogram of lineage importations, coloured by lineage size.", eval=TRUE}

  for (s in 1:nrow(stateFiles)) {
    state <- stateFiles$state[s]
    clusterStatsMCC <- stateInfo$clusterStatsMCC[[s]] 
    
    layout(matrix(1:2, nrow=2, byrow=TRUE))
    par(mar=c(4,6,2.5,6), cex.axis=0.7, cex.lab=0.8, cex.main=1.5, mgp=c(3,0.75,0))
    tmrcaBreaks <- seq.Date(min(clusterStatsMCC$tmrca_shifted_calendar), max(clusterStatsMCC$tmrca_calendar), by="1 days")

    tmrcaStat <- c("tmrca_calendar", "tmrca_shifted_calendar")
    # plotEnd <- as.Date("2020-06-21")
    ylabs <- c("Frequency of TMRCAs\n(per day", "Frequency of importations\n(per day)")
    
    for (i in 1:length(tmrcaStat)) {

        tmrca_hist_small <- hist(clusterStatsMCC[clusterStatsMCC$seqs <= 10, tmrcaStat[i]], breaks=tmrcaBreaks, plot=FALSE, right=FALSE)   
        tmrca_hist_med   <- hist(clusterStatsMCC[clusterStatsMCC$seqs > 10  & clusterStatsMCC$seqs <= 100, tmrcaStat[i]], breaks=tmrcaBreaks, plot=FALSE, right=FALSE)   
        tmrca_hist_big   <- hist(clusterStatsMCC[clusterStatsMCC$seqs > 100 & clusterStatsMCC$seqs <= 1000, tmrcaStat[i]], breaks=tmrcaBreaks, plot=FALSE, right=FALSE)   
        tmrca_hist_huge  <- hist(clusterStatsMCC[clusterStatsMCC$seqs > 1000, tmrcaStat[i]], breaks=tmrcaBreaks, plot=FALSE, right=FALSE)   
        
        # Stacked barplot
        tmrca_hist_breakdown <- data.frame(huge  = tmrca_hist_huge$counts,
                                           big   = tmrca_hist_big$counts,
                                           med   = tmrca_hist_med$counts,
                                           small = tmrca_hist_small$counts)
	
	#tmrca_hist_breakdown = log(tmrca_hist_breakdown + 1)
	#tmrca_hist_breakdown[tmrca_hist_breakdown <= 0] = NA

        dateFreqDistribution(t(tmrca_hist_breakdown), tmrcaBreaks, plot.ci=FALSE, barplot=TRUE, label=LETTERS[i], ylab=ylabs[i],
                             #startDate = startDate, endDate = plotEnd, 
                         startDate = tmrcaBreaks[1], endDate = tmrcaBreaks[length(tmrcaBreaks)-1], 
				col=mPal(unlist(ukPal), 0.75), border=mPal(unlist(ukPal)), ymax=max(rowSums(tmrca_hist_breakdown))+2)
         # Mark sequencing    
    points(x=travelDates$lockdown, y=130, pch=25, font=50, cex=50, xpd=TRUE, col=mPal(ukPal$eng))
        
        legend("top", horiz=FALSE, inset=c(0,-0.33), bty='n', xpd=TRUE, ncol=2,
               fill=mPal(unlist(ukPal, 0.75)), border = mPal(unlist(ukPal)), 
               legend = c("Bigger than 1000", "101 to 1000", "11 to 100", "10 or smaller"), title = paste("Transmission lineage size of", state),
               cex=0.8)
        
    }
  }
```



        
```{r tmrca-shift-comparison-sizes-weekly, fig.width=7, fig.height=6, fig.cap="(A) Histogram of lineage TMRCAs, coloured by lineage size. (B) Histogram of lineage importations, coloured by lineage size.", eval=TRUE}

  for (s in 1:nrow(stateFiles)) {
    state <- stateFiles$state[s]
    clusterStatsMCC <- stateInfo$clusterStatsMCC[[s]] 
    

    # tmrcaBreaks <- seq.Date(as.Date("2019-01-01"), as.Date("2021-06-20"), by="7 days")
    tmrcaBreaks <- seq.Date(min(clusterStatsMCC$tmrca_shifted_calendar), max(clusterStatsMCC$tmrca_calendar)+7, by="7 days")

    layout(matrix(1:2, nrow=2, byrow=TRUE))
    par(mar=c(4,6,2.5,6), cex.axis=0.7, cex.lab=0.8, cex.main=1.5, mgp=c(3,0.75,0))

    tmrcaStat <- c("tmrca_calendar", "tmrca_shifted_calendar")
    # plotEnd <- as.Date("2020-06-21")
    ylabs <- c("Frequency of TMRCAs\n(per week)", "Frequency of importations\n(per week)")
    
    for (i in 1:length(tmrcaStat)) {

        tmrca_hist_small <- hist(clusterStatsMCC[clusterStatsMCC$seqs <= 5, tmrcaStat[i]], breaks=tmrcaBreaks, plot=FALSE, right=FALSE)   
        tmrca_hist_med   <- hist(clusterStatsMCC[clusterStatsMCC$seqs > 5  & clusterStatsMCC$seqs <= 25, tmrcaStat[i]], breaks=tmrcaBreaks, plot=FALSE, right=FALSE)   
        tmrca_hist_big   <- hist(clusterStatsMCC[clusterStatsMCC$seqs > 25 & clusterStatsMCC$seqs <= 125, tmrcaStat[i]], breaks=tmrcaBreaks, plot=FALSE, right=FALSE)   
        tmrca_hist_huge  <- hist(clusterStatsMCC[clusterStatsMCC$seqs > 125, tmrcaStat[i]], breaks=tmrcaBreaks, plot=FALSE, right=FALSE)   
        
        # Stacked barplot
        tmrca_hist_breakdown <- data.frame(huge  = tmrca_hist_huge$counts,
                                           big   = tmrca_hist_big$counts,
                                           med   = tmrca_hist_med$counts,
                                           small = tmrca_hist_small$counts)
	
	#tmrca_hist_breakdown = log(tmrca_hist_breakdown + 1)
	#tmrca_hist_breakdown[tmrca_hist_breakdown <= 0] = NA

        dateFreqDistribution(t(tmrca_hist_breakdown), tmrcaBreaks, plot.ci=FALSE, barplot=TRUE, label=LETTERS[i], ylab=ylabs[i],
                             #startDate = startDate, endDate = plotEnd, 
                         startDate = tmrcaBreaks[1], endDate = tmrcaBreaks[length(tmrcaBreaks)-1], 
				col=mPal(unlist(ukPal), 0.75), border=mPal(unlist(ukPal)), ymax=18)
        #max(rowSums(tmrca_hist_breakdown))+10
         # Mark sequencing    
    points(x=travelDates$lockdown, y=130, pch=25, font=50, cex=50, xpd=TRUE, col=mPal(ukPal$eng))
        
        legend("top", horiz=FALSE, inset=c(0,-0.33), bty='n', xpd=TRUE, ncol=2,
               fill=mPal(unlist(ukPal, 0.75)), border = mPal(unlist(ukPal)), 
               legend = c("Bigger than 125", "25 to 125", "5 to 25", "5 or smaller"), title = paste("Importation lineage size of", state),
               cex=0.8)
        
    }
  }
   
```
```{r function-plot_weekly_table, eval=TRUE}

# clusterFirstCaseByCounty, "adm1", dePal, paste("Transmission lineage of states", "(no singleton)"), "C", ylabs[i], 
#                         legend_ = function(x) ifelse(nchar(x) > 10, substr(x, 1, 10), x)
plot_weekly_table <- function(casesDataset, color_by_column, inPal, title, label_, ylab, legend_ = NULL, ordering_=NULL, ymax = NULL, marks_ = NULL, printTable_ = TRUE, legend.position = "top", legend.ncol = 6, legend.inset = c(0, -0.33), legend.map = FALSE, legend.map.color = dePal, legend.map.viewport = NULL) {
   
      if (is.null(ordering_)) {
         countyOrder <-
            unlist((
               casesDataset %>% group_by(.data[[color_by_column]]) %>% dplyr::summarise(nn = sum(n)) %>% arrange(-nn) 
               # %>% filter(.data[[color_by_column]] != "NA")
            )[,color_by_column])
      } else {
         countyOrder <- ordering_
      }
      
      
      clusterStatsByCounty <-
         data.frame(date = tmrcaBreaks[1:(length(tmrcaBreaks) - 1)])
      for (county in countyOrder) {
         #  clusterStateHistogram <- (clusterFirstCases %>% filter(adm1 == county, .data[[tmrcaStat[i]]] >= tmrcaBreaks[1],
         #                                                         .data[[tmrcaStat[i]]] < tmrcaBreaks[length(tmrcaBreaks)]) %>%
         #                               dplyr::select(tmrcaStat[i]))[,1] %>%
         #     hist(breaks=tmrcaBreaks, plot=FALSE, right=FALSE)
         # clusterStatsByCounty <- clusterStatsByCounty %>% bind_cols(`names<-`(data.frame(clusterStateHistogram$counts), county ))
         # clusterFirstCaseByCounty %>% filter(adm1 == county, tmrca.break.index < length(tmrcaBreaks), tmrca.break.index >= 1)
         clusterStateHistogram <-
            data.frame(tmrcaBreaks[1:(length(tmrcaBreaks) - 1)],
                       index = seq(length(tmrcaBreaks) -
                                      1)) %>% left_join(
                                         casesDataset %>% filter(
                                            .data[[color_by_column]] == county,
                                            tmrca.break.index < length(tmrcaBreaks),
                                            tmrca.break.index >= 1
                                         ) %>% group_by(tmrca.break.index) %>% dplyr::summarise(nn = sum(n)),
                                         by = c("index" = "tmrca.break.index")
                                      ) %>% mutate(nn = ifelse(is.na(nn), 0, nn))
         
         clusterStatsByCounty <-
            clusterStatsByCounty %>% bind_cols(`names<-`(data.frame(clusterStateHistogram$nn), county))
      }
      
      pal <- inPal[countyOrder]
      
      if (is.null(ymax)) {
         ymax = max(rowSums(clusterStatsByCounty %>% dplyr::select(-date))) * 1.1
      }
      
      dateFreqDistribution(
         t(clusterStatsByCounty %>% dplyr::select(-date)),
         tmrcaBreaks,
         plot.ci = FALSE,
         barplot = TRUE,
         label = label_,
         ylab = ylab,
         startDate = tmrcaBreaks[1],
         endDate = tmrcaBreaks[length(tmrcaBreaks) - 1],
         col = mPal(unlist(pal), 0.75),
         border = mPal(unlist(pal)),
         ymax = ymax,
         dateFormat = "%b %d"
      )
      
      if (length(legend_) == 1 && is.function(legend_)) {
         legend_ <- sapply(countyOrder, legend_)
      } else if (is.null(legend_)) {
         legend_ <- countyOrder
      } else {
         legend_ <- legend_[countyOrder]
      }
      
      legend(
         legend.position,
         horiz = FALSE,
         inset = legend.inset,
         bty = 'n',
         xpd = TRUE,
         ncol = legend.ncol,
         fill = mPal(unlist(pal), 0.75),
         border = mPal(unlist(pal)),
         legend = legend_,
         title = title,
         cex = 0.8
      )
      
      if (!is.null(marks_)) {
         plot.window(c(tmrcaBreaks[1], tmrcaBreaks[length(tmrcaBreaks) - 1]), c(0, ymax), xaxs="i")
         for (m in marks_) {
            arrows(as.Date(m$date), 0.9*ymax, as.Date(m$date), 0*ymax, col=m$color, lwd=1, angle=10, length=0.1)
            if ("label" %in% names(m)) {
               text(as.Date(m$date), 0.9*ymax, m$label, cex=0.65, pos=3, col=m$color)
            }
         }
      }
      
      if (printTable_) {
         print(kable(casesDataset %>% group_by(.data[[color_by_column]]) %>% dplyr::summarise(n = sum(n)) %>% 
                        mutate(p=round(n/sum(n)*100, digits=2)), caption=paste(title)))
      }
      
      if (legend.map) {
        germany <- raster::getData("GADM", country = "DEU", level = 1)
        germany.f <- fortify(germany, region = "CC_1")
        
        mapNames <- germany$VARNAME_1
        mapNames[is.na(mapNames)] <- germany$NAME_1[is.na(mapNames)]
        mapNames[mapNames == "Baden-Württemberg"] <- "Baden-Wurttemberg"
        mapNames[mapNames == "Mecklenburg-West Pomerania"] <- "Mecklenburg-Western Pomerania"
        
        germany$NAME_1_EN <- germany$NAME_1
        germany$NAME_1_EN[germany$NAME_1 == "Baden-Württemberg"] <- "Baden-Wurttemberg"
        germany$NAME_1_EN[germany$NAME_1 == "Mecklenburg-Vorpommern"] <- "Mecklenburg-Western Pomerania"
        germany$NAME_1_EN[germany$NAME_1 == "Bayern"] <- "Bavaria"
        germany$NAME_1_EN[germany$NAME_1 == "Hessen"] <- "Hesse"
        germany$NAME_1_EN[germany$NAME_1 == "Niedersachsen"] <- "Lower Saxony"
        germany$NAME_1_EN[germany$NAME_1 == "Nordrhein-Westfalen"] <- "North Rhine-Westphalia"
        germany$NAME_1_EN[germany$NAME_1 == "Rheinland-Pfalz"] <- "Rhineland-Palatinate"
        germany$NAME_1_EN[germany$NAME_1 == "Sachsen"] <- "Saxony"
        germany$NAME_1_EN[germany$NAME_1 == "Sachsen-Anhalt"] <- "Saxony-Anhalt"
        germany$NAME_1_EN[germany$NAME_1 == "Thüringen"] <- "Thuringia"
        
        germany.f$value <- germany$NAME_1_EN[match(germany.f$id, germany$CC_1)]
      
        
         # plot.new()              ## suggested by @Josh
         vps <- baseViewports()
         pushViewport(vps$figure) ##   I am in the space of the autocorrelation plot
         vp1 <-plotViewport(legend.map.viewport) ## create new vp with margins, you play with this values 
      
        p <- ggplot() + 
          geom_polygon(data = germany.f, aes(x = long, y = lat, group = group, fill = value), colour = "grey10", size = 0.1)+
          geom_polygon(data = germany.f[germany.f$id == "11",], aes(x = long, y = lat, group = group, fill = value), colour = "grey10", size = 0.1)+
          # scale_fill_gradient(low = lighten(col, 1), high = col, space = "Lab", limits=c(0, 1),
          #                     name = "legend_title")+
          # ggtitle("State colors") +
          # options(repr.plot.width=max(germany.f$lat) - min(germany.f$lat), repr.plot.height=max(germany.f$long) - min(germany.f$long)) +
          theme(axis.line=element_blank(), axis.text.x=element_blank(),
                axis.text.y=element_blank(), axis.ticks=element_blank(),
                axis.title.x=element_blank(),
                axis.title.y=element_blank(),
                panel.background=element_blank(), panel.grid.major=element_blank(),
                # panel.border = element_rect(colour = "black", fill=NA, size=0.1),
                panel.grid.minor=element_blank(), plot.background=element_blank(), 
                aspect.ratio = (max(germany.f$long) - min(germany.f$long))/(max(germany.f$lat) - min(germany.f$lat)),
                legend.position="none"
                ) + scale_fill_manual(values = legend.map.color)
        #+ guides(fill=guide_legend(ncol=2))
        print(p, vp = vp1 )
      }
}
```


```{r NPI-comparison-init}

firstCaseDistance <- 0

pangolineagePal <- list(
   "A"         = "#872434",
   "B.1.1.317"         = "#33A02C",
   "B.1.1.519"         = "#F5CF47",
   "B.1.1.7"        = "#4169E1",
   "B.1.1.70"       = "#000000",
   "B.1.160"   = "#AAB300",
   "B.1.177"       = "#FF7F00",
   "B.1.221"   = "#BE0F34",
   "B.1.258"       = "#CF7A30",
   "B.1.351"            = "#A6CEE3",
   "B.1.36"        = "#007770",
   "C"      = "#6A3D9A",
   "Other"         = "#C7C2BC"
)

firstCaseDistancesizePal <- list(huge = "#BE0F34", 
              big = "#191970", 
              med = "#F5CF47",
              small = "#9ECEEB", 
              single = "#C7C2BC")

      # plot_weekly_table(clusterFirstCaseByOrder, "lineage_size_order", firstCaseDistancesizePal, paste("Transmission lineage size of", state, "+singleton"), 
      #                   "A-2", ylabs[i], legend_=list("huge"="Bigger than 1000", "big"="101 to 1000", "med"="11 to 100", "small"="10 to 2", "single"="1"))

dePal$"NA" <- "#A0A0A0"

calculateLineageSizeOrder <- function(clusterFirstCases) {
   clusterFirstCases <- clusterFirstCases %>% mutate(lineage_size_order = ifelse(lineage_seqs <= 1, "single", 
                                                            ifelse(lineage_seqs <= 5, "small", 
                                                                   ifelse(lineage_seqs <= 25, "med",
                                                                          ifelse(lineage_seqs <= 125, "big",
                                                                          "huge")))))
   return(clusterFirstCases)
}

tmrcaBreakIndicesDF <- function(tmrcaBreaks) {
   return(tmrcaBreaks %>% sapply(function(x) which.max(x < tmrcaBreaks) - 1) %>% data.frame() %>% 
                         dplyr::rename(tmrca.break.index=1) %>% mutate(tmrca.break.index=ifelse(tmrca.break.index == 0, length(tmrcaBreaks), tmrca.break.index)))
}

```

```{r oldest-comparison-sizes-weekly, fig.width=7, fig.height=3, eval=TRUE}

# , fig.cap="(A) Histogram of lineage TMRCAs, coloured by lineage size. (B) Histogram of lineage importations, coloured by lineage size."

   s <- 1
   state <- stateFiles$state[s]
   clusterStatsMCC <- stateInfo$clusterStatsMCC[[s]]
   clusterSamplesMCC <- stateInfo$clusterSamplesMCC[[s]]
   
   clusterStatsMCC$oldest_calendar <-as.Date(round_date(date_decimal(clusterStatsMCC$oldest), unit = "day"))
   clusterSamplesMCC$oldest_calendar <- as.Date(round_date(date_decimal(clusterSamplesMCC$lineage_oldest), unit = "day"))
   clusterStatsMCC$pangolin <- gsub("_.*", "", clusterStatsMCC$cluster)
   pangolineages <- levels(as.factor(clusterStatsMCC$pangolin))
   clusterSamplesMCC$pangolin <- sapply(clusterSamplesMCC$Pango.lineage, function(x)
         pangolineages[x == pangolineages |
                          startsWith(x, paste0(pangolineages, "."))])
   
   clusterSamplesMCC <- clusterSamplesMCC %>% mutate(sample_date = ymd(sample_date)) %>% mutate(oldest_calendar = if_else(is.na(oldest_calendar), sample_date, oldest_calendar)) 
   
   # clusterSamplesMCC <- 
   #    clusterSamplesMCC %>% left_join(clusterStatsMCC %>% dplyr::select(cluster, tmrca_calendar, tmrca_shifted_calendar), by=c("cluster"="cluster")) %>%
   #    mutate(tmrca_calendar = if_else(is.na(tmrca_calendar), oldest_calendar, tmrca_calendar), 
   #           tmrca_shifted_calendar = if_else(is.na(tmrca_shifted_calendar), oldest_calendar, tmrca_shifted_calendar))
   
   
   
   # tmrcaBreaks <- seq.Date(as.Date("2019-01-01"), as.Date("2021-06-20"), by="7 days")
   # tmrcaBreaks <-
   #    seq.Date(
   #       min(clusterStatsMCC$oldest_calendar),
   #       max(clusterStatsMCC$oldest_calendar) + 7,
   #       by = "7 days"
   #    )
   tmrcaBreaks <- seq.Date(min(clusterStatsMCC$tmrca_shifted_calendar), max(clusterStatsMCC$tmrca_calendar)+7+7+7, by="7 days")
   tmrcaBreaks <- tmrcaBreaks[tmrcaBreaks >= max(tmrcaBreaks[tmrcaBreaks <= as.Date("2020-08-30")])]
   tmrcaBreaks <- seq.Date(as.Date("2020-08-27"), as.Date("2021-06-03")+7, by="week")

 #  layout(matrix(1:2, nrow = 2, byrow = TRUE))
  # old.par <- par(mar = c(4, 6, 2.5, 6), cex.axis = 0.7, cex.lab = 0.8, cex.main = 1.5, mgp = c(3, 0.75, 0))
   # 
   tmrcaStat <- c("oldest_calendar")
   ylabs <- c("Frequency of oldest seq\n(per week)")
   
   # tmrcaStat <- c("tmrca_calendar", "tmrca_shifted_calendar", "oldest_calendar")
   # ylabs <- c("Frequency of TMRCAs\n(per week)", "Frequency of importations\n(per week)", "Frequency of oldest seq\n(per week)")
    
   for (i in 1:length(tmrcaStat)) {
      tmrca_hist_single <-
         hist(
            clusterSamplesMCC[clusterSamplesMCC$lineage_seqs == 1 &
                                 clusterSamplesMCC[, tmrcaStat[i]] >= tmrcaBreaks[1] &
                                 clusterSamplesMCC[, tmrcaStat[i]] < tmrcaBreaks[length(tmrcaBreaks)], tmrcaStat[i]],
            breaks = tmrcaBreaks,
            plot = FALSE,
            right = FALSE
         )
      tmrca_hist_small <-
         hist(clusterStatsMCC[clusterStatsMCC$seqs <= 10 &
                                 clusterStatsMCC$seqs > 1&
                                 clusterStatsMCC[, tmrcaStat[i]] >= tmrcaBreaks[1] &
                                 clusterStatsMCC[, tmrcaStat[i]] < tmrcaBreaks[length(tmrcaBreaks)], tmrcaStat[i]],
              breaks = tmrcaBreaks,
              plot = FALSE,
              right = FALSE)
      tmrca_hist_med   <-
         hist(clusterStatsMCC[clusterStatsMCC$seqs > 10  &
                                 clusterStatsMCC$seqs <= 100&
                                 clusterStatsMCC[, tmrcaStat[i]] >= tmrcaBreaks[1] &
                                 clusterStatsMCC[, tmrcaStat[i]] < tmrcaBreaks[length(tmrcaBreaks)], tmrcaStat[i]],
              breaks = tmrcaBreaks,
              plot = FALSE,
              right = FALSE)
      tmrca_hist_big   <-
         hist(clusterStatsMCC[clusterStatsMCC$seqs > 100 &
                                 clusterStatsMCC$seqs <= 1000&
                                 clusterStatsMCC[, tmrcaStat[i]] >= tmrcaBreaks[1] &
                                 clusterStatsMCC[, tmrcaStat[i]] < tmrcaBreaks[length(tmrcaBreaks)], tmrcaStat[i]],
              breaks = tmrcaBreaks,
              plot = FALSE,
              right = FALSE)
      tmrca_hist_huge  <-
         hist(clusterStatsMCC[clusterStatsMCC$seqs > 1000&
                                 clusterStatsMCC[, tmrcaStat[i]] >= tmrcaBreaks[1] &
                                 clusterStatsMCC[, tmrcaStat[i]] < tmrcaBreaks[length(tmrcaBreaks)], tmrcaStat[i]],
              breaks = tmrcaBreaks,
              plot = FALSE,
              right = FALSE)
      # Stacked barplot
      tmrca_hist_breakdown <-
         data.frame(
            huge  = tmrca_hist_huge$counts,
            big   = tmrca_hist_big$counts,
            med   = tmrca_hist_med$counts,
            small = tmrca_hist_small$counts,
            single = tmrca_hist_single$counts
         )
      
      #tmrca_hist_breakdown = log(tmrca_hist_breakdown + 1)
      #tmrca_hist_breakdown[tmrca_hist_breakdown <= 0] = NA
      
      dateFreqDistribution(
         t(tmrca_hist_breakdown),
         tmrcaBreaks,
         plot.ci = FALSE,
         barplot = TRUE,
         label = LETTERS[i],
         ylab = ylabs[i],
         #startDate = startDate, endDate = plotEnd,
         startDate = tmrcaBreaks[1],
         endDate = tmrcaBreaks[length(tmrcaBreaks) - 1],
         col = mPal(unlist(ukPal), 0.75),
         border = mPal(unlist(ukPal)),
         ymax = 45
      )
      #max(rowSums(tmrca_hist_breakdown))+10
      # Mark sequencing
      points(x = travelDates$lockdown, y = 130, pch = 25, font = 50,
         cex = 50, xpd = TRUE, col = mPal(ukPal$eng))
      
      legend("top", horiz = FALSE, inset = c(0,-0.33), bty = 'n', xpd = TRUE, ncol = 3,
         fill = mPal(unlist(ukPal, 0.75)), border = mPal(unlist(ukPal)),
         legend = c("Bigger than 1000", "101 to 1000", "11 to 100", "10 to 2", "1"),
         title = paste("Transmission lineage size of", state, "(no singleton)"),
         cex = 0.8
      )

      clusterStatsMCCWithSingles <-
         clusterStatsMCC %>% dplyr::select(tmrcaStat[i], pangolin) %>% 
         bind_rows(
            clusterSamplesMCC %>% filter(lineage_seqs == 1) %>% dplyr::select(tmrcaStat[i], pangolin) %>% mutate(cluster.first.case.count = 1)
         )
      clusterStatsByPangolineage <-
         data.frame(date = tmrcaBreaks[1:(length(tmrcaBreaks) - 1)])
      for (l in pangolineages) {
         clusterStateHistogram <-
            (
               clusterStatsMCCWithSingles %>% filter(pangolin == l,
                                                     .data[[tmrcaStat[i]]] >= tmrcaBreaks[1],
                                                     .data[[tmrcaStat[i]]] < tmrcaBreaks[length(tmrcaBreaks)]) %>% dplyr::select(tmrcaStat[i])
            )[, 1] %>% hist(breaks = tmrcaBreaks, plot = FALSE, right = FALSE)
         clusterStatsByPangolineage <-
            clusterStatsByPangolineage %>% bind_cols(`names<-`(data.frame(clusterStateHistogram$counts), l))
      }
      
      dateFreqDistribution(t(clusterStatsByPangolineage %>% dplyr::select(-date)),
         tmrcaBreaks, plot.ci = FALSE, barplot = TRUE, label = "B", ylab = ylabs[i],
         startDate = tmrcaBreaks[1], endDate = tmrcaBreaks[length(tmrcaBreaks) - 1],
         col = mPal(unlist(pangolineagePal), 0.75), border = mPal(unlist(pangolineagePal)), ymax = 45
      )

      legend("top", horiz = FALSE, inset = c(0, -0.33), bty = 'n',
         xpd = TRUE, ncol = 6, fill = mPal(unlist(pangolineagePal), 0.75),
         border = mPal(unlist(pangolineagePal)), legend = pangolineages,
         title = paste("Transmission lineage of pangolineage", "(no singleton)"), cex = 0.8)
   }
```

```{r oldest-comparison-sizes-weekly-2, fig.width=7, fig.height=3, eval=TRUE}
#par(mar=c(4,4,2.5,5), cex.axis=0.7, cex.lab=0.8, mgp=c(2,0.75,0))
   par(mar = c(4, 6, 3, 8))
   for (i in 1:length(tmrcaStat)) {

      clusterFirstCases <-
         clusterSamplesMCC %>% filter(
            lineage_seqs > 1 &
               abs(.data[[tmrcaStat[i]]] - sample_date) < 1 / 366 + firstCaseDistance / 366
               # ((.data[[tmrcaStat[i]]] - decimal_date) < 1 / 366 + firstCaseDistance / 366 & 
               #     (.data[[tmrcaStat[i]]] - decimal_date) > -1 / 366 - firstCaseDistance / 366)
         )
      clusterFirstCasesCount <-
         clusterFirstCases %>% group_by(cluster) %>% dplyr::summarise(cluster.first.case.count = n())
      clusterFirstCases <-
         clusterFirstCases %>% left_join(clusterFirstCasesCount, by = c("cluster" = "cluster"))
      clusterFirstCaseByCounty <-
         clusterFirstCases %>% 
         mutate(tmrca.break.index = sapply(oldest_calendar, function(x) which.max(x < tmrcaBreaks) - 1)) %>%
         group_by(adm1, tmrca.break.index) %>%
         dplyr::summarise(n = sum(1 / cluster.first.case.count)) %>%
         mutate(p =  round(n / sum(n) * 100, digits = 1)) %>% arrange(desc(n))

      plot_weekly_table(clusterFirstCaseByCounty, "adm1", dePal, paste("Transmission lineage of states", "(no singleton)"), "C", ylabs[i], 
                        legend_ = function(x) ifelse(nchar(x) > 10, substr(x, 1, 10), x))

      germanyImportantStates <- c("North Rhine-Westphalia", "Bavaria", "Baden-Wurttemberg")
      clusterFirstCaseByCountyWS <-
         clusterFirstCases %>% 
         left_join(clusterFirstCasesCount %>% dplyr::select(cluster), by = c("cluster" = "cluster")) %>% 
         bind_rows(clusterSamplesMCC %>% filter(lineage_seqs == 1) %>% mutate(cluster.first.case.count = 1)) %>%
         mutate(tmrca.break.index = sapply(oldest_calendar, function(x) which.max(x < tmrcaBreaks) - 1)) %>%
         mutate(adm1 = ifelse(adm1 %in% germanyImportantStates, adm1, "Other")) %>%
         group_by(adm1, tmrca.break.index) %>%
         dplyr::summarise(n = sum(1 / cluster.first.case.count)) %>%
         mutate(p =  round(n / sum(n) * 100, digits = 1)) %>% arrange(desc(n))
            
   
      plot_weekly_table(clusterFirstCaseByCountyWS, "adm1", sdePal, "", "", "Number of importation linages\ncounted on date of earliest sequence", 
                        legend_ = function(x) ifelse(nchar(x) > 10, substr(x, 1, 10), x), ordering_ = c(germanyImportantStates, "Other"), legend.position = "right", legend.ncol = 1, legend.inset = c(-0.3, 0))
      

      
      # Normalized of A

      
      # clusterFirstCaseByOrder <-
      #    clusterFirstCases %>% 
      #    bind_rows(clusterSamplesMCC %>% filter(lineage_seqs == 1) %>% mutate(cluster.first.case.count = 1)) %>%
      #    calculateLineageSizeOrder() %>% 
      #    mutate(tmrca.break.index = sapply(oldest_calendar, function(x) which.max(x < tmrcaBreaks) - 1)) %>%
      #    group_by(lineage_size_order, tmrca.break.index) %>%
      #    dplyr::summarise(n = sum(1 / cluster.first.case.count)) %>%
      #    mutate(p =  round(n / sum(n) * 100, digits = 1)) %>% arrange(desc(n))

  #    plot_weekly_table(clusterFirstCaseByOrder, "lineage_size_order", firstCaseDistancesizePal, paste("Transmission lineage size of", state, "+singleton"), 
  #                      "A-2", ylabs[i], legend_=list("huge"="Bigger than 1000", "big"="101 to 1000", "med"="11 to 100", "small"="10 to 2", "single"="1"))

      # Normalized of 
      clusterFirstCaseByPangilin <-
         clusterFirstCases %>% 
         bind_rows(clusterSamplesMCC %>% filter(lineage_seqs == 1) %>% mutate(cluster.first.case.count = 1)) %>%
         mutate(tmrca.break.index = sapply(oldest_calendar, function(x) which.max(x < tmrcaBreaks) - 1)) %>%
         group_by(pangolin, tmrca.break.index) %>%
         dplyr::summarise(n = sum(1 / cluster.first.case.count)) %>%
         mutate(p =  round(n / sum(n) * 100, digits = 1)) %>% arrange(desc(n))
      
      plot_weekly_table(clusterFirstCaseByPangilin, "pangolin", pangolineagePal, paste("Transmission lineage of states"), 
                        "B-2", ylabs[i])
      
      
      # The same chart for Saxony and Bavaria

      # clusterFirstCaseByCounty <-
      #    clusterFirstCases %>% 
      #    bind_rows(clusterSamplesMCC %>% filter(lineage_seqs == 1) %>% mutate(cluster.first.case.count = 1)) %>%
      #    mutate(tmrca.break.index = sapply(oldest_calendar, function(x) which.max(x < tmrcaBreaks) - 1)) %>%
      #    group_by(adm1, tmrca.break.index) %>%
      #    dplyr::summarise(n = sum(1 / cluster.first.case.count)) %>%
      #    mutate(p =  round(n / sum(n) * 100, digits = 1)) %>% arrange(desc(n))
      # 

      dePal2 <- lapply(dePal, function(x) dePal$oth)
      dePal2$Saxony = dePal$Saxony
      dePal2$Bavaria = dePal$Bavaria
      
      # plot_weekly_table(clusterFirstCaseByCounty, "adm1", dePal2, paste("Transmission lineage of states", "+singletons"), 
      #                   "C-2", ylabs[i], 
      #                   legend_ = function(x) ifelse(nchar(x) > 10, substr(x, 1, 10), x),
      #                   ordering_ = c("North Rhine-Westphalia", "Bavaria", "Baden-Wurttemberg", "Saxony",  
      #                                 "Rhineland-Palatinate", "Saxony-Anhalt", "Thuringia", "Hesse", "Berlin", "Hamburg", 
      #                                 "Bremen", "Saarland", "Lower Saxony", "Mecklenburg-Western Pomerania", "Schleswig-Holstein", "Brandenburg"))

      ## Sequence colored by first-case-county weight normalized
      
      sampleFirstCase <- clusterFirstCases %>% dplyr::select(cluster, cluster.first.case.count, adm1, tmrcaStat[i]) %>% full_join(
         clusterSamplesMCC %>% dplyr::select(Accession.ID, cluster, sample_date, sample_adm1=adm1),
         by = c("cluster" = "cluster")
      ) %>% mutate(cluster.first.case.count = ifelse(is.na(cluster.first.case.count), 1, cluster.first.case.count),
                   adm1=ifelse(is.na(adm1), sample_adm1, adm1),
                   oldest_calendar=ifelse(is.na(oldest_calendar), sample_date, oldest_calendar)) %>%
         mutate(tmrca.break.index = c(sapply(sample_date, function(x) which.max(x < tmrcaBreaks) - 1))) %>% 
         group_by(adm1, tmrca.break.index) %>% dplyr::summarise(n = sum(1/cluster.first.case.count))

      
      
      # old.par <-par(mar = c(4, 6, 1, 10))
      # ylabs <- c("Frequency of lineage sequences\ncolored by first state of lineage\n(per week)")
      # plot_weekly_table(sampleFirstCase %>% 
      #                      mutate(adm1 = if_else(adm1 %in% c("North Rhine-Westphalia", "Bavaria", "Baden-Wurttemberg"), adm1, "Other" )) %>% 
      #                      group_by(adm1, tmrca.break.index) %>% 
      #                      dplyr::summarise(n = sum(n)), 
      #                   "adm1", sdePal, 
      #                   # paste("Subsampled sequences colored by state of the corresponding lineage's oldest seq's state"), 
      #                   "",
      #                   "D", ylabs[1],
      #                   #  ordering_ = c("North Rhine-Westphalia", "Bavaria", "Baden-Wurttemberg", "Saxony",  
      #                   #               "Rhineland-Palatinate", "Saxony-Anhalt", "Thuringia", "Hesse", "Berlin", "Hamburg", 
      #                   #               "Bremen", "Saarland", "Lower Saxony", "Mecklenburg-Western Pomerania", "Schleswig-Holstein", "Brandenburg", "Other"),
      #                ordering_  = c("North Rhine-Westphalia", "Bavaria", "Baden-Wurttemberg", "Other"), 
      #                   # legend_ = function(x) ifelse(nchar(x) > 10, substr(x, 1, 10), x)
      #                legend.position = "topright",
      #                legend.inset = c(-0.40, 0), legend.ncol = 1,
      #                legend.map = TRUE, legend.map.color = sdePal, legend.map.viewport = c(2,30,5,1))
      # 
      # plot_weekly_table(sampleFirstCase, 
      #                   "adm1", dePal, 
      #                   # paste("Subsampled sequences colored by state of the corresponding lineage's oldest seq's state"), 
      #                   "",
      #                   "D'", ylabs[1],
      #                   #  ordering_ = c("North Rhine-Westphalia", "Bavaria", "Baden-Wurttemberg", "Saxony",  
      #                   #               "Rhineland-Palatinate", "Saxony-Anhalt", "Thuringia", "Hesse", "Berlin", "Hamburg", 
      #                   #               "Bremen", "Saarland", "Lower Saxony", "Mecklenburg-Western Pomerania", "Schleswig-Holstein", "Brandenburg", "Other"),
      #                # ordering_  = c("North Rhine-Westphalia", "Bavaria", "Baden-Wurttemberg", "Other"), 
      #                   # legend_ = function(x) ifelse(nchar(x) > 10, substr(x, 1, 10), x)
      #             legend_ = function(x) shortStateName[x],
      #             legend.position = "topright",
      #             legend.inset = c(-0.45, 0), legend.ncol = 3,
      #             legend.map = TRUE, legend.map.color = dePal, legend.map.viewport = c(2,30,6,1))

      # par(old.par) 

      # plot_weekly_table(clusterFirstCaseByCounty, "adm1", dePal2, paste("Transmission lineage of states"), 
      #                   "B-2", ylabs[i], 
      #                   legend_ = function(x) ifelse(nchar(x) > 10, substr(x, 1, 10), x),
      #                   ordering_ = c("Saxony", "Bavaria", "North Rhine-Westphalia", "Baden-Wurttemberg", 
      #                                 "Rhineland-Palatinate", "Saxony-Anhalt", "Thuringia", "Hesse", "Berlin", "Hamburg", 
      #                                 "Bremen", "Saarland", "Lower Saxony", "Mecklenburg-Western Pomerania", "Schleswig-Holstein", "Brandenburg"))

   # tmrcaBreaks <- seq.Date(as.Date("2019-01-01"), as.Date("2021-06-20"), by="7 days")

      sampleFirstCase <-
         clusterFirstCases %>% dplyr::select(cluster, cluster.first.case.count, adm1, tmrcaStat[i]) %>% full_join(
            clusterSamplesMCC %>% dplyr::select(Accession.ID, cluster, sample_date, sample_adm1 = adm1),
            by = c("cluster" = "cluster")
         ) %>% mutate(
            cluster.first.case.count = ifelse(is.na(cluster.first.case.count), 1, cluster.first.case.count),
            adm1 = ifelse(is.na(adm1), sample_adm1, adm1),
            oldest_calendar = ifelse(is.na(oldest_calendar), sample_date, oldest_calendar)
         ) %>%
         mutate(tmrca.break.index = c(sapply(sample_date, function(x)
            which.max(x < tmrcaBreaks) - 1))) %>%
         group_by(adm1, tmrca.break.index) %>% dplyr::summarise(n = sum(1 / cluster.first.case.count))

      
      pal <- dePal
      #pal["Bavaria"]="#FF69B4"

      plot_weekly_table(sampleFirstCase, "adm1", pal, paste("Subsampled sequences colored by state of first case of it's lineage (normalized)"),
                        "E", ylabs[i], 
                        legend_ = function(x) ifelse(nchar(x) > 10, substr(x, 1, 10), x))

   }

   # tmrcaBreaks <-
   #    seq.Date(
   #       min(clusterStatsMCC$oldest_calendar),
   #       max(clusterStatsMCC$oldest_calendar) + 7,
   #       by = "7 days"
   #    )
   
   # For samples
   
      clusterSamplesMCCByPangolin <-
         clusterSamplesMCC %>% 
         mutate(tmrca.break.index = c(sapply(sample_date, function(x) which.max(x < tmrcaBreaks) - 1))) %>%
         group_by(pangolin, tmrca.break.index) %>% dplyr::summarise(n = n()) 

   
      plot_weekly_table(clusterSamplesMCCByPangolin, "pangolin", pangoPal, paste("Pango Lineage"),
                        "F", "Frequency of samples\n(per week)", legend.position = "right", legend.ncol = 1, legend.inset = c(-0.33, 0.0), 
                        ordering_ = clusterSamplesMCCByPangolin %>% pull(pangolin) %>% as.factor() %>% levels())

# 
#       allSeqByPangoli <-
#          metadataAllSequences %>% filter(country == "Germany") %>%
#          mutate(tmrca.break.index = c(sapply(sample_date, function(x) which.max(x < tmrcaBreaks) - 1))) %>%
#          group_by(Pango.lineage, tmrca.break.index) %>% dplyr::summarise(n = n()) 
#       
#       plot_weekly_table(allSeqByPangoli, "Pango.lineage", pangoPal, paste("Pango Lineage"),
#                         "F", "Frequency of samples\n(per week)", legend.position = "right", legend.ncol = 1, legend.inset = c(-0.33, 0.0), 
#                         ordering_ = allSeqByPangoli %>% pull(Pango.lineage) %>% as.factor() %>% levels())

```
```{r}
# Sequences from Germany in third wave count by pangolineage
metadataAllSequences %>% filter(country == "Germany", sample_date >= as.Date("2021-02-01")) %>% group_by(Pango.lineage) %>% dplyr::summarise(n = n()) %>% arrange(-n)
```

```{r Samples colored by origin of lineage, fig.width=8, fig.height=3, eval=TRUE}
#par(mar=c(4,4,2.5,5), cex.axis=0.7, cex.lab=0.8, mgp=c(2,0.75,0))
   par(mar = c(4, 6, 1, 10))
   for (i in 1:length(tmrcaStat)) {

      clusterFirstCases <-
         clusterSamplesMCC %>% filter(
            lineage_seqs > 1 &
               abs(.data[[tmrcaStat[i]]] - sample_date) < 1 / 366 + firstCaseDistance / 366
               # ((.data[[tmrcaStat[i]]] - decimal_date) < 1 / 366 + firstCaseDistance / 366 & 
               #     (.data[[tmrcaStat[i]]] - decimal_date) > -1 / 366 - firstCaseDistance / 366)
         )
      clusterFirstCasesCount <-
         clusterFirstCases %>% group_by(cluster) %>% dplyr::summarise(cluster.first.case.count = n())
      clusterFirstCases <-
         clusterFirstCases %>% left_join(clusterFirstCasesCount, by = c("cluster" = "cluster"))
      clusterFirstCaseByCounty <-
         clusterFirstCases %>% 
         mutate(tmrca.break.index = sapply(oldest_calendar, function(x) which.max(x < tmrcaBreaks) - 1)) %>%
         group_by(adm1, tmrca.break.index) %>%
         dplyr::summarise(n = sum(1 / cluster.first.case.count)) %>%
         mutate(p =  round(n / sum(n) * 100, digits = 1)) %>% arrange(desc(n))

#      plot_weekly_table(clusterFirstCaseByCounty, "adm1", dePal, paste("Transmission lineage of states", "(no singleton)"), "C", ylabs[i], 
 #                       legend_ = function(x) ifelse(nchar(x) > 10, substr(x, 1, 10), x))
      
   

      
      # Normalized of A

      
      clusterFirstCaseByOrder <-
         clusterFirstCases %>% 
         bind_rows(clusterSamplesMCC %>% filter(lineage_seqs == 1) %>% mutate(cluster.first.case.count = 1)) %>%
         calculateLineageSizeOrder() %>% 
         mutate(tmrca.break.index = sapply(oldest_calendar, function(x) which.max(x < tmrcaBreaks) - 1)) %>%
         group_by(lineage_size_order, tmrca.break.index) %>%
         dplyr::summarise(n = sum(1 / cluster.first.case.count)) %>%
         mutate(p =  round(n / sum(n) * 100, digits = 1)) %>% arrange(desc(n))

#      plot_weekly_table(clusterFirstCaseByOrder, "lineage_size_order", firstCaseDistancesizePal, paste("Transmission lineage size of", state, "+singleton"), 
#                        "A-2", ylabs[i], legend_=list("huge"="Bigger than 1000", "big"="101 to 1000", "med"="11 to 100", "small"="10 to 2", "single"="1"))

      # Normalized of 
      clusterFirstCaseByPangilin <-
         clusterFirstCases %>% 
         bind_rows(clusterSamplesMCC %>% filter(lineage_seqs == 1) %>% mutate(cluster.first.case.count = 1)) %>%
         mutate(tmrca.break.index = sapply(oldest_calendar, function(x) which.max(x < tmrcaBreaks) - 1)) %>%
         group_by(pangolin, tmrca.break.index) %>%
         dplyr::summarise(n = sum(1 / cluster.first.case.count)) %>%
         mutate(p =  round(n / sum(n) * 100, digits = 1)) %>% arrange(desc(n))
      
#      plot_weekly_table(clusterFirstCaseByPangilin, "pangolin", pangolineagePal, paste("Transmission lineage of states"), 
#                        "B-2", ylabs[i])
      
      
      # The same chart for Saxony and Bavaria

      clusterFirstCaseByCounty <-
         clusterFirstCases %>% 
         bind_rows(clusterSamplesMCC %>% filter(lineage_seqs == 1) %>% mutate(cluster.first.case.count = 1)) %>%
         mutate(tmrca.break.index = sapply(oldest_calendar, function(x) which.max(x < tmrcaBreaks) - 1)) %>%
         group_by(adm1, tmrca.break.index) %>%
         dplyr::summarise(n = sum(1 / cluster.first.case.count)) %>%
         mutate(p =  round(n / sum(n) * 100, digits = 1)) %>% arrange(desc(n))


      dePal2 <- lapply(dePal, function(x) dePal$oth)
      dePal2$Saxony = dePal$Saxony
      dePal2$Bavaria = dePal$Bavaria
      
 #     plot_weekly_table(clusterFirstCaseByCounty, "adm1", dePal2, paste("Transmission lineage of states", "+singletons"), 
  #                      "C-2", ylabs[i], 
  #                      legend_ = function(x) ifelse(nchar(x) > 10, substr(x, 1, 10), x),
  #                      ordering_ = c("North Rhine-Westphalia", "Bavaria", "Baden-Wurttemberg", "Saxony",  
  #                                    "Rhineland-Palatinate", "Saxony-Anhalt", "Thuringia", "Hesse", "Berlin", "Hamburg", 
  #                                    "Bremen", "Saarland", "Lower Saxony", "Mecklenburg-Western Pomerania", "Schleswig-Holstein", "Brandenburg"))

      ## Sequence colored by first-case-county weight normalized
      
      sampleFirstCase <- clusterFirstCases %>% dplyr::select(cluster, cluster.first.case.count, adm1, tmrcaStat[i]) %>% full_join(
         clusterSamplesMCC %>% dplyr::select(Accession.ID, cluster, sample_date, sample_adm1=adm1),
         by = c("cluster" = "cluster")
      ) %>% mutate(cluster.first.case.count = ifelse(is.na(cluster.first.case.count), 1, cluster.first.case.count),
                   adm1=ifelse(is.na(adm1), sample_adm1, adm1),
                   oldest_calendar=ifelse(is.na(oldest_calendar), sample_date, oldest_calendar)) %>%
         mutate(tmrca.break.index = c(sapply(sample_date, function(x) which.max(x < tmrcaBreaks) - 1))) %>% 
         group_by(adm1, tmrca.break.index) %>% dplyr::summarise(n = sum(1/cluster.first.case.count))

      
      
      # old.par <-par(mar = c(4, 6, 1, 10))
      ylabs <- c("Frequency of lineage sequences\ncolored by first state of lineage\n(per week)")
      plot_weekly_table(sampleFirstCase %>% 
                           mutate(adm1 = if_else(adm1 %in% c("North Rhine-Westphalia", "Bavaria", "Baden-Wurttemberg"), adm1, "Other" )) %>% 
                           group_by(adm1, tmrca.break.index) %>% 
                           dplyr::summarise(n = sum(n)), 
                        "adm1", sdePal, 
                        # paste("Subsampled sequences colored by state of the corresponding lineage's oldest seq's state"), 
                        "",
                        "D", ylabs[1],
                        #  ordering_ = c("North Rhine-Westphalia", "Bavaria", "Baden-Wurttemberg", "Saxony",  
                        #               "Rhineland-Palatinate", "Saxony-Anhalt", "Thuringia", "Hesse", "Berlin", "Hamburg", 
                        #               "Bremen", "Saarland", "Lower Saxony", "Mecklenburg-Western Pomerania", "Schleswig-Holstein", "Brandenburg", "Other"),
                     ordering_  = c("North Rhine-Westphalia", "Bavaria", "Baden-Wurttemberg", "Other"), 
                        # legend_ = function(x) ifelse(nchar(x) > 10, substr(x, 1, 10), x)
                     legend.position = "topright",
                     legend.inset = c(-0.40, 0), legend.ncol = 1,
                     legend.map = TRUE, legend.map.color = sdePal, legend.map.viewport = c(2,30,5,1))
      
      plot_weekly_table(sampleFirstCase, 
                        "adm1", dePal, 
                        # paste("Subsampled sequences colored by state of the corresponding lineage's oldest seq's state"), 
                        "",
                        "D'", ylabs[1],
                        #  ordering_ = c("North Rhine-Westphalia", "Bavaria", "Baden-Wurttemberg", "Saxony",  
                        #               "Rhineland-Palatinate", "Saxony-Anhalt", "Thuringia", "Hesse", "Berlin", "Hamburg", 
                        #               "Bremen", "Saarland", "Lower Saxony", "Mecklenburg-Western Pomerania", "Schleswig-Holstein", "Brandenburg", "Other"),
                     # ordering_  = c("North Rhine-Westphalia", "Bavaria", "Baden-Wurttemberg", "Other"), 
                        # legend_ = function(x) ifelse(nchar(x) > 10, substr(x, 1, 10), x)
                  legend_ = function(x) shortStateName[x],
                  legend.position = "topright",
                  legend.inset = c(-0.45, 0), legend.ncol = 3,
                  legend.map = TRUE, legend.map.color = dePal, legend.map.viewport = c(2,30,6,1))

      # par(old.par) 

 
 

   }

  

```

```{r frequency of pango sequences, fig.width=7, fig.height=4, eval=TRUE}

# par(mar=c(4,4,2.5,5), cex.axis=0.7, cex.lab=0.8, mgp=c(2,0.75,0))
par(mar = c(4, 6, 1, 8))

# For sequences
sampleByPangolineage <-
   data.frame(date = tmrcaBreaks[1:(length(tmrcaBreaks) - 1)])
for (l in pangolineages) {
   clusterStateHistogram <-
      (
         metadataAllSequences  %>% filter(
            country == "Germany",
            Pango.lineage == l |
               startsWith(Pango.lineage, paste0(l, ".")),
            sample_date >= tmrcaBreaks[1],
            sample_date < tmrcaBreaks[length(tmrcaBreaks)]
         ) %>% dplyr::select(sample_date)
      )[, 1] %>% hist(breaks = tmrcaBreaks,
                      plot = FALSE,
                      right = FALSE)
   sampleByPangolineage <-
      sampleByPangolineage %>% bind_cols(`names<-`(data.frame(clusterStateHistogram$counts), l))
}

col <- unlist(pangoPal[sampleByPangolineage %>% dplyr::select(-date) %>% colnames()])

dateFreqDistribution(
   t(sampleByPangolineage %>% dplyr::select(-date)),
   tmrcaBreaks,
   plot.ci = FALSE,
   barplot = TRUE,
   label = "",
   ylab = "Frequency of sequences\n(per week)",
   startDate = tmrcaBreaks[10],
   endDate = tmrcaBreaks[length(tmrcaBreaks) - 1],
   border = col,
   col = lighten(col,0.1),
#   border = darken(col,0.1),
   ymax = 10000 * 1.1
)

legend(
   "right",
   horiz = FALSE,
   inset = c(-0.2, 0),
   bty = 'n',
   xpd = TRUE,
   ncol = 1,
   fill = mPal(col),
   border = "#bababa",
   legend = pangolineages,
   title = paste("Pango Lineage"),
   cex = 0.8
)

```
```{r frequency of pango sequences 2, fig.width=7, fig.height=4, eval=TRUE}
   par(mar = c(4, 6, 1, 8))

   allSeqByPangoli <-
      metadataAllSequences %>% filter(country == "Germany", sample_date >= tmrcaBreaks[1]) %>%
      mutate(tmrca.break.index = c(sapply(sample_date, function(x) which.max(x < tmrcaBreaks) - 1))) %>%
      group_by(Pango.lineage, tmrca.break.index) %>% dplyr::summarise(n = n())
   
   largerPangolineages <- allSeqByPangoli %>% group_by(Pango.lineage) %>% dplyr::summarise(n = sum(n)) %>% filter(n >= 1000) %>% pull(Pango.lineage)
   
   allSeqByPangoli <- allSeqByPangoli %>% filter(Pango.lineage %in% largerPangolineages)

   # plot_weekly_table(allSeqByPangoli, "Pango.lineage", pangoPal, paste("Pango Lineage"),
   #                   "F", "Frequency of samples\n(per week)", legend.position = "right", legend.ncol = 3, legend.inset = c(-0.33, 0.0),
   #                   ordering_ = allSeqByPangoli %>% pull(Pango.lineage) %>% as.factor() %>% levels())

```

```{r test-001, fig.width=8, fig.height=3, eval=TRUE}
      
   # plot_weekly_table(clusterFirstCaseByCountyWithSingles %>%
   #                      mutate(adm1 = ifelse(adm1 %in% c("North Rhine-Westphalia", "Bavaria", "Baden-Wurttemberg"), adm1, "Other")) %>% 
   #                      group_by(adm1, tmrca.break.index) %>% dplyr::summarise(n = sum(n)), "adm1", 
   #                   sdePal, 
   #                   NULL, # paste("A) Imp. events of states", "+single"), 
   #                   "", "Frequency of importation events",
   #                   # legend_ = function(x) ifelse(x %in% names(stateNameShort), stateNameShort[x], x),
   #                   # legend_ = function(x) ifelse(nchar(x) > 10, substr(x, 1, 10), x),
   #                   ordering_  = c("North Rhine-Westphalia", "Bavaria", "Baden-Wurttemberg", "Other"), 
   #                   legend.position = "topright",
   #                   legend.inset = c(-0.33, 0), legend.ncol = 1,
   #                   legend.map = TRUE, legend.map.color = sdePal, legend.map.viewport = c(2,30,5,1))


```


```{r importation-comparison-sizes-weekly-with-singles, fig.width=7, fig.height=3, eval=TRUE}

par(mar = c(4, 6, 2.5, 6), cex.axis = 0.7, cex.lab = 0.8, cex.main = 1.5, mgp = c(3, 0.75, 0))

tmrcaBreaks <- seq.Date(min(clusterStatsMCC$tmrca_shifted_calendar), max(clusterStatsMCC$tmrca_calendar), by="week")
ymax <- 40

nationalcol = "#980043"
marks_ <- list(
   "Ncoldsymp19Oct"= list(
         "date"= "2020-10-19",
         "color"= nationalcol,
         label="N1"
   ),
   "Nopera02Nov"= list(
         "date"= "2020-11-02",
         "color"= nationalcol,
         label="N2"
   ),
   "Nopera08Nov"= list(
         "date"= "2020-11-08",
         "color"= nationalcol,
         label="N3"
   ),
    "Nopera30Nov"= list(
         "date"= "2020-11-30",
         "color"= nationalcol,
         label="N4"
   ),
   "Nlockdown16Dec"= list(
      "date"= "2020-12-16",
      "color"= nationalcol,
         label="N5"
   ), 
   "Nlockdown16Dec"= list(
      "date"= "2020-12-22",
      "color"= nationalcol,
         label="N6"
   ), 
   "Nborder11Jan"= list(
      "date"= "2021-01-11",
      "color"= nationalcol,
      label="N7"
   ),
    "Nborder22Jan"= list(
      "date"= "2021-01-24",
      "color"= nationalcol,
      label="N8"
   ),
    "Nborder30Jan"= list(
      "date"= "2021-01-30",
      "color"= nationalcol,
      label="N9"
   ),
    "Nborder14Feb"= list(
      "date"= "2021-02-14",
      "color"= nationalcol,
      label="N10"
   ),
   "Nborder08March"= list(
      "date"= "2021-03-08",
      "color"= nationalcol,
      label="N11"
   ),
   "NPoland21March"= list(
      "date"= "2021-03-21",
      "color"= nationalcol,
      label="N12"
   ),
   "NFrance31March"= list(
      "date"= "2021-03-30",
      "color"= nationalcol,
      label="N13"
   )
)
# clusterStatsMCC$shift <- alpha + beta/clusterStatsMCC$seqs
   # clusterStatsMCC$tmrca_shifted <- clusterStatsMCC$tmrca - (clusterStatsMCC$shift/366)
   # clusterStatsMCC$tmrca_shifted_calendar <- as.Date(round_date(date_decimal(clusterStatsMCC$tmrca_shifted), unit = "day"))
   # clusterStatsMCC$detection_lag <- as.Date(round_date(date_decimal(clusterStatsMCC$oldest), unit = "day")) - clusterStatsMCC$tmrca_shifted_calendar
   
data <- clusterStatsMCC %>% mutate(lineage_seqs = seqs) %>% dplyr::select(cluster, lineage_seqs, tmrca_calendar, tmrca) %>%
   rbind(clusterSamplesMCC %>% filter(lineage_seqs == 1) %>% mutate(tmrca_calendar=sample_date, tmrca=decimal_date) %>% 
            dplyr::select(cluster, lineage_seqs, tmrca_calendar, tmrca)) %>%
   calculateLineageSizeOrder() %>% 
   mutate(shift = alpha + beta/lineage_seqs, tmrca_shifted=tmrca - (shift/366), tmrca_shifted_calendar = as.Date(round_date(date_decimal(tmrca_shifted), unit = "day")))

clusterBySizeByTMRCA <-
   data %>%
   mutate(tmrca.break.index = sapply(tmrca_calendar, function(x) which.max(x < tmrcaBreaks) - 1)) %>%
   group_by(lineage_size_order, tmrca.break.index) %>%
   dplyr::summarise(n = n()) %>%
   mutate(p =  round(n / sum(n) * 100, digits = 1)) %>% arrange(desc(n))

plot_weekly_table(clusterBySizeByTMRCA, "lineage_size_order", firstCaseDistancesizePal, paste("TMRCA frequency ", "(+ singleton)"), "C", "No. lineages", ordering_=c("huge", "big", "med", "small", "single"), marks_ = marks_, ymax = ymax)


clusterBySizeByShiftedTMRCA <-
   data %>%
   mutate(tmrca.break.index = sapply(tmrca_shifted_calendar, function(x) which.max(x < tmrcaBreaks) - 1)) %>%
   group_by(lineage_size_order, tmrca.break.index) %>%
   dplyr::summarise(n = n()) %>%
   mutate(p =  round(n / sum(n) * 100, digits = 1)) %>% arrange(desc(n))

    # # Mark lockdown    
    # points(x=travelDates$lockdown, y=0.1*ymax, pch=175, font=5, cex=1.5, xpd=TRUE, col=mPal(ukPal$eng))
    # 
    # # Mark self-isolation advice
    # points(x=travelDates$china, y=0.1*ymax, pch=175, font=5, cex=1.5, xpd=TRUE, col=mPal(countryPal$China))
    # points(x=travelDates$italy, y=0.1*ymax, pch=175, font=5, cex=1.5, xpd=TRUE, col=mPal(countryPal$Italy))


plot_weekly_table(clusterBySizeByShiftedTMRCA, "lineage_size_order", firstCaseDistancesizePal, paste("Importation events tmrca_shifted", "(+ singleton)"), "C", "No. lineages", ordering_=c("huge", "big", "med", "small", "single"), marks_ = marks_, ymax = ymax)

print(kable(data %>% arrange(tmrca_calendar) %>% dplyr::select(-tmrca, -shift, -tmrca_shifted), caption = "clusters+single sorted by tmrca"))

print(kable(data %>% arrange(tmrca_shifted_calendar) %>% dplyr::select(-tmrca, -shift, -tmrca_shifted), caption = "clusters+single sorted by importation"))

# for (lin in c("B.1.1.7", "B.1.177")) {
#    clusterBySizeByShiftedTMRCALin <-
#       data %>%
#       mutate(pangolin = gsub("_.*", "", cluster)) %>%
#       mutate(tmrca.break.index = sapply(tmrca_shifted_calendar, function(x) which.max(x < tmrcaBreaks) - 1)) %>%
#       filter(pangolin == lin) %>%
#       group_by(lineage_size_order, tmrca.break.index) %>%
#       dplyr::summarise(n = n()) %>%
#       mutate(p =  round(n / sum(n) * 100, digits = 1)) %>% arrange(desc(n))
# 
#    
#    plot_weekly_table(clusterBySizeByShiftedTMRCALin, "lineage_size_order", firstCaseDistancesizePal, paste("Importation events", "(+ singleton),", lin), "C", "A", ordering_=c("huge", "big", "med", "small", "single"), marks_ = marks_)
#    
# }

```
```{r importation-comparison-sizes-weekly-with-singles-statistical-test, fig.width=7, fig.height=3, eval=TRUE}

# dist.diff.dist <- function(data, dvar, startDate, endDate) {
# data.filtered <- data %>% filter(.data[[dvar]] >= startDate, .data[[dvar]] <= endDate)
#    
# data.filtered.dist <- data.filtered %>% group_by(.data[[dvar]]) %>% 
#    dplyr::summarize(n=n()) %>% dplyr::rename("date"=.data[[dvar]]) %>%
#    right_join(seq(startDate, endDate, by="day") %>% data.frame() %>% setNames("date")) %>% mutate(n=ifelse(is.na(n), 0, n)) %>% arrange(date)
   # 
# convolve.exact <- function(a, b) {
#     # la <- length(a)
#     # a <- c(rep(0, length(b)), a, rep(0, length(b)))
#     # r <- c()
#     # for (shift in seq(length(b)+la)) {
#     #     # print(c(rep(0, shift), b, rep(0, length(a)-length(b)-shift)) * a)
#     #     r <- c(r, sum(c(rep(0, shift), rev(b), rep(0, length(a)-length(b)-shift)) * a))
#     # }
#     r <- rep(0, length(a) + length(b)-1)
#     for (i in seq(length(a))) {
#         for (j in seq(length(b))) {
#             r[i+j-1] <- r[i+j-1] + a[i] * b[j]
#         }
#     }
#     return(r)
# }
# 
# dist <- data.filtered.dist %>% pull(n)
# cdist <- c(1)
# for (i in seq(7)) {
#     # cdist <- convolve(dist, cdist, type="open") %>% round() %>% .[.!=0]
#     cdist <- convolve.exact(dist, cdist) %>% .[.!=0]
# }
# 
# dist.diff <- rep(0, length(cdist))
#    for (i in seq(length(cdist))) {
#       for (j in seq(length(cdist))) {
#          if (i >= j) {
#              dist.diff[i-j+1] <- dist.diff[i-j+1] + cdist[i] * cdist[j]
#          }
#       }
#    }
#    return(dist.diff)
# }
# 

startDate <- as.Date("2020-05-01")
endDate <- as.Date("2021-04-26")

# dist.diff.p.value <- function(dist.diff, d) {
#    print(paste("dist.diff.p.value", d))
#     if (d == 0) return(1);
#     d = abs(d)
#     sum.all <- sum(dist.diff) * 2 - dist.diff[1]
#     sum.to.end <- rev(cumsum(rev(dist.diff)))
#     sum.to.end[0] = sum.all
#     return(sum.to.end[d+1] / sum.all)
# }
# 
# date.diff.p.value <- function(data, dvar, dist.diff, date) {
#    before <- data %>% filter(.data[[dvar]] >= date-7, .data[[dvar]] < date) %>% nrow()
#    after <- data %>% filter(.data[[dvar]] >= date, .data[[dvar]] < date+7) %>% nrow()
#    return(dist.diff.p.value(dist.diff, after-before))
# }

data <- clusterStatsMCC %>% mutate(lineage_seqs = seqs) %>% dplyr::select(cluster, lineage_seqs, tmrca_calendar, tmrca) %>%
   rbind(clusterSamplesMCC %>% filter(lineage_seqs == 1) %>% mutate(tmrca_calendar=sample_date, tmrca=decimal_date) %>% dplyr::select(cluster, lineage_seqs, tmrca_calendar, tmrca)) %>%
   calculateLineageSizeOrder() %>% 
   mutate(shift = alpha + beta/lineage_seqs, tmrca_shifted=tmrca - (shift/366), tmrca_shifted_calendar = as.Date(round_date(date_decimal(tmrca_shifted), unit = "day")))

for (dvar in c('tmrca_shifted_calendar', 'tmrca_calendar')) {
   data.filtered <- data %>% filter(.data[[dvar]] >= startDate, .data[[dvar]] <= endDate)
   data.filtered.dist <- data.filtered %>% group_by(.data[[dvar]]) %>%
      dplyr::summarize(n=n()) %>% dplyr::rename("date"=.data[[dvar]]) %>%
      right_join(seq(startDate, endDate, by="day") %>% data.frame() %>% setNames("date")) %>% mutate(n=ifelse(is.na(n), 0, n)) %>% arrange(date) %>% 
      mutate(n.cumsum = cumsum(n))
   
   data.filtered.dist$n.seven <- c(data.filtered.dist$n.cumsum - c(rep(0,7), data.filtered.dist$n.cumsum[1:(length(data.filtered.dist$n.cumsum)-7)]), rep(0,6)) %>% tail(-6)
   # data.filtered.dist$n.seven.diff <- (c(data.filtered.dist$n.seven, rep(0, 7)) - c(rep(NA, 7), data.filtered.dist$n.seven)) %>% head(-7)
   data.filtered.dist <- data.filtered.dist %>% tail(-7)
   print(kable(data.filtered.dist))
   # col <- sapply(data.filtered.dist$n.seven.diff %>% head(-1), function(x) ifelse(x >= 0, "#87CEFA", "#FA8072"))
   col <- "#87CEFA"
      
   ymax <- max(data.filtered.dist$n.seven) * 1.1
   dateFreqDistribution(data.filtered.dist$n.seven %>% head(-1) %>% abs(),
      data.filtered.dist$date,
      plot.ci = FALSE,
      barplot = TRUE,
      label = "",
      ylab = paste("Number of imported lineages in next seven days"), 
      startDate = data.filtered.dist$date[1],
      endDate = data.filtered.dist$date[length(data.filtered.dist$date)-1],
      col = mPal(col, 0.75),
      border = mPal(col),
      ymax = ymax
   )
   
   legend(
      "top",
      horiz = FALSE,
      inset = c(0, -0.0),
      bty = 'n',
      xpd = TRUE,
      ncol = 6,
      fill = c(col),
      border = c(col),
      legend = c("importation"),
      title = paste("Sequences of lineage", dvar),
      cex = 0.8
   )

   plot.window(c(data.filtered.dist$date[1], data.filtered.dist$date[length(data.filtered.dist$date)-1]), c(0, ymax), xaxs="i")
   for (m in marks_) {
      arrows(as.Date(m$date), 0.7*ymax, as.Date(m$date), 0*ymax, col=m$color, lwd=1, angle=10, length=0.1)
   }

}


# legend(
#    "top",
#    horiz = FALSE,
#    inset = c(0, -0.33),
#    bty = 'n',
#    xpd = TRUE,
#    ncol = 6,
#    fill = mPal(unlist(pangolineagePal, 0.75)),
#    border = mPal(unlist(pangolineagePal)),
#    legend = pangolineages,
#    title = paste("Sequences of lineage"),
#    cex = 0.8
# )
   
# # dist <- (c(cumsum(data.filtered.dist$n), rep(0, 6)) - c(rep(0, 6), cumsum(data.filtered.dist$n))) %>% .[. > 0] %>% tail(-6)
# 
# dist.diff <- rep(0, max(dist)+1)
# # for (i in dist) {
# #    # print(i)
# #    for (j in dist) {
# #       if (i >= j) {
# #          dist.diff[i-j+1] = dist.diff[i-j+1] + 1
# #       }
# #    }
# # }
# 
# for (ii in seq(length(dist)-7)) {
#    i = dist[ii]
#    j = dist[ii+7]
#    # print(i)
#    # for (j in dist) {
#       if (i >= j) {
#          dist.diff[i-j+1] = dist.diff[i-j+1] + 1
#       }
#    # }
# }
# 
# date.diff.p.value(data, dvar, dist.diff, as.Date("2020-12-16"))
# 
# # dist.diff = list(
# #    "tmrca_calendar" = dist.diff.dist(data, 'tmrca_calendar', as.Date("2021-01-01"), as.Date("2022-01-01")),
# #    "tmrca_shifted_calendar" = dist.diff.dist(data, 'tmrca_shifted_calendar', as.Date("2021-01-01"), as.Date("2022-01-01"))
# # )
# 
# # date.diff.p.value(data, dist.diff[["tmrca_shifted_calendar"]], as.Date("2021-02-14"))
# 
# # plot(sapply(seq(0,100), function(x) dist.diff.p.value(dist.diff, x)))

```

```{r Bavaria-lineages}


data <- clusterStatsMCC %>% mutate(lineage_seqs = seqs) %>% dplyr::select(cluster, lineage_seqs, tmrca_calendar, tmrca) %>%
   rbind(clusterSamplesMCC %>% filter(lineage_seqs == 1) %>% mutate(tmrca_calendar=sample_date, tmrca=decimal_date) %>% dplyr::select(cluster, lineage_seqs, tmrca_calendar, tmrca)) %>%
   calculateLineageSizeOrder() %>% 
   mutate(shift = alpha + beta/lineage_seqs, tmrca_shifted=tmrca - (shift/366), tmrca_shifted_calendar = as.Date(round_date(date_decimal(tmrca_shifted), unit = "day"))) %>%
  left_join(clusterFirstCasesWithSingles %>% 
    group_by(cluster, adm1) %>% dplyr::summarise(weight = n()/first(cluster.first.case.count) ))

tmrcaBreaks <- seq.Date(min(data$tmrca_shifted_calendar) - 8, max(data$tmrca_shifted_calendar) + 8, by="week")

data2 <- data %>% 
  mutate(tmrca.break.index = sapply(tmrca_shifted_calendar, function(x) which.max(x < tmrcaBreaks) - 1)) %>%
  mutate(tmrca.break.value = tmrcaBreaks[tmrca.break.index]) %>%
  left_join(clusterSamplesMCC %>% filter(!(adm1 %in% c("North Rhine-Westphalia", "Bavaria", "Baden-Wurttemberg"))) %>% group_by(cluster) %>% dplyr::summarise(seq_in_13_states = n())) %>%
  mutate(seq_in_13_states = ifelse(is.na(seq_in_13_states), 0, seq_in_13_states))

for (state in c("North Rhine-Westphalia", "Bavaria", "Baden-Wurttemberg")) {
  p <- data2 %>%
    filter(adm1 == state) %>%
    group_by(tmrca.break.index, tmrca.break.value) %>% dplyr::summarise(seqs = sum(seq_in_13_states * weight)) %>%
    ggplot(aes(x = tmrca.break.value, y = seqs, fill=state)) +
      geom_bar(stat = "identity", position = "dodge") +
      scale_fill_manual(values = sdePal[[state]]) +
      xlim(tmrcaBreaks[1], tmrcaBreaks[length(tmrcaBreaks)])
  print(p)  
}

for (state in c("North Rhine-Westphalia", "Bavaria", "Baden-Wurttemberg")) {
  print(kable(
    data2 %>% filter(adm1 == state) %>% dplyr::select(-tmrca, -tmrca_calendar, -tmrca_shifted, -lineage_size_order, -tmrca.break.index, -tmrca.break.value), caption = paste("Sequences entered to states from", state)
  ))
}

```


```{r effectiveness of NPIs: importation-state-specific-10-day, fig.width=7, fig.height=4, eval=TRUE}

   # layout(matrix(1:2, nrow = 2, byrow = TRUE))
   #par(mar = c(4, 6, 5, 6), cex.axis = 0.7, cex.lab = 0.8, cex.main = 1.5, mgp = c(3, 0.75, 0))
   
   s <- 1
   state <- stateFiles$state[s]
   clusterStatsMCC <- stateInfo$clusterStatsMCC[[s]]
   clusterSamplesMCC <- stateInfo$clusterSamplesMCC[[s]]
   
   clusterStatsMCC$oldest_calendar <-as.Date(round_date(date_decimal(clusterStatsMCC$oldest), unit = "day"))
   clusterSamplesMCC$oldest_calendar <- as.Date(round_date(date_decimal(clusterSamplesMCC$lineage_oldest), unit = "day"))
   clusterStatsMCC$pangolin <- gsub("_.*", "", clusterStatsMCC$cluster)
   pangolineages <- levels(as.factor(clusterStatsMCC$pangolin))
   clusterSamplesMCC$pangolin <- sapply(clusterSamplesMCC$Pango.lineage, function(x)
         pangolineages[x == pangolineages |
                          startsWith(x, paste0(pangolineages, "."))])
   
   clusterSamplesMCC <- clusterSamplesMCC %>% mutate(sample_date = ymd(sample_date)) %>% mutate(oldest_calendar = if_else(is.na(oldest_calendar), sample_date, oldest_calendar)) 
   
   clusterSamplesMCC <-
      clusterSamplesMCC %>% left_join(clusterStatsMCC %>% dplyr::select(cluster, tmrca_calendar, tmrca_shifted_calendar), by=c("cluster"="cluster")) %>%
      mutate(tmrca_calendar = if_else(is.na(tmrca_calendar), oldest_calendar, tmrca_calendar),
             tmrca_shifted_calendar = if_else(is.na(tmrca_shifted_calendar), tmrca_calendar - (alpha + beta)/366, tmrca_shifted_calendar))
             # tmrca_shifted_calendar = if_else(is.na(tmrca_shifted_calendar), oldest_calendar, tmrca_shifted_calendar))




pal <- sdePal
pal[['Germany']] = sdePal$`Baden-Wurttemberg`


nationalcol = "#980043"
localcol = "#c994c7"


marksForStates_ <- list(
   "Bavaria" = list(
      "food2Oct"= list(
         "date"= "2020-10-02",
         "color"= localcol,
         label="A"
      ), 
      "nights23Oct"= list(
         "date"= "2020-10-23",
         "color"= localcol,
         label="B"
      ), 
      "home09Dec"= list(
         "date"= "2020-12-09",
         "color"= localcol,
         label="C"
      ), 
        "Ncoldsymp19Oct"= list(
         "date"= "2020-10-19",
         "color"= nationalcol,
         label="N1"
   ),
   "Nopera02Nov"= list(
         "date"= "2020-11-02",
         "color"= nationalcol,
         label="N2"
   ),
   "Nopera08Nov"= list(
         "date"= "2020-11-08",
         "color"= nationalcol,
         label="N3"
   ),
    "Nopera30Nov"= list(
         "date"= "2020-11-30",
         "color"= nationalcol,
         label="N4"
   ),
   "Nlockdown16Dec"= list(
      "date"= "2020-12-16",
      "color"= nationalcol,
         label="N5"
   ), 
   "Nlockdown16Dec"= list(
      "date"= "2020-12-22",
      "color"= nationalcol,
         label="N6"
   ), 
   "Nborder11Jan"= list(
      "date"= "2021-01-11",
      "color"= nationalcol,
      label="N7"
   ),
    "Nborder22Jan"= list(
      "date"= "2021-01-24",
      "color"= nationalcol,
      label="N8"
   ),
    "Nborder30Jan"= list(
      "date"= "2021-01-30",
      "color"= nationalcol,
      label="N9"
   ),
    "Nborder14Feb"= list(
      "date"= "2021-02-14",
      "color"= nationalcol,
      label="N10"
   ),
   "Nborder08March"= list(
      "date"= "2021-03-08",
      "color"= nationalcol,
      label="N11"
   ),
   "NPoland21March"= list(
      "date"= "2021-03-21",
      "color"= nationalcol,
      label="N12"
   ),
   "NFrance31March"= list(
      "date"= "2021-03-30",
      "color"= nationalcol,
      label="N13"
   )
),
   
   "Baden-Wurttemberg"= list(
      "mask19ct"= list(
         "date"= "2020-10-02",
         "color"= localcol,
         label="A"
      ), 
   "Ncoldsymp19Oct"= list(
         "date"= "2020-10-19",
         "color"= nationalcol,
         label="N1"
   ),
   "Nopera02Nov"= list(
         "date"= "2020-11-02",
         "color"= nationalcol,
         label="N2"
   ),
   "Nopera08Nov"= list(
         "date"= "2020-11-08",
         "color"= nationalcol,
         label="N3"
   ),
    "Nopera30Nov"= list(
         "date"= "2020-11-30",
         "color"= nationalcol,
         label="N4"
   ),
   "Nlockdown16Dec"= list(
      "date"= "2020-12-16",
      "color"= nationalcol,
         label="N5"
   ), 
   "Nlockdown16Dec"= list(
      "date"= "2020-12-22",
      "color"= nationalcol,
         label="N6"
   ), 
   "Nborder11Jan"= list(
      "date"= "2021-01-11",
      "color"= nationalcol,
      label="N7"
   ),
    "Nborder22Jan"= list(
      "date"= "2021-01-24",
      "color"= nationalcol,
      label="N8"
   ),
    "Nborder30Jan"= list(
      "date"= "2021-01-30",
      "color"= nationalcol,
      label="N9"
   ),
    "Nborder14Feb"= list(
      "date"= "2021-02-14",
      "color"= nationalcol,
      label="N10"
   ),
   "Nborder08March"= list(
      "date"= "2021-03-08",
      "color"= nationalcol,
      label="N11"
   ),
   "NPoland21March"= list(
      "date"= "2021-03-21",
      "color"= nationalcol,
      label="N12"
   ),
   "NFrance31March"= list(
      "date"= "2021-03-30",
      "color"= nationalcol,
      label="N13"
   )
   ),
   
   "North Rhine-Westphalia" = list(
 
    "Ncoldsymp19Oct"= list(
         "date"= "2020-10-19",
         "color"= nationalcol,
         label="N1"
   ),
   "Nopera02Nov"= list(
         "date"= "2020-11-02",
         "color"= nationalcol,
         label="N2"
   ),
   "Nopera08Nov"= list(
         "date"= "2020-11-08",
         "color"= nationalcol,
         label="N3"
   ),
    "Nopera30Nov"= list(
         "date"= "2020-11-30",
         "color"= nationalcol,
         label="N4"
   ),
   "Nlockdown16Dec"= list(
      "date"= "2020-12-16",
      "color"= nationalcol,
         label="N5"
   ), 
   "Nlockdown16Dec"= list(
      "date"= "2020-12-22",
      "color"= nationalcol,
         label="N6"
   ), 
   "Nborder11Jan"= list(
      "date"= "2021-01-11",
      "color"= nationalcol,
      label="N7"
   ),
    "Nborder22Jan"= list(
      "date"= "2021-01-24",
      "color"= nationalcol,
      label="N8"
   ),
    "Nborder30Jan"= list(
      "date"= "2021-01-30",
      "color"= nationalcol,
      label="N9"
   ),
    "Nborder14Feb"= list(
      "date"= "2021-02-14",
      "color"= nationalcol,
      label="N10"
   ),
   "Nborder08March"= list(
      "date"= "2021-03-08",
      "color"= nationalcol,
      label="N11"
   ),
   "NPoland21March"= list(
      "date"= "2021-03-21",
      "color"= nationalcol,
      label="N12"
   ),
   "NFrance31March"= list(
      "date"= "2021-03-30",
      "color"= nationalcol,
      label="N13"
   )
   ),
   
   "Saxony" = list(
      
   "Ncoldsymp19Oct"= list(
         "date"= "2020-10-19",
         "color"= nationalcol,
         label="N1"
   ),
   "Nopera02Nov"= list(
         "date"= "2020-11-02",
         "color"= nationalcol,
         label="N2"
   ),
   "Nopera08Nov"= list(
         "date"= "2020-11-08",
         "color"= nationalcol,
         label="N3"
   ),
    "Nopera30Nov"= list(
         "date"= "2020-11-30",
         "color"= nationalcol,
         label="N4"
   ),
   "Nlockdown16Dec"= list(
      "date"= "2020-12-16",
      "color"= nationalcol,
         label="N5"
   ), 
   "Nlockdown16Dec"= list(
      "date"= "2020-12-22",
      "color"= nationalcol,
         label="N6"
   ), 
   "Nborder11Jan"= list(
      "date"= "2021-01-11",
      "color"= nationalcol,
      label="N7"
   ),
    "Nborder22Jan"= list(
      "date"= "2021-01-24",
      "color"= nationalcol,
      label="N8"
   ),
    "Nborder30Jan"= list(
      "date"= "2021-01-30",
      "color"= nationalcol,
      label="N9"
   ),
    "Nborder14Feb"= list(
      "date"= "2021-02-14",
      "color"= nationalcol,
      label="N10"
   ),
   "Nborder08March"= list(
      "date"= "2021-03-08",
      "color"= nationalcol,
      label="N11"
   ),
   "NPoland21March"= list(
      "date"= "2021-03-21",
      "color"= nationalcol,
      label="N12"
   ),
   "NFrance31March"= list(
      "date"= "2021-03-30",
      "color"= nationalcol,
      label="N13"
   )
   )
)





sumtriangle <- function(data, template = c(seq(7), seq(6,1))) {
   # print(data)
   x <- convolve(data, template, type="open")
   return(x %>% tail(-(length(template)-1)) %>% round(digits = 1))
}

shift <- function(data, amount) {
   if (amount > 0) {
      return(c(rep(NA, amount), data) %>% head(-amount))
   } else {
      return(c(data, rep(NA, amount)) %>% tail(-amount))
   }
}

smoothDiffMeasure <- function(column, w=7) {
   sapply(seq(length(column)), function(i) max(column[max(0,i-w+1):i]) - min(column[min(length(column),i+w-1):i])  ) 
}

smoothDiffMeasureNext <- function(column, w=7) {
   sapply(seq(length(column)), function(i) min(column[min(length(column),i+w-1):i])  ) 
}
smoothDiffMeasurePrev <- function(column, w=7) {
   sapply(seq(length(column)), function(i) max(column[max(0,i-w+1):i])  ) 
}


startDate <- as.Date("2020-09-25")
endDate <- as.Date("2021-05-04")

# tmrcaBreaksWidths <- data.frame(len = c(7, 1), width = c("1 day", "week"))
# 
# for (tmrcaBreaksWidthIndex in seq(2)) {
#    tmrcaBreaksLength <- tmrcaBreaksWidths$len[tmrcaBreaksWidthIndex]
#    tmrcaBreaksWidth  <- tmrcaBreaksWidths$width[tmrcaBreaksWidthIndex]
#       
   # for (dvar in c('tmrca_shifted_calendar', 'tmrca_calendar')) {
   for (dvar in c('tmrca_shifted_calendar')) {
   
      # tmrcaBreaks <- seq.Date(as.Date("2019-01-01"), as.Date("2021-06-20"), by="7 days")
      # tmrcaBreaks <-
      #    seq.Date(
      #       min(clusterStatsMCC$oldest_calendar),
      #       max(clusterStatsMCC$oldest_calendar) + 7,
      #       by = "7 days"
      #    )
       tmrcaBreaks <- seq.Date(startDate, endDate, by="1 day")
      
         clusterFirstCases <-
            clusterSamplesMCC %>% filter(
               lineage_seqs > 1 &
                  abs(.data[["oldest_calendar"]] - sample_date) < 1 / 366 + firstCaseDistance / 366 
            )
         clusterFirstCasesCount <-
            clusterFirstCases %>% group_by(cluster) %>% dplyr::summarise(cluster.first.case.count = n())
         clusterFirstCases <-
            clusterFirstCases %>% left_join(clusterFirstCasesCount, by = c("cluster" = "cluster"))
         clusterFirstCaseByCounty <-
            clusterFirstCases %>% 
            # mutate(adm1 = ifelse(is.na(adm1) | adm1 == "NA", "Saxony", adm1)) %>%
            mutate(tmrca.break.index = sapply(.[[dvar]], function(x) which.max(x < tmrcaBreaks) - 1)) %>%
            group_by(adm1, tmrca.break.index) %>%
            dplyr::summarise(n = sum(1 / cluster.first.case.count)) %>%
            mutate(p =  round(n / sum(n) * 100, digits = 1)) 
         #%>% arrange(desc(n)) %>% filter(adm1 == "Saxony" | adm1 == "Bavaria")
   
         # plot_weekly_table(clusterFirstCaseByCounty, "adm1", dePal, paste("Transmission lineage of states", "(no singleton)"), "C", "importation", 
         #                   legend_ = function(x) ifelse(nchar(x) > 10, substr(x, 1, 10), x))
         # 
   
         clusterFirstCasesWithSingles <-
            clusterSamplesMCC %>% filter(
                  abs(.data[["oldest_calendar"]] - sample_date) < 1 / 366 + firstCaseDistance / 366
            )
         clusterFirstCasesCount <-
            clusterFirstCasesWithSingles %>% group_by(cluster) %>% dplyr::summarise(cluster.first.case.count = n())
         clusterFirstCasesWithSingles <-
            clusterFirstCasesWithSingles %>% left_join(clusterFirstCasesCount, by = c("cluster" = "cluster"))
         clusterFirstCaseByCountyWithSingles <-
            clusterFirstCasesWithSingles %>%
            mutate(tmrca.break.index = sapply(.[[dvar]], function(x) which.max(x < tmrcaBreaks) - 1)) %>%
            group_by(adm1, tmrca.break.index) %>%
            dplyr::summarise(n = sum(1 / cluster.first.case.count))
            # mutate(p =  round(n / sum(n) * 100, digits = 1)) %>% arrange(desc(n)) %>%
   
         # plot_weekly_table(clusterFirstCaseByCountyWithSingles, "adm1", dePal, paste("Transmission lineage of states", "(+single)"), "C", "importation",
         #                   legend_ = function(x) ifelse(nchar(x) > 10, substr(x, 1, 10), x))
      
      smoothedCharts <- function(adm1_s, adm1_name, col, marks__) {
         data <- clusterFirstCaseByCountyWithSingles %>% filter(adm1 %in% adm1_s) %>% 
          group_by(tmrca.break.index) %>% dplyr::summarise(n = sum(n)) %>%
            mutate(adm1 = adm1_name) %>%
            full_join(tmrcaBreakIndicesDF(tmrcaBreaks), by=c("tmrca.break.index"="tmrca.break.index")) %>% 
            mutate(adm1=ifelse(is.na(adm1), adm1_name, adm1), n=ifelse(is.na(n), 0, n)) %>% arrange(tmrca.break.index) %>%
            # mutate(n=rollsum(n, tmrcaBreaksLength, align='left', fill=0))
            filter(tmrca.break.index > 0) %>%
            mutate(date = tmrcaBreaks[tmrca.break.index]) %>%
            mutate(n = sumtriangle(n, template=c(seq(1,10),seq(9,1)))) %>%
            mutate(n.shift = shift(n, 1), n.diff = n - n.shift) %>%
            mutate(smdiff = smoothDiffMeasure(n.diff), smdiff.pref = smoothDiffMeasurePrev(n.diff), smdiff.next = smoothDiffMeasureNext(n.diff))
          plot_weekly_table(data, "adm1", pal, 
                         # paste("Imp conv to triangle (10 d)", "(+sing)", adm1_name, dvar), 
                         "", 
                         "", paste("Smoothed importation frequency of", adm1_name),
                         legend_ = function(x) ifelse(nchar(x) > 10, substr(x, 1, 10), x), printTable_ = FALSE, marks_ = marks__ )

         ymax2 = max(data$n.diff, na.rm = TRUE) * 1.1
         ymin2 = min(min(data$n.diff, na.rm = TRUE) * 1.1, 0)
         marks__extended <- do.call(rbind.data.frame, marks__) %>% mutate(date = as.Date(date)) %>% left_join(data, by=c("date" = "date"))
         p <- ggplot() + 
            geom_line(data = data, aes(x=date, y=n.diff), color=col) + 
            geom_point(data = data, aes(x=date, y=n.diff), color=col) + 
            #labs(title=paste("Imp  derivation of conv to triangle (10 d)", "(+s)", adm1_name, dvar))+
            # labs(title=paste("triangle 10d +s",  adm1_name, dvar))+
            scale_x_date(date_breaks = "2 week", date_labels =  "%d %b") + 
            theme_bw() + 
            theme(legend.position="top", axis.text.x=element_text(angle=90, hjust=1)) + geom_hline(yintercept = 0, color = "black") +
            geom_segment(data=marks__extended, aes(x=date, y=smdiff.pref, xend=date, yend=smdiff.next), color=marks__extended$color, linetype=1) +
            geom_segment(data=marks__extended, aes(x=date-1, y=smdiff.pref, xend=date+1, yend=smdiff.pref), color=marks__extended$color, linetype=1) +
            geom_segment(data=marks__extended, aes(x=date-1, y=smdiff.next, xend=date+1, yend=smdiff.next), color=marks__extended$color, linetype=1) +
            geom_segment(data=marks__extended, aes(x=date-6, y=smdiff.pref, xend=date+0, yend=smdiff.pref), color=marks__extended$color, linetype=3) +
            geom_segment(data=marks__extended, aes(x=date-0, y=smdiff.next, xend=date+6, yend=smdiff.next), color=marks__extended$color, linetype=3) +
            # geom_text_repel(data=marks__extended, aes(label=label, x=date, y=smdiff.pref), color=marks__extended$color, nudge_y = 0.01 * ymax, vjust = 0, direction = "x", segment.curvature = -0.1, segment.linetype = 6, force = 0) +
            geom_text(data=marks__extended, aes(label=label, x=date, y=smdiff.pref), color=marks__extended$color, vjust = 0, nudge_y = 0.01 * ymax) +
            ylab(paste("Change rate of\n  smoothed importation frequency", adm1_name)) + 
            theme(axis.title.x = element_blank())

         print(p)
         
         
         print(kable(
            do.call(bind_rows, marks__) %>% 
               mutate(date.index = sapply(date, function(x) which.max(x < tmrcaBreaks) - 1), date.old.index = sapply(as.Date(date)-days(7), function(x) which.max(x < tmrcaBreaks) - 1)) %>% 
               left_join(data %>% dplyr::rename(date.value = n), by=c("date.index"="tmrca.break.index")) %>% 
               left_join(data %>% dplyr::rename(date.old.value = n), by=c("date.old.index"="tmrca.break.index")) %>% 
               dplyr::select(-date.index, -date.old.index, -color) %>% 
               mutate(fold.change= -(date.old.value-date.value)/date.old.value) %>% dplyr::select(label, smdiff.x), 
            caption=paste("Change in critical points", adm1_name)))
      }
      
      adm1List <- levels(factor((clusterFirstCaseByCounty %>% dplyr::select(adm1))$adm1))
      adm1List <- c("Bavaria", "North Rhine-Westphalia", "Baden-Wurttemberg", "Saxony", "Berlin")
      for (adm1_ in adm1List) {
         
         
        # # plot_weekly_table(clusterFirstCaseByCounty %>% filter(adm1 == adm1_), "adm1", dePal, 
        #  #                  paste("Transmission lineage of states", "(no singleton)", adm1_), "C", "importation", 
        #   #                 legend_ = function(x) ifelse(nchar(x) > 10, substr(x, 1, 10), x))
        #  data <- clusterFirstCaseByCountyWithSingles %>% filter(adm1 == adm1_) %>% 
        #     full_join(tmrcaBreakIndicesDF(tmrcaBreaks), by=c("tmrca.break.index"="tmrca.break.index")) %>% 
        #     mutate(adm1=ifelse(is.na(adm1), adm1_, adm1), n=ifelse(is.na(n), 0, n)) %>% arrange(tmrca.break.index) %>%
        #     # mutate(n=rollsum(n, tmrcaBreaksLength, align='left', fill=0))
        #     filter(tmrca.break.index > 0) %>%
        #     mutate(date = tmrcaBreaks[tmrca.break.index]) %>%
        #     mutate(n = sumtriangle(n, template=c(seq(1,10),seq(9,1)))) %>%
        #     mutate(n.shift = shift(n, 1), n.diff = n - n.shift) %>%
        #     mutate(smdiff = smoothDiffMeasure(n.diff), smdiff.pref = smoothDiffMeasurePrev(n.diff), smdiff.next = smoothDiffMeasureNext(n.diff))
        #  
         marks__ = marks_
         if (adm1_ %in% names(marksForStates_)) {
            marks__ = marksForStates_[[adm1_]];
         }
        # 
        #  # box__extended <- data.frame(st=c(), ed=c(), color=c())
        #  # if (adm1_ %in% names(boxForStates_)) {
        #  #    box__ = boxForStates_[[adm1_]];
        #  #    box__extended <- do.call(rbind.data.frame, box__) %>% mutate(st = as.Date(st), ed = as.Date(ed))
        #  # }
        # 
        #  plot_weekly_table(data, "adm1", pal, 
        #                    paste("Importation events convolved to triangle (10 days)", "(+single)", adm1_, dvar), "", "Frequency of importations",
        #                    legend_ = function(x) ifelse(nchar(x) > 10, substr(x, 1, 10), x), printTable_ = FALSE, marks_ = marks__ )
        #  # plot_weekly_table(data %>% mutate(n = n.diff), "adm1", pal, 
        #  #                   paste("Importation events convolved to triangle, 7 day diff", "(+single)", adm1_, dvar), "", "Frequency of importations",
        #  #                   legend_ = function(x) ifelse(nchar(x) > 10, substr(x, 1, 10), x), printTable_ = FALSE, marks_ = marks__ )
        #  
        #  ymax2 = max(data$n.diff, na.rm = TRUE) * 1.1
        #  ymin2 = min(min(data$n.diff, na.rm = TRUE) * 1.1, 0)
        #  marks__extended <- do.call(rbind.data.frame, marks__) %>% mutate(date = as.Date(date)) %>% left_join(data, by=c("date" = "date"))
        #  p <- ggplot() + 
        #     # geom_rect(data=box__extended, aes(xmin=st, ymin=ymin2, xmax=ed, ymax=ymax2, fill=color)) +
        #     geom_line(data = data, aes(x=date, y=n.diff), color=pal[[adm1_]]) + 
        #     geom_point(data = data, aes(x=date, y=n.diff), color=pal[[adm1_]]) + 
        #     labs(title=paste("Importation events: derivation of convolved to triangle (10 days)", "(+single)", adm1_, dvar))+
        #     scale_x_date(date_breaks = "1 week", date_labels =  "%d %b") + 
        #     theme(legend.position="top", axis.text.x=element_text(angle=90, hjust=1)) + geom_hline(yintercept = 0, color = "black") +
        #     geom_segment(data=marks__extended, aes(x=date, y=smdiff.pref, xend=date, yend=smdiff.next), color=marks__extended$color, linetype=1) +
        #     geom_segment(data=marks__extended, aes(x=date-1, y=smdiff.pref, xend=date+1, yend=smdiff.pref), color=marks__extended$color, linetype=1) +
        #     geom_segment(data=marks__extended, aes(x=date-1, y=smdiff.next, xend=date+1, yend=smdiff.next), color=marks__extended$color, linetype=1) +
        #     geom_segment(data=marks__extended, aes(x=date-6, y=smdiff.pref, xend=date+0, yend=smdiff.pref), color=marks__extended$color, linetype=3) +
        #     geom_segment(data=marks__extended, aes(x=date-0, y=smdiff.next, xend=date+6, yend=smdiff.next), color=marks__extended$color, linetype=3) +
        #     geom_text(data=marks__extended, aes(label=label, x=date, y=smdiff.pref), color=marks__extended$color, vjust = 0, nudge_y = 0.01 * ymax)
        # 
        #  print(p)
        #  
        #  
        #  print(kable(
        #     do.call(bind_rows, marks__) %>% 
        #        mutate(date.index = sapply(date, function(x) which.max(x < tmrcaBreaks) - 1), date.old.index = sapply(as.Date(date)-days(7), function(x) which.max(x < tmrcaBreaks) - 1)) %>% 
        #        left_join(data %>% dplyr::rename(date.value = n), by=c("date.index"="tmrca.break.index")) %>% 
        #        left_join(data %>% dplyr::rename(date.old.value = n), by=c("date.old.index"="tmrca.break.index")) %>% 
        #        dplyr::select(-date.index, -date.old.index, -color) %>% 
        #        mutate(fold.change= -(date.old.value-date.value)/date.old.value), 
        #     caption=paste("Change in critical points", adm1_)))
        #  # print(kable(clusterFirstCasesWithSingles %>% filter(adm1 == adm1_) %>% arrange(.[[dvar]]) %>% dplyr::select(cluster, dvar), caption = paste("clusters+single sorted by importation for", adm1_) ))
         smoothedCharts(adm1_, adm1_, pal[[adm1_]], marks__)
      }
      
      marks_test = marks_; #for (x in names(marks_test)) { marks_test[[x]]$color = "gray"; }
      smoothedCharts(c(levels(factor((clusterFirstCaseByCounty %>% dplyr::select(adm1))$adm1)), NA), state, pal[[state]], marks_)

      # adm1_ <- state
      # 
      # data1 <- clusterFirstCaseByCountyWithSingles %>%
      #    group_by(tmrca.break.index) %>% dplyr::summarise(n = sum(n)) %>%
      #    full_join(tmrcaBreakIndicesDF(tmrcaBreaks), by=c("tmrca.break.index"="tmrca.break.index")) %>%
      #    filter(tmrca.break.index > 0) %>%
      #    mutate(date = tmrcaBreaks[tmrca.break.index]) %>%
      #    mutate(n=ifelse(is.na(n), 0, n), state=state) %>% arrange(tmrca.break.index) %>%
      #    mutate(n = sumtriangle(n, template=c(seq(1,10),seq(9,1)))) %>%
      #    mutate(n.shift = shift(n, 1), n.diff = n - n.shift) %>%
      #    mutate(smdiff = smoothDiffMeasure(n.diff), smdiff.pref = smoothDiffMeasurePrev(n.diff), smdiff.next = smoothDiffMeasureNext(n.diff))
      # 
      # data2 <- clusterFirstCaseByCountyWithSingles %>% filter(adm1 %in% adm1_s) %>% 
      #    group_by(tmrca.break.index) %>% dplyr::summarise(n = sum(n)) %>%
      #       mutate(adm1 = adm1_name) %>%
      #       full_join(tmrcaBreakIndicesDF(tmrcaBreaks), by=c("tmrca.break.index"="tmrca.break.index")) %>% 
      #       mutate(adm1=ifelse(is.na(adm1), adm1_name, adm1), n=ifelse(is.na(n), 0, n)) %>% arrange(tmrca.break.index) %>%
      #       # mutate(n=rollsum(n, tmrcaBreaksLength, align='left', fill=0))
      #       filter(tmrca.break.index > 0) %>%
      #       mutate(date = tmrcaBreaks[tmrca.break.index]) %>%
      #       mutate(n = sumtriangle(n, template=c(seq(1,10),seq(9,1)))) %>%
      #       mutate(n.shift = shift(n, 1), n.diff = n - n.shift) %>%
      #       mutate(smdiff = smoothDiffMeasure(n.diff), smdiff.pref = smoothDiffMeasurePrev(n.diff), smdiff.next = smoothDiffMeasureNext(n.diff))

      # 
      # marks__ = marks_
      # if (state %in% names(marksForStates_)) {
      #    marks__ = marksForStates_[[state]];
      # }
      # 
      # # box__extended <- NULL
      # # if (adm1_ %in% names(boxForStates_)) {
      # #    box__extended <- do.call(rbind.data.frame, box__) %>% mutate(st = as.Date(st), ed = as.Date(ed))
      # # }
      # 
      # plot_weekly_table(data, "state", pal, 
      #                   paste("Importation events convolved to triangle (10 days)", "(+single)", state, dvar), "", "frequency of importations",
      #                   legend_ = function(x) ifelse(nchar(x) > 10, substr(x, 1, 10), x), printTable_ = FALSE, marks_ = marks__ )
      # # plot_weekly_table(data %>% mutate(n = n.diff), "state", pal, 
      # #                   paste("Importation events convolved to triangle (7 days), 7 day diff", "(+single)", state, dvar), "", "frequency of importations",
      # #                   legend_ = function(x) ifelse(nchar(x) > 10, substr(x, 1, 10), x), printTable_ = FALSE, marks_ = marks__ )
      # 
      # ymax2 = max(data$n.diff, na.rm = TRUE) * 1.1
      # ymin2 = min(min(data$n.diff, na.rm = TRUE) * 1.1, 0)
      # # p <- ggplot(data = data, aes(x=date, y=n.diff)) + geom_line(color=pal[[adm1_]]) + geom_point(color=pal[[adm1_]]) + 
      # #    labs(title=paste("Importation events convolved to triangle (10 days), 1 day diff", "(+single)", state, dvar))+
      # #    scale_x_date(date_breaks = "1 week", date_labels =  "%d %b") + 
      # #    theme(legend.position="top", axis.text.x=element_text(angle=90, hjust=1)) + 
      # #    geom_segment(data=do.call(rbind.data.frame, marks__), aes(x=as.Date(date), y=ymax2, xend=as.Date(date), yend=ymin2, color=color)) +
      # #    geom_text(data=do.call(rbind.data.frame, marks__), aes(label=label, x=as.Date(date), y=ymax2), vjust = 0, nudge_y = 0.5)
      # 
      # marks__extended <- do.call(rbind.data.frame, marks__) %>% mutate(date = as.Date(date)) %>% left_join(data, by=c("date" = "date"))
      # p <- ggplot() + 
      #    geom_line(data = data, aes(x=date, y=n.diff), color=pal[[adm1_]]) + 
      #    geom_point(data = data, aes(x=date, y=n.diff), color=pal[[adm1_]]) + 
      #    labs(title=paste("Importation events: derivation of convolved to triangle (10 days)", "(+single)", adm1_, dvar))+
      #    scale_x_date(date_breaks = "1 week", date_labels =  "%d %b") + 
      #    theme(legend.position="top", axis.text.x=element_text(angle=90, hjust=1)) + geom_hline(yintercept = 0, color = "black") +
      #    geom_segment(data=marks__extended, aes(x=date, y=smdiff.pref, xend=date, yend=smdiff.next), color=marks__extended$color, linetype=1) +
      #    geom_segment(data=marks__extended, aes(x=date-1, y=smdiff.pref, xend=date+1, yend=smdiff.pref), color=marks__extended$color, linetype=1) +
      #    geom_segment(data=marks__extended, aes(x=date-1, y=smdiff.next, xend=date+1, yend=smdiff.next), color=marks__extended$color, linetype=1) +
      #    geom_segment(data=marks__extended, aes(x=date-6, y=smdiff.pref, xend=date+0, yend=smdiff.pref), color=marks__extended$color, linetype=3) +
      #    geom_segment(data=marks__extended, aes(x=date-0, y=smdiff.next, xend=date+6, yend=smdiff.next), color=marks__extended$color, linetype=3) +
      #    geom_text(data=marks__extended, aes(label=label, x=date, y=smdiff.pref), color=marks__extended$color, vjust = 0, nudge_y = 0.01 * ymax)
      # print(p)
      # 
      # 
      # print(kable(
      #    do.call(rbind.data.frame, marks__) %>% 
      #       mutate(date.index = sapply(date, function(x) which.max(x < tmrcaBreaks) - 1), date.old.index = sapply(as.Date(date)-days(7), function(x) which.max(x < tmrcaBreaks) - 1)) %>% 
      #       left_join(data %>% dplyr::rename(date.value = n), by=c("date.index"="tmrca.break.index")) %>% 
      #       left_join(data %>% dplyr::rename(date.old.value = n), by=c("date.old.index"="tmrca.break.index")) %>% 
      #       dplyr::select(-date.index, -date.old.index, -color) %>% 
      #       mutate(fold.change= -(date.old.value-date.value)/date.old.value), 
      #    caption=paste("Change in critical points", adm1_)))
      # # print(kable(clusterFirstCasesWithSingles %>% filter(adm1 == adm1_) %>% arrange(.[[dvar]]) %>% dplyr::select(cluster, dvar), caption = paste("clusters+single sorted by importation for", adm1_) ))
      smoothedCharts(setdiff(c(levels(factor((clusterFirstCaseByCounty %>% dplyr::select(adm1))$adm1)), NA), c("Bavaria", "North Rhine-Westphalia", "Baden-Wurttemberg")), "other", pal[["Other"]], marks_test)

   }
         
# } 

```


```{r TEMP effectiveness of NPIs: importation-state-specific-10-day, fig.width=6, fig.height=4, eval=TRUE}
# 
#    # layout(matrix(1:2, nrow = 2, byrow = TRUE))
#    # par(mar = c(4, 6, 5, 6), cex.axis = 0.7, cex.lab = 0.8, cex.main = 1.5, mgp = c(3, 0.75, 0))
# 
#    s <- 1
#    state <- stateFiles$state[s]
#    clusterStatsMCC <- stateInfo$clusterStatsMCC[[s]]
#    clusterSamplesMCC <- stateInfo$clusterSamplesMCC[[s]]
# 
#    clusterStatsMCC$oldest_calendar <-as.Date(round_date(date_decimal(clusterStatsMCC$oldest), unit = "day"))
#    clusterSamplesMCC$oldest_calendar <- as.Date(round_date(date_decimal(clusterSamplesMCC$lineage_oldest), unit = "day"))
#    clusterStatsMCC$pangolin <- gsub("_.*", "", clusterStatsMCC$cluster)
#    pangolineages <- levels(as.factor(clusterStatsMCC$pangolin))
#    clusterSamplesMCC$pangolin <- sapply(clusterSamplesMCC$Pango.lineage, function(x)
#          pangolineages[x == pangolineages |
#                           startsWith(x, paste0(pangolineages, "."))])
# 
#    clusterSamplesMCC <- clusterSamplesMCC %>% mutate(sample_date = ymd(sample_date)) %>% mutate(oldest_calendar = if_else(is.na(oldest_calendar), sample_date, oldest_calendar))
# 
#    clusterSamplesMCC <-
#       clusterSamplesMCC %>% left_join(clusterStatsMCC %>% dplyr::select(cluster, tmrca_calendar, tmrca_shifted_calendar), by=c("cluster"="cluster")) %>%
#       mutate(tmrca_calendar = if_else(is.na(tmrca_calendar), oldest_calendar, tmrca_calendar),
#              tmrca_shifted_calendar = if_else(is.na(tmrca_shifted_calendar), oldest_calendar, tmrca_shifted_calendar))
# 
# 
# 
# 
# pal <- sdePal
# 
# 
# nationalcol = "#cb181d"
# localcol = "#cccccc"
# 
# 
# marksForStates_ <- list(
# 
#     "Bavaria" = list(
#       "food2Oct"= list(
#          "date"= "2020-10-02",
#          "color"= localcol,
#          label="A"
#       ),
#       "nights23Oct"= list(
#          "date"= "2020-10-23",
#          "color"= localcol,
#          label="B"
#       ),
#       "home09Dec"= list(
#          "date"= "2020-12-09",
#          "color"= localcol,
#          label="C"
#       ),
#         "Ncoldsymp19Oct"= list(
#          "date"= "2020-10-19",
#          "color"= nationalcol,
#          label="N1"
#    ),
#    "Nopera02Nov"= list(
#          "date"= "2020-11-02",
#          "color"= nationalcol,
#          label="N2"
#    ),
#    "Nopera08Nov"= list(
#          "date"= "2020-11-08",
#          "color"= nationalcol,
#          label="N3"
#    ),
#     "Nopera30Nov"= list(
#          "date"= "2020-11-30",
#          "color"= nationalcol,
#          label="N4"
#    ),
#    "Nlockdown16Dec"= list(
#       "date"= "2020-12-16",
#       "color"= nationalcol,
#          label="N5"
#    ),
#    "Nlockdown16Dec"= list(
#       "date"= "2020-12-22",
#       "color"= nationalcol,
#          label="N6"
#    ),
#    "Nborder11Jan"= list(
#       "date"= "2021-01-11",
#       "color"= nationalcol,
#       label="N7"
#    ),
#     "Nborder22Jan"= list(
#       "date"= "2021-01-24",
#       "color"= nationalcol,
#       label="N8"
#    ),
#     "Nborder30Jan"= list(
#       "date"= "2021-01-30",
#       "color"= nationalcol,
#       label="N9"
#    ),
#     "Nborder14Feb"= list(
#       "date"= "2021-02-14",
#       "color"= nationalcol,
#       label="N10"
#    ),
#    "Nborder08March"= list(
#       "date"= "2021-03-08",
#       "color"= nationalcol,
#       label="N11"
#    ),
#    "NPoland21March"= list(
#       "date"= "2021-03-21",
#       "color"= nationalcol,
#       label="N12"
#    ),
#    "NFrance31March"= list(
#       "date"= "2021-03-30",
#       "color"= nationalcol,
#       label="N13"
#    )
# ),
# 
#    "Baden-Wurttemberg"= list(
#       "mask19ct"= list(
#          "date"= "2020-10-02",
#          "color"= localcol,
#          label="A"
#       ),
#    "Ncoldsymp19Oct"= list(
#          "date"= "2020-10-19",
#          "color"= nationalcol,
#          label="N1"
#    ),
#    "Nopera02Nov"= list(
#          "date"= "2020-11-02",
#          "color"= nationalcol,
#          label="N2"
#    ),
#    "Nopera08Nov"= list(
#          "date"= "2020-11-08",
#          "color"= nationalcol,
#          label="N3"
#    ),
#     "Nopera30Nov"= list(
#          "date"= "2020-11-30",
#          "color"= nationalcol,
#          label="N4"
#    ),
#    "Nlockdown16Dec"= list(
#       "date"= "2020-12-16",
#       "color"= nationalcol,
#          label="N5"
#    ),
#    "Nlockdown16Dec"= list(
#       "date"= "2020-12-22",
#       "color"= nationalcol,
#          label="N6"
#    ),
#    "Nborder11Jan"= list(
#       "date"= "2021-01-11",
#       "color"= nationalcol,
#       label="N7"
#    ),
#     "Nborder22Jan"= list(
#       "date"= "2021-01-24",
#       "color"= nationalcol,
#       label="N8"
#    ),
#     "Nborder30Jan"= list(
#       "date"= "2021-01-30",
#       "color"= nationalcol,
#       label="N9"
#    ),
#     "Nborder14Feb"= list(
#       "date"= "2021-02-14",
#       "color"= nationalcol,
#       label="N10"
#    ),
#    "Nborder08March"= list(
#       "date"= "2021-03-08",
#       "color"= nationalcol,
#       label="N11"
#    ),
#    "NPoland21March"= list(
#       "date"= "2021-03-21",
#       "color"= nationalcol,
#       label="N12"
#    ),
#    "NFrance31March"= list(
#       "date"= "2021-03-30",
#       "color"= nationalcol,
#       label="N13"
#    )
#    ),
# 
#    "North Rhine-Westphalia" = list(
# 
#     "Ncoldsymp19Oct"= list(
#          "date"= "2020-10-19",
#          "color"= nationalcol,
#          label="N1"
#    ),
#    "Nopera02Nov"= list(
#          "date"= "2020-11-02",
#          "color"= nationalcol,
#          label="N2"
#    ),
#    "Nopera08Nov"= list(
#          "date"= "2020-11-08",
#          "color"= nationalcol,
#          label="N3"
#    ),
#     "Nopera30Nov"= list(
#          "date"= "2020-11-30",
#          "color"= nationalcol,
#          label="N4"
#    ),
#    "Nlockdown16Dec"= list(
#       "date"= "2020-12-16",
#       "color"= nationalcol,
#          label="N5"
#    ),
#    "Nlockdown16Dec"= list(
#       "date"= "2020-12-22",
#       "color"= nationalcol,
#          label="N6"
#    ),
#    "Nborder11Jan"= list(
#       "date"= "2021-01-11",
#       "color"= nationalcol,
#       label="N7"
#    ),
#     "Nborder22Jan"= list(
#       "date"= "2021-01-24",
#       "color"= nationalcol,
#       label="N8"
#    ),
#     "Nborder30Jan"= list(
#       "date"= "2021-01-30",
#       "color"= nationalcol,
#       label="N9"
#    ),
#     "Nborder14Feb"= list(
#       "date"= "2021-02-14",
#       "color"= nationalcol,
#       label="N10"
#    ),
#    "Nborder08March"= list(
#       "date"= "2021-03-08",
#       "color"= nationalcol,
#       label="N11"
#    ),
#    "NPoland21March"= list(
#       "date"= "2021-03-21",
#       "color"= nationalcol,
#       label="N12"
#    ),
#    "NFrance31March"= list(
#       "date"= "2021-03-30",
#       "color"= nationalcol,
#       label="N13"
#    )
#    )
# 
# 
# 
# )
# 
# 
# 
# 
# 
# sumtriangle <- function(data, template = c(seq(7), seq(6,1))) {
#    # print(data)
#    x <- convolve(data, template, type="open")
#    return(x %>% tail(-(length(template)-1)) %>% round(digits = 1))
# }
# 
# shift <- function(data, amount) {
#    if (amount > 0) {
#       return(c(rep(NA, amount), data) %>% head(-amount))
#    } else {
#       return(c(data, rep(NA, amount)) %>% tail(-amount))
#    }
# }
# 
# smoothDiffMeasure <- function(column, w=7) {
#    sapply(seq(length(column)), function(i) max(column[max(0,i-w+1):i]) - min(column[min(length(column),i+w-1):i])  )
# }
# 
# smoothDiffMeasureNext <- function(column, w=7) {
#    sapply(seq(length(column)), function(i) min(column[min(length(column),i+w-1):i])  )
# }
# smoothDiffMeasurePrev <- function(column, w=7) {
#    sapply(seq(length(column)), function(i) max(column[max(0,i-w+1):i])  )
# }
# 
# 
# startDate <- as.Date("2020-09-25")
# endDate <- as.Date("2021-05-04")
# 
# # tmrcaBreaksWidths <- data.frame(len = c(7, 1), width = c("1 day", "week"))
# #
# # for (tmrcaBreaksWidthIndex in seq(2)) {
# #    tmrcaBreaksLength <- tmrcaBreaksWidths$len[tmrcaBreaksWidthIndex]
# #    tmrcaBreaksWidth  <- tmrcaBreaksWidths$width[tmrcaBreaksWidthIndex]
# #
#    # for (dvar in c('tmrca_shifted_calendar', 'tmrca_calendar')) {
#    for (dvar in c('tmrca_shifted_calendar')) {
# 
#       # tmrcaBreaks <- seq.Date(as.Date("2019-01-01"), as.Date("2021-06-20"), by="7 days")
#       # tmrcaBreaks <-
#       #    seq.Date(
#       #       min(clusterStatsMCC$oldest_calendar),
#       #       max(clusterStatsMCC$oldest_calendar) + 7,
#       #       by = "7 days"
#       #    )
#        tmrcaBreaks <- seq.Date(startDate, endDate, by="1 day")
# 
#          clusterFirstCases <-
#             clusterSamplesMCC %>% filter(
#                lineage_seqs > 1 &
#                   abs(.data[["oldest_calendar"]] - sample_date) < 1 / 366 + firstCaseDistance / 366
#             )
#          clusterFirstCasesCount <-
#             clusterFirstCases %>% group_by(cluster) %>% dplyr::summarise(cluster.first.case.count = n())
#          clusterFirstCases <-
#             clusterFirstCases %>% left_join(clusterFirstCasesCount, by = c("cluster" = "cluster"))
#          clusterFirstCaseByCounty <-
#             clusterFirstCases %>%
#             # mutate(adm1 = ifelse(is.na(adm1) | adm1 == "NA", "Saxony", adm1)) %>%
#             mutate(tmrca.break.index = sapply(.[[dvar]], function(x) which.max(x < tmrcaBreaks) - 1)) %>%
#             group_by(adm1, tmrca.break.index) %>%
#             dplyr::summarise(n = sum(1 / cluster.first.case.count)) %>%
#             mutate(p =  round(n / sum(n) * 100, digits = 1))
#          #%>% arrange(desc(n)) %>% filter(adm1 == "Saxony" | adm1 == "Bavaria")
# 
#          # plot_weekly_table(clusterFirstCaseByCounty, "adm1", dePal, paste("Transmission lineage of states", "(no singleton)"), "C", "importation",
#          #                   legend_ = function(x) ifelse(nchar(x) > 10, substr(x, 1, 10), x))
#          #
# 
#          clusterFirstCasesWithSingles <-
#             clusterSamplesMCC %>% filter(
#                   abs(.data[["oldest_calendar"]] - sample_date) < 1 / 366 + firstCaseDistance / 366
#             )
#          clusterFirstCasesCount <-
#             clusterFirstCasesWithSingles %>% group_by(cluster) %>% dplyr::summarise(cluster.first.case.count = n())
#          clusterFirstCasesWithSingles <-
#             clusterFirstCasesWithSingles %>% left_join(clusterFirstCasesCount, by = c("cluster" = "cluster"))
#          clusterFirstCaseByCountyWithSingles <-
#             clusterFirstCasesWithSingles %>%
#             mutate(tmrca.break.index = sapply(.[[dvar]], function(x) which.max(x < tmrcaBreaks) - 1)) %>%
#             group_by(adm1, tmrca.break.index) %>%
#             dplyr::summarise(n = sum(1 / cluster.first.case.count))
#             # mutate(p =  round(n / sum(n) * 100, digits = 1)) %>% arrange(desc(n)) %>%
# 
#          # plot_weekly_table(clusterFirstCaseByCountyWithSingles, "adm1", dePal, paste("Transmission lineage of states", "(+single)"), "C", "importation",
#          #                   legend_ = function(x) ifelse(nchar(x) > 10, substr(x, 1, 10), x))
# 
#       smoothedCharts <- function(adm1_s, adm1_name, col, marks__) {
#          data <- clusterFirstCaseByCountyWithSingles %>% filter(adm1 %in% adm1_s) %>%
#          group_by(tmrca.break.index) %>% dplyr::summarise(n = sum(n)) %>%
#             mutate(adm1 = adm1_name) %>%
#             full_join(tmrcaBreakIndicesDF(tmrcaBreaks), by=c("tmrca.break.index"="tmrca.break.index")) %>%
#             mutate(adm1=ifelse(is.na(adm1), adm1_name, adm1), n=ifelse(is.na(n), 0, n)) %>% arrange(tmrca.break.index) %>%
#             # mutate(n=rollsum(n, tmrcaBreaksLength, align='left', fill=0))
#             filter(tmrca.break.index > 0) %>%
#             mutate(date = tmrcaBreaks[tmrca.break.index]) %>%
#             mutate(n = sumtriangle(n, template=c(seq(1,10),seq(9,1)))) %>%
#             mutate(n.shift = shift(n, 1), n.diff = n - n.shift) %>%
#             mutate(smdiff = smoothDiffMeasure(n.diff), smdiff.pref = smoothDiffMeasurePrev(n.diff), smdiff.next = smoothDiffMeasureNext(n.diff))
#             plot_weekly_table(data, "adm1", pal,
#                            # paste("Imp conv to triangle (10 d)", "(+sing)", adm1_name, dvar),
#                            "",
#                            "", "Smoothed importation frequency",
#                            legend_ = function(x) ifelse(nchar(x) > 10, substr(x, 1, 10), x), printTable_ = FALSE, marks_ = marks__ )
# 
#          ymax2 = max(data$n.diff, na.rm = TRUE) * 1.1
#          ymin2 = min(min(data$n.diff, na.rm = TRUE) * 1.1, 0)
#          marks__extended <- do.call(rbind.data.frame, marks__) %>% mutate(date = as.Date(date)) %>% left_join(data, by=c("date" = "date"))
#          p <- ggplot() +
#             geom_line(data = data, aes(x=date, y=n.diff), color=col) +
#             geom_point(data = data, aes(x=date, y=n.diff), color=col) +
#             #labs(title=paste("Imp  derivation of conv to triangle (10 d)", "(+s)", adm1_name, dvar))+
#             # labs(title=paste("triangle 10d +s",  adm1_name, dvar))+
#             scale_x_date(date_breaks = "2 week", date_labels =  "%d %b") +
#             theme(legend.position="top", axis.text.x=element_text(angle=90, hjust=1)) + geom_hline(yintercept = 0, color = "black") +
#             geom_segment(data=marks__extended, aes(x=date, y=smdiff.pref, xend=date, yend=smdiff.next), color=marks__extended$color, linetype=1) +
#             geom_segment(data=marks__extended, aes(x=date-1, y=smdiff.pref, xend=date+1, yend=smdiff.pref), color=marks__extended$color, linetype=1) +
#             geom_segment(data=marks__extended, aes(x=date-1, y=smdiff.next, xend=date+1, yend=smdiff.next), color=marks__extended$color, linetype=1) +
#             geom_segment(data=marks__extended, aes(x=date-6, y=smdiff.pref, xend=date+0, yend=smdiff.pref), color=marks__extended$color, linetype=3) +
#             geom_segment(data=marks__extended, aes(x=date-0, y=smdiff.next, xend=date+6, yend=smdiff.next), color=marks__extended$color, linetype=3) +
#             # geom_text_repel(data=marks__extended, aes(label=label, x=date, y=smdiff.pref), color=marks__extended$color, nudge_y = 0.01 * ymax, vjust = 0, direction = "x", segment.curvature = -0.1, segment.linetype = 6, force = 0) +
#             geom_text(data=marks__extended, aes(label=label, x=date, y=smdiff.pref), color=marks__extended$color, vjust = 0, nudge_y = 0.01 * ymax) +
#             ylab("Change rate of smoothed importation frequency") +
#             theme(axis.title.x = element_blank())
# 
#          print(p)
# 
# 
#          print(kable(
#             do.call(bind_rows, marks__) %>%
#                mutate(date.index = sapply(date, function(x) which.max(x < tmrcaBreaks) - 1), date.old.index = sapply(as.Date(date)-days(7), function(x) which.max(x < tmrcaBreaks) - 1)) %>%
#                left_join(data %>% dplyr::rename(date.value = n), by=c("date.index"="tmrca.break.index")) %>%
#                left_join(data %>% dplyr::rename(date.old.value = n), by=c("date.old.index"="tmrca.break.index")) %>%
#                dplyr::select(-date.index, -date.old.index, -color) %>%
#                mutate(fold.change= -(date.old.value-date.value)/date.old.value),
#             caption=paste("Change in critical points", adm1_name)))
#       }
# 
#       adm1List <- levels(factor((clusterFirstCaseByCounty %>% dplyr::select(adm1))$adm1))
#       adm1List <- c("Bavaria", "North Rhine-Westphalia", "Baden-Wurttemberg", "Saxony", "Berlin")
#       for (adm1_ in adm1List) {
# 
# 
# 
#          marks__ = marks_
#          if (adm1_ %in% names(marksForStates_)) {
#             marks__ = marksForStates_[[adm1_]];
#          }
# 
#          smoothedCharts(adm1_, adm1_, pal[[adm1_]], marks__)
#       }
# 
#       smoothedCharts(c(levels(factor((clusterFirstCaseByCounty %>% dplyr::select(adm1))$adm1)), NA), state, pal[[state]], marks_)
# 
# 
#       smoothedCharts(setdiff(c(levels(factor((clusterFirstCaseByCounty %>% dplyr::select(adm1))$adm1)), NA), c("Bavaria", "North Rhine-Westphalia", "Baden-Wurttemberg")), "other", pal[["Other"]], marks_)
# 
#    }
# 
# # }

```

```{r smoothed-compare}

for (dvar in c('tmrca_shifted_calendar', 'tmrca_calendar')) {

    tmrcaBreaks <- seq.Date(startDate, endDate, by="1 day")
   
      clusterFirstCases <-
         clusterSamplesMCC %>% filter(
            lineage_seqs > 1 &
               abs(.data[["oldest_calendar"]] - sample_date) < 1 / 366 + firstCaseDistance / 366 
         )
      clusterFirstCasesCount <-
         clusterFirstCases %>% group_by(cluster) %>% dplyr::summarise(cluster.first.case.count = n())
      clusterFirstCases <-
         clusterFirstCases %>% left_join(clusterFirstCasesCount, by = c("cluster" = "cluster"))
      clusterFirstCaseByCounty <-
         clusterFirstCases %>% 
         # mutate(adm1 = ifelse(is.na(adm1) | adm1 == "NA", "Saxony", adm1)) %>%
         mutate(tmrca.break.index = sapply(.[[dvar]], function(x) which.max(x < tmrcaBreaks) - 1)) %>%
         group_by(adm1, tmrca.break.index) %>%
         dplyr::summarise(n = sum(1 / cluster.first.case.count)) %>%
         mutate(p =  round(n / sum(n) * 100, digits = 1)) 

      clusterFirstCasesWithSingles <-
         clusterSamplesMCC %>% filter(
               abs(.data[["oldest_calendar"]] - sample_date) < 1 / 366 + firstCaseDistance / 366
         )
      clusterFirstCasesCount <-
         clusterFirstCasesWithSingles %>% group_by(cluster) %>% dplyr::summarise(cluster.first.case.count = n())
      clusterFirstCasesWithSingles <-
         clusterFirstCasesWithSingles %>% left_join(clusterFirstCasesCount, by = c("cluster" = "cluster"))
      clusterFirstCaseByCountyWithSingles <-
         clusterFirstCasesWithSingles %>%
         mutate(tmrca.break.index = sapply(.[[dvar]], function(x) which.max(x < tmrcaBreaks) - 1)) %>%
         group_by(adm1, tmrca.break.index) %>%
         dplyr::summarise(n = sum(1 / cluster.first.case.count))
      
   allTables <- setNames(data.frame(matrix(ncol = 1, nrow = 0)), c("date")) %>% mutate(date = as.Date(date))


   adm1List <- levels(factor((clusterFirstCaseByCounty %>% dplyr::select(adm1))$adm1))
   adm1List <- c("Bavaria", "North Rhine-Westphalia", "Baden-Wurttemberg", "Saxony")
   for (adm1_ in adm1List) {
      
      data <- clusterFirstCaseByCountyWithSingles %>% filter(adm1 == adm1_) %>% 
         full_join(tmrcaBreakIndicesDF(tmrcaBreaks), by=c("tmrca.break.index"="tmrca.break.index")) %>% 
         mutate(adm1=ifelse(is.na(adm1), adm1_, adm1), n=ifelse(is.na(n), 0, n)) %>% arrange(tmrca.break.index) %>%
         # mutate(n=rollsum(n, tmrcaBreaksLength, align='left', fill=0))
         filter(tmrca.break.index > 0) %>%
         mutate(date = tmrcaBreaks[tmrca.break.index]) %>%
         mutate(n = sumtriangle(n, template=c(seq(1,10),seq(9,1)))) %>%
         mutate(n.shift = shift(n, 1), n.diff = n - n.shift) %>%
         mutate(smdiff = smoothDiffMeasure(n.diff))
      
      
      
      allTables <- allTables %>% full_join(data %>% ungroup() %>% dplyr::select(date, smdiff, n.diff), by=c("date"="date"))
      colnames(allTables)[(ncol(allTables)-1):(ncol(allTables))] <- c(paste0("smdiff.", adm1_), paste0("nd.", adm1_))

   }
   
   data <- clusterFirstCaseByCountyWithSingles %>% 
      group_by(tmrca.break.index) %>% dplyr::summarise(n = sum(n)) %>%
      full_join(tmrcaBreakIndicesDF(tmrcaBreaks), by=c("tmrca.break.index"="tmrca.break.index")) %>% 
      filter(tmrca.break.index > 0) %>%
      mutate(date = tmrcaBreaks[tmrca.break.index]) %>%
      mutate(n=ifelse(is.na(n), 0, n), state=state) %>% arrange(tmrca.break.index) %>%
      mutate(n = sumtriangle(n, template=c(seq(1,10),seq(9,1)))) %>%
      mutate(n.shift = shift(n, 1), n.diff = n - n.shift) %>%
      mutate(smdiff = smoothDiffMeasure(n.diff))
   
  

   adm1_ <- "Germany"
   # print(kable(data %>% dplyr::select(date, smdiff, n), caption=paste("Smoothed measure diff", dvar)))
   allTables <- allTables %>% full_join(data %>% ungroup() %>% dplyr::select(date, smdiff, n.diff), by=c("date"="date"))
   colnames(allTables)[(ncol(allTables)-1):(ncol(allTables))] <- c(paste0("smdiff.", adm1_), paste0("nd.", adm1_))
   
   col.names <- colnames(allTables)
   col.names <- str_replace(col.names, "\\.", " ")
   col.names <- str_replace(col.names, "smdiff", "d")
   col.names <- str_replace(col.names, "North Rhine-Westphalia", "NRW")
   col.names <- str_replace(col.names, "Bavaria", "Bav")
   col.names <- str_replace(col.names, "Baden-Wurttemberg", "Bad")
   col.names <- str_replace(col.names, "Saxony", "Sax")
   col.names <- str_replace(col.names, "Germany", "DEU")

   library(kableExtra)
   print(kbl(allTables, col.names = col.names, caption=paste("smoothed diff", dvar), booktabs=TRUE) %>% kable_classic(c("striped", "hover")))
}
         
```

```{r importation-state-specific-10-day, fig.width=8, fig.height=4, eval=TRUE}
#    par(mar = c(4, 6, 5, 6), cex.axis = 0.7, cex.lab = 0.8, cex.main = 1.5, mgp = c(3, 0.75, 0))
# 
# 
# pal <- dePal
# pal[[state]] <- dePal$oth
# 
# pal[["Bavaria"]] = lighten(dePal[["Bavaria"]], 0.5)
# pal[["Baden-Wurttemberg"]] = lighten(dePal[["Baden-Wurttemberg"]], 0.5)
# pal[["North Rhine-Westphalia"]] = lighten(dePal[["North Rhine-Westphalia"]], 0.5)
# pal[["Saxony"]] = lighten(dePal[["Saxony"]], 0.5)
# 
# 
# 
#    for (dvar in c('tmrca_shifted_calendar', 'tmrca_calendar')) {
#    
#       # tmrcaBreaks <- seq.Date(as.Date("2019-01-01"), as.Date("2021-06-20"), by="7 days")
#       # tmrcaBreaks <-
#       #    seq.Date(
#       #       min(clusterStatsMCC$oldest_calendar),
#       #       max(clusterStatsMCC$oldest_calendar) + 7,
#       #       by = "7 days"
#       #    )
#        tmrcaBreaks <- seq.Date(startDate, endDate, by="1 day")
#       
#          clusterFirstCases <-
#             clusterSamplesMCC %>% filter(
#                lineage_seqs > 1 &
#                   abs(.data[["oldest_calendar"]] - sample_date) < 1 / 366 + firstCaseDistance / 366 
#             )
#          clusterFirstCasesCount <-
#             clusterFirstCases %>% group_by(cluster) %>% dplyr::summarise(cluster.first.case.count = n())
#          clusterFirstCases <-
#             clusterFirstCases %>% left_join(clusterFirstCasesCount, by = c("cluster" = "cluster"))
#          clusterFirstCaseByCounty <-
#             clusterFirstCases %>% 
#             # mutate(adm1 = ifelse(is.na(adm1) | adm1 == "NA", "Saxony", adm1)) %>%
#             mutate(tmrca.break.index = sapply(.[[dvar]], function(x) which.max(x < tmrcaBreaks) - 1)) %>%
#             group_by(adm1, tmrca.break.index) %>%
#             dplyr::summarise(n = sum(1 / cluster.first.case.count)) %>%
#             mutate(p =  round(n / sum(n) * 100, digits = 1)) 
#          #%>% arrange(desc(n)) %>% filter(adm1 == "Saxony" | adm1 == "Bavaria")
#    
#          # plot_weekly_table(clusterFirstCaseByCounty, "adm1", dePal, paste("Transmission lineage of states", "(no singleton)"), "C", "importation", 
#          #                   legend_ = function(x) ifelse(nchar(x) > 10, substr(x, 1, 10), x))
#          # 
#    
#          clusterFirstCasesWithSingles <-
#             clusterSamplesMCC %>% filter(
#                   abs(.data[["oldest_calendar"]] - sample_date) < 1 / 366 + firstCaseDistance / 366
#             )
#          clusterFirstCasesCount <-
#             clusterFirstCasesWithSingles %>% group_by(cluster) %>% dplyr::summarise(cluster.first.case.count = n())
#          clusterFirstCasesWithSingles <-
#             clusterFirstCasesWithSingles %>% left_join(clusterFirstCasesCount, by = c("cluster" = "cluster"))
#          clusterFirstCaseByCountyWithSingles <-
#             clusterFirstCasesWithSingles %>%
#             mutate(tmrca.break.index = sapply(.[[dvar]], function(x) which.max(x < tmrcaBreaks) - 1)) %>%
#             group_by(adm1, tmrca.break.index) %>%
#             dplyr::summarise(n = sum(1 / cluster.first.case.count))
#             # mutate(p =  round(n / sum(n) * 100, digits = 1)) %>% arrange(desc(n)) %>%
#    
#          # plot_weekly_table(clusterFirstCaseByCountyWithSingles, "adm1", dePal, paste("Transmission lineage of states", "(+single)"), "C", "importation",
#          #                   legend_ = function(x) ifelse(nchar(x) > 10, substr(x, 1, 10), x))
#          
#    
#       adm1List <- levels(factor((clusterFirstCaseByCounty %>% dplyr::select(adm1))$adm1))
#       adm1List <- c("Bavaria", "North Rhine-Westphalia", "Baden-Wurttemberg", "Saxony")
#       for (adm1_ in adm1List) {
#          
#         # plot_weekly_table(clusterFirstCaseByCounty %>% filter(adm1 == adm1_), "adm1", dePal, 
#          #                  paste("Transmission lineage of states", "(no singleton)", adm1_), "C", "importation", 
#           #                 legend_ = function(x) ifelse(nchar(x) > 10, substr(x, 1, 10), x))
#          data <- clusterFirstCaseByCountyWithSingles %>% filter(adm1 == adm1_) %>% 
#             full_join(tmrcaBreaks %>% sapply(function(x) which.max(x < tmrcaBreaks) - 1) %>% data.frame() %>% 
#                          dplyr::rename(tmrca.break.index=1), by=c("tmrca.break.index"="tmrca.break.index")) %>% 
#             mutate(adm1=ifelse(is.na(adm1), adm1_, adm1), n=ifelse(is.na(n), 0, n)) %>% arrange(tmrca.break.index) %>%
#             # mutate(n=rollsum(n, tmrcaBreaksLength, align='left', fill=0))
#             mutate(n = sumtriangle(n, template=c(seq(10), seq(9,1)))) %>%
#             mutate(n.shift = shift(n, 7), n.diff = n - n.shift)
#          
#          marks__ = marks_
#          if (adm1_ %in% names(marksForStates_)) {
#             marks__ = marksForStates_[[adm1_]];
#          }
#    
#          plot_weekly_table(data, "adm1", pal, 
#                            paste("Frequency of importations convolved to triangle (10 days)", "(+single)", adm1_, dvar), "", "frequency of importations",
#                            legend_ = function(x) ifelse(nchar(x) > 10, substr(x, 1, 10), x), printTable_ = FALSE, marks_ = marks__ )
#          plot_weekly_table(data %>% mutate(n = n.diff), "adm1", dePal, 
#                            paste("Frequency of importations convolved to triangle (10 days), 7 day diff", "(+single)", adm1_, dvar), "", "frequency of importations",
#                            legend_ = function(x) ifelse(nchar(x) > 10, substr(x, 1, 10), x), printTable_ = FALSE, marks_ = marks__ )
#          
#          print(kable(
#             do.call(rbind.data.frame, marks__) %>% 
#                mutate(date.index = sapply(date, function(x) which.max(x < tmrcaBreaks) - 1), date.old.index = sapply(as.Date(date)-days(7), function(x) which.max(x < tmrcaBreaks) - 1)) %>% 
#                left_join(data %>% dplyr::rename(date.value = n), by=c("date.index"="tmrca.break.index")) %>% 
#                left_join(data %>% dplyr::rename(date.old.value = n), by=c("date.old.index"="tmrca.break.index")) %>% 
#                dplyr::select(-date.index, -date.old.index, -color) %>% 
#                mutate(fold.change= -(date.old.value-date.value)/date.old.value), 
#             caption=paste("Change in critical points", adm1_)))
#          # print(kable(clusterFirstCasesWithSingles %>% filter(adm1 == adm1_) %>% arrange(.[[dvar]]) %>% dplyr::select(cluster, dvar), caption = paste("clusters+single sorted by importation for", adm1_) ))
#    
#       }
#       
#       data <- clusterFirstCaseByCountyWithSingles %>% 
#          group_by(tmrca.break.index) %>% dplyr::summarise(n = sum(n)) %>%
#          full_join(tmrcaBreaks %>% sapply(function(x) which.max(x < tmrcaBreaks) - 1) %>% data.frame() %>% 
#                       dplyr::rename(tmrca.break.index=1), by=c("tmrca.break.index"="tmrca.break.index")) %>% 
#          mutate(n=ifelse(is.na(n), 0, n), state=state) %>% arrange(tmrca.break.index) %>%
#          mutate(n = sumtriangle(n, template=c(seq(10), seq(9,1)))) %>%
#          mutate(n.shift = shift(n, 7), n.diff = n - n.shift)
#       
#       marks__ = marks_
#       if (state %in% names(marksForStates_)) {
#          marks__ = marksForStates_[[state]];
#       }
#       
#  #     pal <- dePal
#  #     pal[[state]] <- dePal$oth
# 
#       plot_weekly_table(data, "state", pal, 
#                         paste("Frequency of importations convolved to triangle (10 days)", "(+single)", state, dvar), "", "frequency of importations",
#                         legend_ = function(x) ifelse(nchar(x) > 10, substr(x, 1, 10), x), printTable_ = FALSE, marks_ = marks__ )
#       plot_weekly_table(data %>% mutate(n = n.diff), "state", pal, 
#                         paste("Frequency of importations convolved to triangle, 7 day diff (10 days)", "(+single)", state, dvar), "", "frequency of importations",
#                         legend_ = function(x) ifelse(nchar(x) > 10, substr(x, 1, 10), x), printTable_ = FALSE, marks_ = marks__ )
#       
#       print(kable(
#          do.call(rbind.data.frame, marks__) %>% 
#             mutate(date.index = sapply(date, function(x) which.max(x < tmrcaBreaks) - 1), date.old.index = sapply(as.Date(date)-days(7), function(x) which.max(x < tmrcaBreaks) - 1)) %>% 
#             left_join(data %>% dplyr::rename(date.value = n), by=c("date.index"="tmrca.break.index")) %>% 
#             left_join(data %>% dplyr::rename(date.old.value = n), by=c("date.old.index"="tmrca.break.index")) %>% 
#             dplyr::select(-date.index, -date.old.index, -color) %>% 
#             mutate(fold.change= -(date.old.value-date.value)/date.old.value), 
#          caption=paste("Change in critical points", adm1_)))
#       # print(kable(clusterFirstCasesWithSingles %>% filter(adm1 == adm1_) %>% arrange(.[[dvar]]) %>% dplyr::select(cluster, dvar), caption = paste("clusters+single sorted by importation for", adm1_) ))
#    
 #  }
         
# }

```
```{r importation-state-specific-10-day-square-convolve, fig.width=12, fig.height=5, eval=TRUE}
#    par(mar = c(4, 6, 5, 6), cex.axis = 0.7, cex.lab = 0.8, cex.main = 1.5, mgp = c(3, 0.75, 0))
# tmrcaChangeEvaluationDistance <- 7
#    for (dvar in c('tmrca_shifted_calendar', 'tmrca_calendar')) {
#    
#       # tmrcaBreaks <- seq.Date(as.Date("2019-01-01"), as.Date("2021-06-20"), by="7 days")
#       # tmrcaBreaks <-
#       #    seq.Date(
#       #       min(clusterStatsMCC$oldest_calendar),
#       #       max(clusterStatsMCC$oldest_calendar) + 7,
#       #       by = "7 days"
#       #    )
#        tmrcaBreaks <- seq.Date(startDate, endDate, by="1 day")
#       
#          clusterFirstCases <-
#             clusterSamplesMCC %>% filter(
#                lineage_seqs > 1 &
#                   abs(.data[["oldest_calendar"]] - sample_date) < 1 / 366 + firstCaseDistance / 366 
#             )
#          clusterFirstCasesCount <-
#             clusterFirstCases %>% group_by(cluster) %>% dplyr::summarise(cluster.first.case.count = n())
#          clusterFirstCases <-
#             clusterFirstCases %>% left_join(clusterFirstCasesCount, by = c("cluster" = "cluster"))
#          clusterFirstCaseByCounty <-
#             clusterFirstCases %>% 
#             # mutate(adm1 = ifelse(is.na(adm1) | adm1 == "NA", "Saxony", adm1)) %>%
#             mutate(tmrca.break.index = sapply(.[[dvar]], function(x) which.max(x < tmrcaBreaks) - 1)) %>%
#             group_by(adm1, tmrca.break.index) %>%
#             dplyr::summarise(n = sum(1 / cluster.first.case.count)) %>%
#             mutate(p =  round(n / sum(n) * 100, digits = 1)) 
#          #%>% arrange(desc(n)) %>% filter(adm1 == "Saxony" | adm1 == "Bavaria")
#    
#          # plot_weekly_table(clusterFirstCaseByCounty, "adm1", dePal, paste("Transmission lineage of states", "(no singleton)"), "C", "importation", 
#          #                   legend_ = function(x) ifelse(nchar(x) > 10, substr(x, 1, 10), x))
#          # 
#    
#          clusterFirstCasesWithSingles <-
#             clusterSamplesMCC %>% filter(
#                   abs(.data[["oldest_calendar"]] - sample_date) < 1 / 366 + firstCaseDistance / 366
#             )
#          clusterFirstCasesCount <-
#             clusterFirstCasesWithSingles %>% group_by(cluster) %>% dplyr::summarise(cluster.first.case.count = n())
#          clusterFirstCasesWithSingles <-
#             clusterFirstCasesWithSingles %>% left_join(clusterFirstCasesCount, by = c("cluster" = "cluster"))
#          clusterFirstCaseByCountyWithSingles <-
#             clusterFirstCasesWithSingles %>%
#             mutate(tmrca.break.index = sapply(.[[dvar]], function(x) which.max(x < tmrcaBreaks) - 1)) %>%
#             group_by(adm1, tmrca.break.index) %>%
#             dplyr::summarise(n = sum(1 / cluster.first.case.count))
#             # mutate(p =  round(n / sum(n) * 100, digits = 1)) %>% arrange(desc(n)) %>%
#    
#          # plot_weekly_table(clusterFirstCaseByCountyWithSingles, "adm1", dePal, paste("Transmission lineage of states", "(+single)"), "C", "importation",
#          #                   legend_ = function(x) ifelse(nchar(x) > 10, substr(x, 1, 10), x))
#          
#    
#       adm1List <- levels(factor((clusterFirstCaseByCounty %>% dplyr::select(adm1))$adm1))
#       adm1List <- c("Bavaria", "North Rhine-Westphalia", "Baden-Wurttemberg", "Saxony")
#       for (adm1_ in adm1List) {
#          
#         # plot_weekly_table(clusterFirstCaseByCounty %>% filter(adm1 == adm1_), "adm1", dePal, 
#          #                  paste("Transmission lineage of states", "(no singleton)", adm1_), "C", "importation", 
#           #                 legend_ = function(x) ifelse(nchar(x) > 10, substr(x, 1, 10), x))
#          data <- clusterFirstCaseByCountyWithSingles %>% filter(adm1 == adm1_) %>% 
#             full_join(tmrcaBreaks %>% sapply(function(x) which.max(x < tmrcaBreaks) - 1) %>% data.frame() %>% 
#                          dplyr::rename(tmrca.break.index=1), by=c("tmrca.break.index"="tmrca.break.index")) %>% 
#             mutate(adm1=ifelse(is.na(adm1), adm1_, adm1), n=ifelse(is.na(n), 0, n)) %>% arrange(tmrca.break.index) %>%
#             # mutate(n=rollsum(n, tmrcaBreaksLength, align='left', fill=0))
#             mutate(n = sumtriangle(n, template=rep(1, tmrcaChangeEvaluationDistance))) %>%
#             mutate(n.shift = shift(n, tmrcaChangeEvaluationDistance), n.diff = n - n.shift)
#          
#          marks__ = marks_
#          if (adm1_ %in% names(marksForStates_)) {
#             marks__ = marksForStates_[[adm1_]];
#          }
#    
#          plot_weekly_table(data, "adm1", dePal, 
#                            paste("Transmission lineage of states convolved to square (", tmrcaChangeEvaluationDistance, " days)", "(+single)", adm1_, dvar), "C", "importation",
#                            legend_ = function(x) ifelse(nchar(x) > 10, substr(x, 1, 10), x), printTable_ = FALSE, marks_ = marks__ )
#          plot_weekly_table(data %>% mutate(n = n.diff), "adm1", dePal, 
#                            paste("Transmission lineage of states convolved to square (", tmrcaChangeEvaluationDistance, " days), ", tmrcaChangeEvaluationDistance, " day diff", "(+single)", adm1_, dvar), "C", "importation",
#                            legend_ = function(x) ifelse(nchar(x) > 10, substr(x, 1, 10), x), printTable_ = FALSE, marks_ = marks__ )
#          
#          print(kable(
#             do.call(rbind.data.frame, marks__) %>% 
#                mutate(date.index = sapply(date, function(x) which.max(x < tmrcaBreaks) - 1), date.old.index = sapply(as.Date(date)-days(tmrcaChangeEvaluationDistance), function(x) which.max(x < tmrcaBreaks) - 1)) %>% 
#                left_join(data %>% dplyr::rename(date.value = n), by=c("date.index"="tmrca.break.index")) %>% 
#                left_join(data %>% dplyr::rename(date.old.value = n), by=c("date.old.index"="tmrca.break.index")) %>% 
#                dplyr::select(-date.index, -date.old.index, -color) %>% 
#                mutate(fold.change= -(date.old.value-date.value)/date.old.value), 
#             caption=paste("Change in critical points", adm1_)))
#          # print(kable(clusterFirstCasesWithSingles %>% filter(adm1 == adm1_) %>% arrange(.[[dvar]]) %>% dplyr::select(cluster, dvar), caption = paste("clusters+single sorted by importation for", adm1_) ))
#    
#       }
#       
#       data <- clusterFirstCaseByCountyWithSingles %>% 
#          group_by(tmrca.break.index) %>% dplyr::summarise(n = sum(n)) %>%
#          full_join(tmrcaBreaks %>% sapply(function(x) which.max(x < tmrcaBreaks) - 1) %>% data.frame() %>% 
#                       dplyr::rename(tmrca.break.index=1), by=c("tmrca.break.index"="tmrca.break.index")) %>% 
#          mutate(n=ifelse(is.na(n), 0, n), state=state) %>% arrange(tmrca.break.index) %>%
#          mutate(n = sumtriangle(n, template=rep(1, tmrcaChangeEvaluationDistance))) %>%
#          mutate(n.shift = shift(n, 7), n.diff = n - n.shift)
#       
#       marks__ = marks_
#       if (state %in% names(marksForStates_)) {
#          marks__ = marksForStates_[[state]];
#       }
#       
#       pal <- dePal
#       pal[[state]] <- dePal$oth
# 
#       plot_weekly_table(data, "state", pal, 
#                         paste("Transmission lineage of states convolved to square (", tmrcaChangeEvaluationDistance, " days square)", "(+single)", state, dvar), "C", "importation",
#                         legend_ = function(x) ifelse(nchar(x) > 10, substr(x, 1, 10), x), printTable_ = FALSE, marks_ = marks__ )
#       plot_weekly_table(data %>% mutate(n = n.diff), "state", pal, 
#                         paste("Transmission lineage of states convolved to square, ", tmrcaChangeEvaluationDistance, " day diff (", tmrcaChangeEvaluationDistance, " days square)", "(+single)", state, dvar), "C", "importation",
#                         legend_ = function(x) ifelse(nchar(x) > 10, substr(x, 1, 10), x), printTable_ = FALSE, marks_ = marks__ )
#       
#       print(kable(
#          do.call(rbind.data.frame, marks__) %>% 
#             mutate(date.index = sapply(date, function(x) which.max(x < tmrcaBreaks) - 1), date.old.index = sapply(as.Date(date)-days(tmrcaChangeEvaluationDistance), function(x) which.max(x < tmrcaBreaks) - 1)) %>% 
#             left_join(data %>% dplyr::rename(date.value = n), by=c("date.index"="tmrca.break.index")) %>% 
#             left_join(data %>% dplyr::rename(date.old.value = n), by=c("date.old.index"="tmrca.break.index")) %>% 
#             dplyr::select(-date.index, -date.old.index, -color) %>% 
#             mutate(fold.change= -(date.old.value-date.value)/date.old.value), 
#          caption=paste("Change in critical points", state, dvar)))
#       # print(kable(clusterFirstCasesWithSingles %>% filter(adm1 == adm1_) %>% arrange(.[[dvar]]) %>% dplyr::select(cluster, dvar), caption = paste("clusters+single sorted by importation for", adm1_) ))
#    
#    }
         
# }

```

```{r confirmed-cases, fig.width=7, fig.height=3, eval=TRUE}

   par(mar = c(4, 6, 2.5, 6), cex.axis = 0.7, cex.lab = 0.8, cex.main = 1.5, mgp = c(3, 0.75, 0))
   # TODO: remove constants 
   deCountyDaily <- getDeCountyDaily("../data/cases-rki-by-state.csv", "../data/germany-subdivisions.csv", metadata)
   pal <- list("n" = firstCaseDistancesizePal$single)
   
   countyIt <- "Germany"
   countyWeekly <- deCountyDaily %>% dplyr::filter(date >= tmrcaBreaks[1] & date < tmrcaBreaks[length(tmrcaBreaks)]) %>% 
      mutate(break.index = sapply(date, function(x) which.max(x < tmrcaBreaks) - 1)) %>%
      join(data.frame("date"=tmrcaBreaks[1:(length(tmrcaBreaks)-1)]) %>% mutate(break.index = sapply(date, function(x) which.max(x < tmrcaBreaks) - 1)), type = "full", by=c("break.index"="break.index")) %>%
      mutate(case=ifelse(is.na(case), 0, case)) %>%
      group_by(break.index) %>%
      dplyr::summarise(n = sum(case)) %>%
      mutate(p =  round(n / sum(n) * 100, digits = 1)) 

   #    dateFreqDistribution(countyWeekly$n,
   #                      tmrcaBreaks, plot.ci=FALSE,
   #                      barplot=TRUE,
   #                      startDate = tmrcaBreaks[1],
   #                      endDate = tmrcaBreaks[length(tmrcaBreaks)-1],
   #                      col=mPal(unlist(pal), 0.75), border=mPal(unlist(pal)),
   #                      ymax=max(countyWeekly$n) * 1.1,
   #                      ylab = "")
   # 
   # legend("top", horiz=FALSE, inset=c(0,-0.2), bty='n', xpd=TRUE, ncol=1,
   #        fill=mPal(unlist(pal), 0.75), border = mPal(unlist(pal)),
   #        legend = c(paste("Number of confirmed cases in", countyIt)),
   #        # legend = c("Germany", "Other countries"),
   #        #legend = c("England", "Scotland", "Wales"#FF7F00, "Northern Ireland", "Other countries"),
   #        cex=0.8)
   
   
         # plot.window(c(tmrcaBreaks[1], tmrcaBreaks[length(tmrcaBreaks) - 1]), c(0, ymax), xaxs="i")
         # for (m in marks_) {
         #    arrows(as.Date(m$date), 0.9*ymax, as.Date(m$date), 0*ymax, col=m$color, lwd=1, angle=10, length=0.1)
         # }
```


```{r debug-1, fig.width=7, fig.height=6, eval=TRUE}


# markers_ <- list(
#    "first"= list(
#       "date"= "2021-01-01",
#       "color"= "#ef0000"
#    ), 
#    "first"= list(
#       "date"= "2020-05-13",
#       "color"= "#00ef00"
#    )
# )
# 
#    par(mar=c(4,6,2.5,6), cex.axis=0.7, cex.lab=0.8, mgp=c(3.25,0.75,0))
# 
# plot_weekly_table(clusterBySizeByShiftedTMRCA, "lineage_size_order", firstCaseDistancesizePal, paste("Transmission lineage of states", "(no singleton)"), "C", "A", ordering_=c("huge", "big", "med", "small", "single"), marks_=markers_)
# 
#    

```


```{r importation-state-specific, fig.width=8, fig.height=4, eval=TRUE}

   #layout(matrix(1:2, nrow = 2, byrow = TRUE))
   # par(mar = c(4, 6, 2.5, 6), cex.axis = 0.7, cex.lab = 0.8, cex.main = 1.5, mgp = c(3, 0.75, 0))
   
   s <- 1
   state <- stateFiles$state[s]
   clusterStatsMCC <- stateInfo$clusterStatsMCC[[s]]
   clusterSamplesMCC <- stateInfo$clusterSamplesMCC[[s]]
   
   clusterStatsMCC$oldest_calendar <-as.Date(round_date(date_decimal(clusterStatsMCC$oldest), unit = "day"))
   clusterSamplesMCC$oldest_calendar <- as.Date(round_date(date_decimal(clusterSamplesMCC$lineage_oldest), unit = "day"))
   clusterStatsMCC$pangolin <- gsub("_.*", "", clusterStatsMCC$cluster)
   pangolineages <- levels(as.factor(clusterStatsMCC$pangolin))
   clusterSamplesMCC$pangolin <- sapply(clusterSamplesMCC$Pango.lineage, function(x)
         pangolineages[x == pangolineages |
                          startsWith(x, paste0(pangolineages, "."))])
   
   clusterSamplesMCC <- clusterSamplesMCC %>% mutate(sample_date = ymd(sample_date)) %>% mutate(oldest_calendar = if_else(is.na(oldest_calendar), sample_date, oldest_calendar)) 
   
   clusterSamplesMCC <-
      clusterSamplesMCC %>% left_join(clusterStatsMCC %>% dplyr::select(cluster, tmrca_calendar, tmrca_shifted_calendar), by=c("cluster"="cluster")) %>%
      mutate(tmrca_calendar = if_else(is.na(tmrca_calendar), oldest_calendar, tmrca_calendar),
             tmrca_shifted_calendar = if_else(is.na(tmrca_shifted_calendar), oldest_calendar, tmrca_shifted_calendar))
   
   
   
   # tmrcaBreaks <- seq.Date(as.Date("2019-01-01"), as.Date("2021-06-20"), by="7 days")
   # tmrcaBreaks <-
   #    seq.Date(
   #       min(clusterStatsMCC$oldest_calendar),
   #       max(clusterStatsMCC$oldest_calendar) + 7,
   #       by = "7 days"
   #    )
    tmrcaBreaks <- seq.Date(min(clusterStatsMCC$tmrca_shifted_calendar), max(clusterStatsMCC$tmrca_calendar)+7+7+7, by="7 days")
    tmrcaBreaks <- tmrcaBreaks[tmrcaBreaks >= max(tmrcaBreaks[tmrcaBreaks <= as.Date("2020-08-30")])]
   
      clusterFirstCases <-
         clusterSamplesMCC %>% filter(
            lineage_seqs > 1 &
               abs(.data[["oldest_calendar"]] - sample_date) < 1 / 366 + firstCaseDistance / 366 
         )
      clusterFirstCasesCount <-
         clusterFirstCases %>% group_by(cluster) %>% dplyr::summarise(cluster.first.case.count = n())
      clusterFirstCases <-
         clusterFirstCases %>% left_join(clusterFirstCasesCount, by = c("cluster" = "cluster"))
      clusterFirstCaseByCounty <-
         clusterFirstCases %>% 
         # mutate(adm1 = ifelse(is.na(adm1) | adm1 == "NA", "Saxony", adm1)) %>%
         mutate(tmrca.break.index = sapply(tmrca_shifted_calendar, function(x) which.max(x < tmrcaBreaks) - 1)) %>%
         group_by(adm1, tmrca.break.index) %>%
         dplyr::summarise(n = sum(1 / cluster.first.case.count)) %>%
         mutate(p =  round(n / sum(n) * 100, digits = 1)) 
      #%>% arrange(desc(n)) %>% filter(adm1 == "Saxony" | adm1 == "Bavaria")

      #plot_weekly_table(clusterFirstCaseByCounty, "adm1", dePal, paste("Importation events of states", "(no singleton)"), "", "Frequency of importation events", 
                       # legend_ = function(x) ifelse(nchar(x) > 10, substr(x, 1, 10), x))
      

      clusterFirstCasesWithSingles <-
         clusterSamplesMCC %>% filter(
               abs(.data[["oldest_calendar"]] - sample_date) < 1 / 366 + firstCaseDistance / 366
         )
      clusterFirstCasesCount <-
         clusterFirstCasesWithSingles %>% group_by(cluster) %>% dplyr::summarise(cluster.first.case.count = n())
      clusterFirstCasesWithSingles <-
         clusterFirstCasesWithSingles %>% left_join(clusterFirstCasesCount, by = c("cluster" = "cluster"))
      clusterFirstCaseByCountyWithSingles <-
         clusterFirstCasesWithSingles %>%
         mutate(tmrca.break.index = sapply(tmrca_shifted_calendar, function(x) which.max(x < tmrcaBreaks) - 1)) %>%
         group_by(adm1, tmrca.break.index) %>%
         dplyr::summarise(n = sum(1 / cluster.first.case.count)) %>%
         mutate(p =  round(n / sum(n) * 100, digits = 1)) %>% arrange(desc(n))

      
   par(mar = c(4, 6, 1, 10))
   adm1List <- levels(factor((clusterFirstCaseByCounty %>% dplyr::select(adm1))$adm1))
   for (adm1_ in adm1List) {

     # plot_weekly_table(clusterFirstCaseByCounty %>% filter(adm1 == adm1_), "adm1", dePal,
      #                  paste("Transmission lineage of states", "(no singleton)", adm1_), "C", "importation",
       #                 legend_ = function(x) ifelse(nchar(x) > 10, substr(x, 1, 10), x))

      plot_weekly_table(clusterFirstCaseByCountyWithSingles %>% filter(adm1 == adm1_), "adm1", sdePal,
                        # paste("Importation events of state ", adm1_ , "(+single)"), 
                        "", 
                        "", 
                        "Frequency of importation events",
                        legend_ = function(x) ifelse(nchar(x) > 10, substr(x, 1, 10), x), 
                     legend.position = "topleft",
                     legend.inset = c(0, -0.2), legend.ncol = 1,
                     # legend.map = TRUE, 
                     legend.map.color = sdePal, legend.map.viewport = c(2,25,5,1))

      print(kable(clusterFirstCasesWithSingles %>% filter(adm1 == adm1_) %>% arrange(tmrca_shifted_calendar) %>% dplyr::select(cluster, tmrca_shifted_calendar), caption = paste("clusters+single sorted by importation for", adm1_) ))

   }

   
```


```{r TEMP importation-state-specific, fig.width=7, fig.height=2.5, eval=TRUE}

   #layout(matrix(1:2, nrow = 2, byrow = TRUE))
   # par(mar = c(4, 6, 2.5, 6), cex.axis = 0.7, cex.lab = 0.8, cex.main = 1.5, mgp = c(3, 0.75, 0))
   
   s <- 1
   state <- stateFiles$state[s]
   clusterStatsMCC <- stateInfo$clusterStatsMCC[[s]]
   clusterSamplesMCC <- stateInfo$clusterSamplesMCC[[s]]
   
   clusterStatsMCC$oldest_calendar <-as.Date(round_date(date_decimal(clusterStatsMCC$oldest), unit = "day"))
   clusterSamplesMCC$oldest_calendar <- as.Date(round_date(date_decimal(clusterSamplesMCC$lineage_oldest), unit = "day"))
   clusterStatsMCC$pangolin <- gsub("_.*", "", clusterStatsMCC$cluster)
   pangolineages <- levels(as.factor(clusterStatsMCC$pangolin))
   clusterSamplesMCC$pangolin <- sapply(clusterSamplesMCC$Pango.lineage, function(x)
         pangolineages[x == pangolineages |
                          startsWith(x, paste0(pangolineages, "."))])
   
   clusterSamplesMCC <- clusterSamplesMCC %>% mutate(sample_date = ymd(sample_date)) %>% mutate(oldest_calendar = if_else(is.na(oldest_calendar), sample_date, oldest_calendar)) 
   
   clusterSamplesMCC <-
      clusterSamplesMCC %>% left_join(clusterStatsMCC %>% dplyr::select(cluster, tmrca_calendar, tmrca_shifted_calendar), by=c("cluster"="cluster")) %>%
      mutate(tmrca_calendar = if_else(is.na(tmrca_calendar), oldest_calendar, tmrca_calendar),
             tmrca_shifted_calendar = if_else(is.na(tmrca_shifted_calendar), oldest_calendar, tmrca_shifted_calendar))
   
   
   
   # tmrcaBreaks <- seq.Date(as.Date("2019-01-01"), as.Date("2021-06-20"), by="7 days")
   # tmrcaBreaks <-
   #    seq.Date(
   #       min(clusterStatsMCC$oldest_calendar),
   #       max(clusterStatsMCC$oldest_calendar) + 7,
   #       by = "7 days"
   #    )
    tmrcaBreaks <- seq.Date(min(clusterStatsMCC$tmrca_shifted_calendar), max(clusterStatsMCC$tmrca_calendar)+7+7+7, by="7 days")
    tmrcaBreaks <- tmrcaBreaks[tmrcaBreaks >= max(tmrcaBreaks[tmrcaBreaks <= as.Date("2020-08-30")])]
   
      clusterFirstCases <-
         clusterSamplesMCC %>% filter(
            lineage_seqs > 1 &
               abs(.data[["oldest_calendar"]] - sample_date) < 1 / 366 + firstCaseDistance / 366 
         )
      clusterFirstCasesCount <-
         clusterFirstCases %>% group_by(cluster) %>% dplyr::summarise(cluster.first.case.count = n())
      clusterFirstCases <-
         clusterFirstCases %>% left_join(clusterFirstCasesCount, by = c("cluster" = "cluster"))
      clusterFirstCaseByCounty <-
         clusterFirstCases %>% 
         # mutate(adm1 = ifelse(is.na(adm1) | adm1 == "NA", "Saxony", adm1)) %>%
         mutate(tmrca.break.index = sapply(tmrca_shifted_calendar, function(x) which.max(x < tmrcaBreaks) - 1)) %>%
         group_by(adm1, tmrca.break.index) %>%
         dplyr::summarise(n = sum(1 / cluster.first.case.count)) %>%
         mutate(p =  round(n / sum(n) * 100, digits = 1)) 
      #%>% arrange(desc(n)) %>% filter(adm1 == "Saxony" | adm1 == "Bavaria")

      #plot_weekly_table(clusterFirstCaseByCounty, "adm1", dePal, paste("Importation events of states", "(no singleton)"), "", "Frequency of importation events", 
                       # legend_ = function(x) ifelse(nchar(x) > 10, substr(x, 1, 10), x))
      

      clusterFirstCasesWithSingles <-
         clusterSamplesMCC %>% filter(
               abs(.data[["oldest_calendar"]] - sample_date) < 1 / 366 + firstCaseDistance / 366
         )
      clusterFirstCasesCount <-
         clusterFirstCasesWithSingles %>% group_by(cluster) %>% dplyr::summarise(cluster.first.case.count = n())
      clusterFirstCasesWithSingles <-
         clusterFirstCasesWithSingles %>% left_join(clusterFirstCasesCount, by = c("cluster" = "cluster"))
      clusterFirstCaseByCountyWithSingles <-
         clusterFirstCasesWithSingles %>%
         mutate(tmrca.break.index = sapply(tmrca_shifted_calendar, function(x) which.max(x < tmrcaBreaks) - 1)) %>%
         group_by(adm1, tmrca.break.index) %>%
         dplyr::summarise(n = sum(1 / cluster.first.case.count)) %>%
         mutate(p =  round(n / sum(n) * 100, digits = 1)) %>% arrange(desc(n))

      
   par(mar = c(4, 6, 1, 10))
   adm1List <- levels(factor((clusterFirstCaseByCounty %>% dplyr::select(adm1))$adm1))
   for (adm1_ in adm1List) {

     # plot_weekly_table(clusterFirstCaseByCounty %>% filter(adm1 == adm1_), "adm1", dePal,
      #                  paste("Transmission lineage of states", "(no singleton)", adm1_), "C", "importation",
       #                 legend_ = function(x) ifelse(nchar(x) > 10, substr(x, 1, 10), x))

      plot_weekly_table(clusterFirstCaseByCountyWithSingles %>% filter(adm1 == adm1_), "adm1", sdePal,
                        # paste("Importation events of state ", adm1_ , "(+single)"), 
                        "", 
                        "", 
                        "Frequency of \n importation events",
                        legend_ = function(x) ifelse(nchar(x) > 10, substr(x, 1, 10), x), 
                     legend.position = "topleft",
                     legend.inset = c(0, -0.2), legend.ncol = 1,
                     # legend.map = TRUE, 
                     legend.map.color = sdePal, legend.map.viewport = c(2,25,5,1))

      print(kable(clusterFirstCasesWithSingles %>% filter(adm1 == adm1_) %>% arrange(tmrca_shifted_calendar) %>% dplyr::select(cluster, tmrca_shifted_calendar), caption = paste("clusters+single sorted by importation for", adm1_) ))

   }

```



```{r importation-state-specific-01, fig.width=7, fig.height=3, eval=TRUE}

   par(mar = c(6, 5, 1, 10))
   plot_weekly_table(clusterFirstCaseByCountyWithSingles %>%
                        mutate(adm1 = ifelse(adm1 %in% c("North Rhine-Westphalia", "Bavaria", "Baden-Wurttemberg"), adm1, "Other")) %>% 
                        group_by(adm1, tmrca.break.index) %>% dplyr::summarise(n = sum(n)), "adm1", 
                     sdePal, 
                     NULL, # paste("A) Imp. events of states", "+single"), 
                     "A", "Number of importations\n(per week)",
                     # legend_ = function(x) ifelse(x %in% names(stateNameShort), stateNameShort[x], x),
                     # legend_ = function(x) ifelse(nchar(x) > 10, substr(x, 1, 10), x),
                     ordering_  = c("North Rhine-Westphalia", "Bavaria", "Baden-Wurttemberg", "Other"), 
                     legend.position = "topright",
                     legend.inset = c(-0.45, 0), legend.ncol = 1,
                     legend.map = TRUE, legend.map.color = sdePal, legend.map.viewport = c(2,25,5,1), printTable_ = FALSE, ymax=35)

   abline(v=sapply(c(as.Date("2021-01-02"), as.Date("2021-04-06")), function(x) {i = which.max(x < tmrcaBreaks) - 1; return (i- as.numeric(tmrcaBreaks[i+1] - x)/as.numeric(tmrcaBreaks[i+1] - tmrcaBreaks[i])); }), col="red", lty=2, lwd=1)
   mtext('2020', side=1, line = 3.8, at=1, las=1, col="darkgray")
   mtext('2021', side=1, line = 3.8, at=21, las=1, col="darkgray")

   pal <- sdePal
   pal[] <- sdePal$Germany
   plot_weekly_table(clusterFirstCaseByCountyWithSingles %>% mutate(country = "Germany") %>% group_by(country, tmrca.break.index) %>% dplyr::summarise(n=sum(n)),
                        "country", 
                     sdePal, 
                     NULL, # paste("A) Imp. events of states", "+single"), 
                     "A", "Number of importations\n(per week)",
                     # legend_ = function(x) ifelse(x %in% names(stateNameShort), stateNameShort[x], x),
                     # legend_ = function(x) ifelse(nchar(x) > 10, substr(x, 1, 10), x),
                     # ordering_  = c("North Rhine-Westphalia", "Bavaria", "Baden-Wurttemberg", "Other"), 
                     legend.position = "topright",
                     legend.inset = c(-0.30, 0), legend.ncol = 1,
                     legend.map = TRUE, legend.map.color = pal, legend.map.viewport = c(2,25,5,1))
   abline(v=sapply(c(as.Date("2021-01-02"), as.Date("2021-04-06")), function(x) {i = which.max(x < tmrcaBreaks) - 1; return (i- as.numeric(tmrcaBreaks[i+1] - x)/as.numeric(tmrcaBreaks[i+1] - tmrcaBreaks[i])); }), col="red", lty=2, lwd=1)
   mtext('2020', side=1, line = 3.8, at=1, las=1, col="darkgray")
   mtext('2021', side=1, line = 3.8, at=21, las=1, col="darkgray")
   
   plot_weekly_table(clusterFirstCaseByCountyWithSingles, "adm1", 
                  dePal, 
                  NULL, # paste("A) Imp. events of states", "+single"), 
                  "A''", "Number of of importations\n(per week)",
                  # legend_ = function(x) ifelse(x %in% names(stateNameShort), stateNameShort[x], x),
                  # legend_ = function(x) ifelse(nchar(x) > 10, substr(x, 1, 10), x),
                  # ordering_  = c("North Rhine-Westphalia", "Bavaria", "Baden-Wurttemberg", "Other"), 
                  legend_ = function(x) shortStateName[x],
                  legend.position = "topright",
                  legend.inset = c(-0.45, 0), legend.ncol = 3,
                  legend.map = TRUE, legend.map.color = dePal, legend.map.viewport = c(2,25,6,1))
   
   abline(v=sapply(c(as.Date("2021-01-02"), as.Date("2021-04-06")), function(x) {i = which.max(x < tmrcaBreaks) - 1; return (i- as.numeric(tmrcaBreaks[i+1] - x)/as.numeric(tmrcaBreaks[i+1] - tmrcaBreaks[i])); }), col="red", lty=2, lwd=1)
   mtext('2020', side=1, line = 3.8, at=1, las=1, col="darkgray")
   mtext('2021', side=1, line = 3.8, at=21, las=1, col="darkgray")
      
      clusterFirstCaseByCountyWithSinglesByTMRCA <-
         clusterFirstCasesWithSingles %>%
         mutate(tmrca.break.index = sapply(tmrca_calendar, function(x) which.max(x < tmrcaBreaks) - 1)) %>%
         group_by(adm1, tmrca.break.index) %>%
         dplyr::summarise(n = sum(1 / cluster.first.case.count)) %>%
         mutate(p =  round(n / sum(n) * 100, digits = 1)) %>% arrange(desc(n))

   # par(mar = c(4, 6, 1, 10))
   plot_weekly_table(clusterFirstCaseByCountyWithSinglesByTMRCA %>%
                        mutate(adm1 = ifelse(adm1 %in% c("North Rhine-Westphalia", "Bavaria", "Baden-Wurttemberg"), adm1, "Other")) %>% 
                        group_by(adm1, tmrca.break.index) %>% dplyr::summarise(n = sum(n)), "adm1", 
                     sdePal, 
                     NULL, # paste("A) Imp. events of states", "+single"), 
                     "A'", "Number of TMRCA\n(per week)",
                     # legend_ = function(x) ifelse(x %in% names(stateNameShort), stateNameShort[x], x),
                     # legend_ = function(x) ifelse(nchar(x) > 10, substr(x, 1, 10), x),
                     ordering_  = c("North Rhine-Westphalia", "Bavaria", "Baden-Wurttemberg", "Other"), 
                     legend.position = "topright",
                     legend.inset = c(-0.45, 0), legend.ncol = 1,
                     legend.map = TRUE, legend.map.color = sdePal, legend.map.viewport = c(2,25,5,1))
   abline(v=sapply(c(as.Date("2021-01-02"), as.Date("2021-04-06")), function(x) {i = which.max(x < tmrcaBreaks) - 1; return (i- as.numeric(tmrcaBreaks[i+1] - x)/as.numeric(tmrcaBreaks[i+1] - tmrcaBreaks[i])); }), col="red", lty=2, lwd=1)
   mtext('2020', side=1, line = 3.8, at=1, las=1, col="darkgray")
   mtext('2021', side=1, line = 3.8, at=21, las=1, col="darkgray")

   plot_weekly_table(clusterFirstCaseByCountyWithSinglesByTMRCA  %>% mutate(country = "Germany") %>% 
                        group_by(country, tmrca.break.index) %>% dplyr::summarise(n=sum(n)),
                        "country", 
                     sdePal, 
                     NULL, # paste("A) Imp. events of states", "+single"), 
                     "A'", "Number of TMRCA\n(per week)",
                     # legend_ = function(x) ifelse(x %in% names(stateNameShort), stateNameShort[x], x),
                     # legend_ = function(x) ifelse(nchar(x) > 10, substr(x, 1, 10), x),
                     # ordering_  = c("North Rhine-Westphalia", "Bavaria", "Baden-Wurttemberg", "Other"), 
                     legend.position = "topright",
                     legend.inset = c(-0.30, 0), legend.ncol = 1,
                     legend.map = TRUE, legend.map.color = pal, legend.map.viewport = c(2,25,5,1))
   abline(v=sapply(c(as.Date("2021-01-02"), as.Date("2021-04-06")), function(x) {i = which.max(x < tmrcaBreaks) - 1; return (i- as.numeric(tmrcaBreaks[i+1] - x)/as.numeric(tmrcaBreaks[i+1] - tmrcaBreaks[i])); }), col="red", lty=2, lwd=1)
   mtext('2020', side=1, line = 3.8, at=1, las=1, col="darkgray")
   mtext('2021', side=1, line = 3.8, at=21, las=1, col="darkgray")
      
   plot_weekly_table(clusterFirstCaseByCountyWithSinglesByTMRCA, "adm1", 
                     dePal, 
                     NULL, # paste("A) Imp. events of states", "+single"), 
                     "A'''", "Number of TMRCA\n(per week)",
                     legend_ = function(x) shortStateName[x],
                     legend.position = "topright",
                     legend.inset = c(-0.45, 0), legend.ncol = 3,
                     legend.map = TRUE, legend.map.color = dePal, legend.map.viewport = c(2,25,6,1))
   abline(v=sapply(c(as.Date("2021-01-02"), as.Date("2021-04-06")), function(x) {i = which.max(x < tmrcaBreaks) - 1; return (i- as.numeric(tmrcaBreaks[i+1] - x)/as.numeric(tmrcaBreaks[i+1] - tmrcaBreaks[i])); }), col="red", lty=2, lwd=1)
   mtext('2020', side=1, line = 3.8, at=1, las=1, col="darkgray")
   mtext('2021', side=1, line = 3.8, at=21, las=1, col="darkgray")
   

```

```{r MPI-effectiveness-no-singleton-shift, fig.width=6, fig.height=3}

MPI.effectiveness.all <- list()
# case ratio
MPI.effectiveness.all[["case ratio"]] <- matrix(c(10,7,4,3,
4.5,4,0,10.5,
3.5,2,0,5,
7,4,10,0,
5,5,4,11,
2,6,7,2,
3,7,2,29,
10,6,4,5,
6,12,3,8,
11,0,11,3,
7,4,9,6,
5,4,2,13,
4,3,2,12), nrow = 4)


# equal
MPI.effectiveness.all[["equal"]] <- matrix(c(8.5,4.5,2,3,
2,1,2,6,
0,1,3,4,
2.5,8,3,10,
7.5,4,0,5.5,
7.5,2,5.5,6,
2.8,5,2,8,
19.4,6.4,12,6.2,
4,3,0,0,
3,1,3,14,
6,0,3,6,
11,2,0,2,
1,1,4,11), nrow = 4)

# 25-100
MPI.effectiveness.all[["25-100"]] <- matrix(c(15,3,0,1,
0,12,4,8,
5,1,0,4.5,
2,13,1,4.5,
12,5,4,0,
9,3,4,7,
9.8,6.3,12,24.4,
12.4,2.4,15,5.2,
3,7.3,2,0,
9,7,5,13,
8,6,3,29,
11,4,0,4,
5,3,2,6), nrow = 4)

library(ggnewscale)


for (MPI.effectiveness.name in names(MPI.effectiveness.all)) {
  MPI.effectiveness <- MPI.effectiveness.all[[MPI.effectiveness.name]]
  cat(paste("Figure", MPI.effectiveness.name))
  colnames(MPI.effectiveness) <- c("N1","N2","N3","N4","N5","N6","N7","N8","N9","N10","N11","N12","N13")
  rownames(MPI.effectiveness) <- c("NRW", "Bavaria", "Baden Wurttemberg", "Others")
  
  MPI.type <- data.frame(MPI=c("N1" , "N2" , "N3" , "N4" , "N5" , "N6" , "N7" , "N8" , "N9" , "N10", "N11", "N12", "N13"), type=factor(c("multifunction", "multifunction", "border", "multifunction", "multifunction", "border", "multifunction", "border", "border", "border", "freetest", "border", "border"), levels=c("multifunction", "border", "freetest")))
  
  data <- MPI.effectiveness %>% data.frame() %>% mutate(state = c("NRW", "Bavaria", "Baden Wurttemberg", "Others")) %>% gather(MPI, effectiveness, -state) %>% left_join(MPI.type)
  
  MPIPal <- list("N1" = "#d7191c", "N2" = "#d7191c", "N3" = "#fdae61", "N4" = "#d7191c", "N5" = "#d7191c", "N6" = "#fdae61", "N7" = "#d7191c",
                 "N8" = "#fdae61", "N9" = "#fdae61", "N10" = "#fdae61", "N11" = "#2b83ba", "N12" = "#fdae61", "N13" = "#fdae61")
  
  p <- ggplot(data = data, aes(x=reorder(MPI, as.numeric(sub('.', '', MPI)), color=type), y=effectiveness)) + 
     # geom_violin(aes(color=MPI, fill = MPI), draw_quantiles = c(0.25, 0.5, 0.75), scale=2) + 
     # stat_summary(fun = "mean", geom = "crossbar", width = 0.5, color = "red") + 
     scale_color_manual(name = "State", values = c(sdePal[["North Rhine-Westphalia"]], sdePal[["Bavaria"]], sdePal[["Baden-Wurttemberg"]], sdePal[["Other"]]), labels = c("NRW", "Bavaria", "Baden Wurttemberg", "Others")) +
     geom_point(aes(color=state), size=3, alpha=1.0) +
     # scale_color_manual(values = as.vector(MPIPal), labels = names(MPIPal)) +
     new_scale_color() +
     scale_color_manual(name = "Category", values = c("#d7191c", "#fdae61", "#2b83ba"), labels = c("Multifunction", "Border control", "Free test")) +
     # scale_fill_manual(values = lighten(unlist(MPIPal), 0.5), labels = names(MPIPal)) + 
     labs(x = "NPI", y = "Effectiveness") + 
     # guides(color=guide_legend(ncol=2)) + 
     # geom_boxplot2(alpha=0.7, aes(color=MPI, fill = MPI), width = 0.8, width.errorbar = 0.5) + 
     theme_linedraw() + 
     # theme(legend.title.align=0.5)
     stat_summary(aes(color=type), fun.data = "mean_se", geom = "crossbar", width = 0.3) 
     # stat_summary(aes(color=type), fun.data = "mean_cl_boot") +
     # stat_summary(fun = mean, geom = "point", fun.min = mean, fun.max = mean, width = 0.3)
     # stat_summary(aes(color=type), fun = mean, geom = "point", size = 2)
  print(p)

}


```

```{r MPI-effectiveness-singleton-shift, fig.width=6, fig.height=3}

library(wesanderson)
library(RColorBrewer)

MPI.effectiveness.all <- list()
# case ratio
MPI.effectiveness.all[["case ratio"]] <- matrix(c(
  17, 10, 8, 4, 3,
10, 4.5, 6, 0, 8,
7, 3.5, 2, 0, 6,
13, 7, 4, 11, 0,
15, 5, 6, 4, 12,
6, 2, 6, 7, 1,
38, 3, 7, 4, 33,
14, 11, 6, 3, 3,
10, 5, 9, 3, 10,
14, 9, 1, 9, 4, 
20, 7, 4, 7, 12,
7, 4, 4, 2, 3,
8, 2, 3, 2, 10
  ), nrow = 5)

library(ggnewscale)

pal = c("Baden Wurttemberg"="#1f78b4", "Bavaria"="#33a02c", "Germany"="#e41a1c", "NRW"="#542788", "NW+BY+BW"=dePal$Saarland, "Others"=dePal$oth)

for (MPI.effectiveness.name in names(MPI.effectiveness.all)) {
  MPI.effectiveness <- MPI.effectiveness.all[[MPI.effectiveness.name]]
  cat(paste("Figure", MPI.effectiveness.name))
  colnames(MPI.effectiveness) <- c("N1","N2","N3","N4","N5","N6","N7","N8","N9","N10","N11","N12","N13")
  rownames(MPI.effectiveness) <- c("Germany", "NRW", "Bavaria", "Baden Wurttemberg", "Others")
  
  MPI.type <- data.frame(MPI=c("N1" , "N2" , "N3" , "N4" , "N5" , "N6" , "N7" , "N8" , "N9" , "N10", "N11", "N12", "N13"), type=factor(c("multifunction", "multifunction", "border", "multifunction", "multifunction", "border", "multifunction", "border", "border", "border", "freetest", "border", "border"), levels=c("multifunction", "border", "freetest")))
  
  layer_to_str <- c("1"="Basic", "2"="Some", "3"="All")
  state.to.display <- c("Germany"="Germany", "NRW"="NRW", "Bavaria"="Bavaria", "Baden Wurttemberg"="BW", "Others"="Other 13 states")
  
  data <- MPI.effectiveness %>% data.frame() %>% mutate(state = c("Germany", "NRW", "Bavaria", "Baden Wurttemberg", "Others")) %>% gather(MPI, effectiveness, -state) %>% left_join(MPI.type) 
  
  data <- data %>% filter(state %in% c("NRW", "Bavaria", "Baden Wurttemberg")) %>% group_by(MPI) %>% dplyr::summarise(effectiveness = mean(effectiveness), type = first(type), state = "NW+BY+BW", layer = 2) %>% rbind(data %>% mutate(layer = if_else(state %in% c("Germany"), 3, if_else(state %in% c("Others"), 2, 1)))) %>% mutate(layer = layer_to_str[layer]) %>% mutate(state.display = state.to.display[state]) %>% filter(state != "NW+BY+BW")
  
  data$state <- factor(data$state, levels = names(state.to.display))
  data$MPI <- reorder(data$MPI, as.numeric(sub('.', '', data$MPI)), color=type)
  data$state.display <- factor(data$state.display, levels = unname(state.to.display))
  
  MPIPal <- list("N1" = "#d7191c", "N2" = "#d7191c", "N3" = "#fdae61", "N4" = "#d7191c", "N5" = "#d7191c", "N6" = "#fdae61", "N7" = "#d7191c",
                 "N8" = "#fdae61", "N9" = "#fdae61", "N10" = "#fdae61", "N11" = "#2b83ba", "N12" = "#fdae61", "N13" = "#fdae61")
  
  p <- ggplot(data, aes(x=reorder(MPI, as.numeric(sub('.', '', MPI)), color=type), y=effectiveness, color = state.display, shape = state.display)) + 
     geom_point(size=3) +
     # geom_point(data = . %>% filter(state %in% c("NRW", "Bavaria", "Baden Wurttemberg")), shape=17, size=3, alpha=1.0) +
     # geom_point(data = . %>% filter(state %in% c("Others")), shape=19, size=3, alpha=1.0) +
     # geom_point(data = . %>% filter(state %in% c("Germany")), shape=15, size=3, alpha=1.0) +
     # scale_color_manual(name = "State", values = pal[levels(data$state)]) + #, labels = levels(data$state)) +
     scale_color_manual(name = "", values = brewer.pal(n=5, name = "Set1"), labels = unname(state.to.display)) + 
     scale_shape_manual(name = "", values = c(15, 17, 17, 17, 19), labels = unname(state.to.display)) + 
     labs(x = "NPI", y = "Effectiveness") + 
     theme_bw() + # guides(shape = "none") + 
     theme(panel.grid.major.y = element_line(linewidth=0, color="black"), panel.grid.minor.y = element_line(linewidth = 0))
  print(p)

  data2 <- data %>% left_join(data %>% group_by(state) %>% dplyr::summarise(effectiveness.max = max(effectiveness)), by="state") %>% mutate(effectiveness.norm = effectiveness / effectiveness.max)
  p <- ggplot(data = data2, aes(x=reorder(MPI, as.numeric(sub('.', '', MPI)), color=type), y=effectiveness.norm)) + 
     geom_point(data = data2 %>% filter(state %in% c("NRW", "Bavaria", "Baden Wurttemberg")), aes(color=state), shape=4, size=3, alpha=1.0) +
     geom_point(data = data2 %>% filter(state %in% c("Others")), aes(color=state), shape=19, size=3, alpha=1.0) +
     geom_point(data = data2 %>% filter(state %in% c("Germany")), aes(color=state), shape=15, size=3, alpha=1.0) +
     scale_color_manual(name = "", values = pal[levels(data$state)]) + #, labels = levels(data$state)) +
     labs(x = "NPI", y = "Effectiveness Normalized") + 
     theme_bw() + guides(shape = "none") + 
     theme(panel.grid.major.y = element_line( linewidth=0, color="black"), panel.grid.minor.y = element_line(linewidth = 0))
  print(p)

  
  p <- ggplot(data %>% filter(state %in% c("NRW", "Bavaria", "Baden Wurttemberg")), aes(x=reorder(MPI, as.numeric(sub('.', '', MPI)), color=type), y=effectiveness)) + 
     geom_point(aes(color=state, shape=layer), size=3, alpha=1.0) +
     new_scale_color() +
     labs(x = "NPI", y = "Effectiveness") + 
    theme_bw() + guides(shape = "none") + 
    theme(panel.grid.major.y = element_line( linewidth=0, color="black"), panel.grid.minor.y = element_line(linewidth = 0)) + 
     stat_summary(aes(color=type), fun.data = "mean_se", geom = "crossbar", width = 0.3)
  print(p)

  
  
  p <- ggplot(data %>% filter(state %in% c("Germany")), aes(x=reorder(MPI, as.numeric(sub('.', '', MPI)), color=type), y=effectiveness)) + 
     geom_point(aes(color=state, shape=layer), size=3, alpha=1.0) +
     new_scale_color() +
     labs(x = "NPI", y = "Effectiveness") + 
    theme_bw() + guides(shape = "none") + 
    theme(panel.grid.major.y = element_line( linewidth=0, color="black"), panel.grid.minor.y = element_line(linewidth = 0)) 
  print(p)

}


```

```{r inter-state-movement, fig.width=7, fig.height=8}

   clusterSamplesMCC$adm1 <- ifelse(clusterSamplesMCC$adm1 == "Baden-Württemberg", "Baden-Wurttemberg", clusterSamplesMCC$adm1)
    library(lubridate)
    library(plyr)
    library(gplots)
    library(beastio)
    library(knitr)
    library(tictoc)
    library(stringr)
    library(tidyr)
    source("../reports/palettes.R")
    source("../reports/plotutils.R")
    source("../reports/clusterutils.R")
    source("../reports/reportutils.R")
    library(shape)
    library(dplyr)
    library(colorspace)

    library(gridBase)
    library(grid)

data <- clusterSamplesMCC %>% group_by(adm1, cluster) %>% dplyr::summarise(Collection.date = min(Collection.date)) %>% filter(adm1 != "NA") %>% ungroup()
data2 <- data %>% left_join(data, by=c("cluster")) %>% filter(Collection.date.x <= Collection.date.y) %>% group_by(adm1.x, adm1.y) %>% dplyr::summarise(n = n()) %>% ungroup()
# data2 = adm1.x to adm1.y 
p <- ggplot(data2, aes(adm1.x, adm1.y, fill=n)) + geom_tile() + geom_text(aes(label = round(n, 1))) + scale_fill_gradient(low = "white", high = "red") + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))
print(p)

library(GGally)
# devtools::install_github("briatte/ggnet")
library(ggnet)

library(network)
library(sna)
library(ggplot2)

net = network(data2 %>% filter(n > 2) %>% mutate(n = n/5), directed = TRUE, loops = TRUE)

ggnet2(net, edge.size="n", label = TRUE, arrow.size = 12, arrow.gap = 0.025)

kable(data2 %>% group_by(adm1.y) %>% arrange(-n, .by_group = TRUE) %>% dplyr::summarise(text =paste(adm1.x, paste0("(", n, ")"), collapse = ", ")), caption = "Number of importations to each state (row) from different source states.")

data3 <- data2 %>% tidyr::pivot_wider(names_from = adm1.y, values_from = n, values_fill = 0) %>% ungroup()
data4 <- as.matrix(data3 %>% dplyr::select(-adm1.x))
rownames(data4) <- data3$adm1.x
data4 <- data4[rownames(data4), rownames(data4)]

heatmap.2(data4, trace="none", col=colorpanel(max(data4), low="white", high = "red"), cellnote = data4, notecol = "black", xlab = "Destination", ylab="Source")

kable(matrix(paste(data4, t(data4), sep=","), nrow(data4), nrow(data4)) %>% `rownames<-`(rownames(data4))  %>% `colnames<-`(rownames(data4)), caption="first number = row->col, second number=col->row")

# lowerSaxonyClusters <- clusterSamplesMCC %>% filter(adm1 == "Lower Saxony") %>% pull(cluster) %>% as.factor() %>% levels()
# clusterSamplesMCC %>% filter(lineage_seqs >1, cluster %in% lowerSaxonyClusters) %>% group_by(cluster) %>% filter(Collection.date == min(Collection.date)) %>% ungroup() %>% dplyr::select(adm1, Collection.date, cluster) %>% data.frame() %>% group_by(adm1) %>% dplyr::summarise(n = n()) %>% arrange(n)

stateLineageCount <- clusterSamplesMCC %>% group_by(adm1) %>% dplyr::summarise(n = n_distinct(cluster)) %>% filter(adm1 != "NA") %>% arrange(n)
stateLineageCountMap <- c()
stateLineageCountMap[match(stateLineageCount$adm1, colnames(data4))] <- stateLineageCount$n
names(stateLineageCountMap) <- colnames(data4)

kable(round(data4 / stateLineageCountMap[col(data4)] * 100, 2), caption = "percentages of row to column movement of lineage divided by number of lineages in destination")
data5 <- apply(data4 / stateLineageCountMap[col(data4)], c(1,2), function(x) ifelse(x < 0.30, 0, x))
diag(data5) <- 0
heatmap.2(data5, trace="none", col=colorpanel(max(data4), low="white", high = "red"), cellnote = round(data5 * 100, 0), notecol = "black", xlab = "Destination", ylab="Source")

stateLineageCountNoSingletone <- clusterSamplesMCC %>% filter(lineage_seqs > 1) %>% group_by(adm1) %>% dplyr::summarise(n = n_distinct(cluster)) %>% filter(adm1 != "NA") %>% arrange(n)
stateLineageCountNoSingletoneMap <- c()
stateLineageCountNoSingletoneMap[match(stateLineageCountNoSingletone$adm1, colnames(data4))] <- stateLineageCountNoSingletone$n
names(stateLineageCountNoSingletoneMap) <- colnames(data4)

kable(round(data4 / stateLineageCountNoSingletoneMap[col(data4)] * 100, 2), caption = "percentages of row to column movement of lineage divided by number of lineages in destination")
# data5 <- apply(data4 / stateLineageCountNoSingletoneMap[col(data4)], c(1,2), function(x) ifelse(x < 0.30, 0, x))
data5 <- apply(data4 / stateLineageCountNoSingletoneMap[col(data4)], c(1,2), function(x) ifelse(x < 0, 0, x))
diag(data5) <- 0
heatmap.2(data5, trace="none", col=colorpanel(max(data4), low="white", high = "red"), cellnote = round(data5 * 100, 0), notecol = "black", xlab = "Destination", ylab="Source")



```

```{r, fig.width=10, fig.height=8}
library(ggalluvial)
ggplot(data2 %>% filter(adm1.x != adm1.y) %>% filter(adm1.x %in% c("Baden-Wurttemberg", "Bavaria", "Bavaria", "Lower Saxony", "North Rhine-Westphalia", "Saxony")) 
       # %>% mutate(adm1.x2 = NA) %>% union(data2 %>% dplyr::rename(adm1.x2 = adm1.x) %>% mutate(adm1.x = NA))
       ,
       aes(y = n, axis1 = adm1.x, axis2 = adm1.y)) +
  geom_alluvium(aes(fill = adm1.x), width = 1/12) +
  geom_stratum(width = 1/12, fill = "black", color = "grey") +
  geom_label(stat = "stratum", aes(label = after_stat(stratum))) +
  scale_x_discrete(limits = c("adm1.x", "adm1.y"), expand = c(.05, .05)) +
  # scale_fill_brewer(type = "qual", palette = "Set1") +
  # scale_fill_identity(values = unlist(dePal)) +
  ggtitle("Number of importations to each state (row) from different source states.")

ggplot(data2 %>% filter(adm1.x != adm1.y) %>% filter(adm1.y %in% c("Baden-Wurttemberg", "Bavaria", "Bavaria", "Lower Saxony", "North Rhine-Westphalia", "Saxony"), !(adm1.x %in% c("Baden-Wurttemberg", "Bavaria", "Bavaria", "Lower Saxony", "North Rhine-Westphalia", "Saxony"))) 
       # %>% mutate(adm1.x2 = NA) %>% union(data2 %>% dplyr::rename(adm1.x2 = adm1.x) %>% mutate(adm1.x = NA))
       ,
       aes(y = n, axis1 = adm1.x, axis2 = adm1.y)) +
  geom_alluvium(aes(fill = adm1.x), width = 1/12) +
  geom_stratum(width = 1/12, fill = "black", color = "grey") +
  geom_label(stat = "stratum", aes(label = after_stat(stratum))) +
  scale_x_discrete(limits = c("adm1.x", "adm1.y"), expand = c(.05, .05)) +
  # ylim(0, 400) + 
  # scale_fill_brewer(type = "qual", palette = "Set1") +
  # scale_fill_identity(values = unlist(dePal)) +
  ggtitle("Number of importations to each state (row) from different source states.")


ggplot(data2 %>% filter(adm1.x != adm1.y)
       # %>% mutate(adm1.x2 = NA) %>% union(data2 %>% dplyr::rename(adm1.x2 = adm1.x) %>% mutate(adm1.x = NA))
       ,
       aes(y = n, axis1 = adm1.x, axis2 = adm1.y)) +
  geom_alluvium(aes(fill = adm1.x), width = 1/12) +
  geom_stratum(width = 1/12, alpha = .1) +
  geom_text(stat = "stratum", aes(label = after_stat(stratum)), angle = 0, color="black", size=3, hjust = 0.5) +
  scale_x_discrete(limits = c("adm1.x", "adm1.y"), expand = c(.05, .05)) +
  xlim(0.9, 2.1) +
  guides(fill=guide_legend(title="Source")) +
  # scale_fill_brewer(type = "qual", palette = "Set1") +
  # scale_fill_identity(values = unlist(dePal)) +
  ggtitle("Number of importations to each state from different source states.") + theme_bw() + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), axis.title.x=element_blank(), axis.text.x=element_blank(), axis.ticks.x=element_blank())



ggplot(data2 %>% filter(adm1.x != adm1.y) %>% left_join(stateLineageCount %>% dplyr::rename(adm1.y.lincount = n), by=c("adm1.y" = "adm1")) %>% mutate(n.ratio = n/adm1.y.lincount) %>% filter(n >= 5, n.ratio >= 0.10) 
       # %>% mutate(adm1.x2 = NA) %>% union(data2 %>% dplyr::rename(adm1.x2 = adm1.x) %>% mutate(adm1.x = NA))
       ,
       aes(y = n, axis1 = adm1.x, axis2 = adm1.y)) +
  geom_alluvium(aes(fill = adm1.x), width = 1/12) +
  geom_stratum(width = 1/12, alpha = .1) +
  geom_text(stat = "stratum", aes(label = after_stat(stratum)), angle = 0, color="black", size=3, hjust = 0.5) +
  scale_x_discrete(limits = c("adm1.x", "adm1.y"), expand = c(.05, .05)) +
  xlim(0.9, 2.1) +
  guides(fill=guide_legend(title="Source")) +
  # scale_fill_brewer(type = "qual", palette = "Set1") +
  # scale_fill_identity(values = unlist(dePal)) +
  ggtitle("Number of importations to each state (row) from different source states. (n>=5, dest-ratio>=10%)") + theme_bw() + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), axis.title.x=element_blank(), axis.text.x=element_blank(), axis.ticks.x=element_blank())



```

```{r}

net = network(data5 %>% as.data.frame() %>% tibble::rownames_to_column("src") %>% pivot_longer(!src, names_to = "dst", values_to = "move") %>% filter(move >= 0.2), directed = TRUE, loops = TRUE)

ggnet2(net, edge.size="move", label = TRUE, arrow.size = 12, arrow.gap = 0.025)

# TODO 

```
```{r}
library(RColorBrewer)

geom.center <- function(x) {
  return((max(x) + min(x))/2)
}
germany.germany.f <- calculate.germany.germany.f()
germany.f <- germany.germany.f$germany.f
germany <- germany.germany.f$germany
data(world.cities)


# legend drawing function, copied from ggplot2
draw_key_segment_custom <- function(data, params, size) {
  if (is.null(data$linetype)) {
    data$linetype <- 0
  } else {
    data$linetype[is.na(data$linetype)] <- 0
  }

  segmentsGrob(0.1, 0.5, 0.9, 0.5,
    gp = gpar(
      # col = alpha(data$colour %||% data$fill %||% "black", data$alpha),
      col = data$colour,
      # the following line was added relative to the ggplot2 code
      # fill = alpha(data$colour %||% data$fill %||% "black", data$alpha),
      fill = data$colour,
      # lwd = (data$size %||% 0.5) * .pt,
      lwd = 0.5 * .pt,
      # lty = data$linetype %||% 1,
      lty = 1,
      lineend = "round"
    ),
    # arrow = params$arrow
    arrow = arrow(length = unit(0.2, "cm"), angle=30, type = "closed", end="first")
  )
}



# germany.state.centers <- data.frame(state = c("Baden-Wurttemberg", "Bavaria", "Berlin", "Brandenburg", "Bremen", "Hamburg", "Hesse", "Lower Saxony", "Mecklenburg-Western Pomerania", "North Rhine-Westphalia", "Rhineland-Palatinate", "Saarland", "Saxony", "Saxony-Anhalt", "Schleswig-Holstein", "Thuringia"), center=c("Stuttgart", "Munich", "Berlin", "Potsdam", "Bremen", "Hamburg", "Wiesbaden", "Hanover", "Schwerin", "Dusseldorf", "Mainz", "Saarbrucken", "Dresden", "Magdeburg", "Kiel", "Erfurt")) %>% left_join(world.cities %>% filter(country.etc == "Germany"), by=c("center"="name")) %>% mutate(long=ifelse(state == "Hesse", 9.16, long))
germany.state.centers<-data.frame(	lat=c(48.66,48.79,52.52181866,52.41,53.0793,53.55002464,50.65,53.61,52.63,51.43,50.11,49.39,51,52.2,54,50.7), 	long=c(9.35,11.49,13.40154862,12.53,8.8017,9.999999144,9.16,12.42,9.8,7.66,7.3,7.02,13,11.69,9.56,11.02996212), 	state=c("Baden-Wurttemberg","Bavaria","Berlin","Brandenburg","Bremen","Hamburg","Hesse","Mecklenburg-Western Pomerania","Lower Saxony","North Rhine-Westphalia","Rhineland-Palatinate","Saarland","Saxony","Saxony-Anhalt","Schleswig-Holstein","Thuringia")	)

# germany.state.grography <- germany.f %>% filter(hole == FALSE) %>% group_by(id, value) %>% summarise(long = geom.center(long), lat = geom.center(lat))
germany.state.grography <- germany.state.centers %>% rename(value = state) %>% left_join(germany.f %>% dplyr::group_by(id, value) %>% summarise())
germany.f$value <- germany$NAME_1_EN[match(germany.f$id, germany$CC_1)]

# data6 <- data5 %>% as.data.frame() %>% tibble::rownames_to_column("src") %>% pivot_longer(!src, names_to = "dst", values_to = "move") %>% filter(move >= 0.3) %>% left_join(germany.state.grography %>% dplyr::rename(src.id = id, src.lat = lat, src.long = long), by=c("src"="value")) %>% left_join(germany.state.grography %>% dplyr::rename(dst.id = id, dst.lat = lat, dst.long = long), by=c("dst"="value"))
map.edge.info <- data.frame(
src=c("Baden-Wurttemberg", "Baden-Wurttemberg", "Bavaria", "Bavaria", "Bavaria", "Bavaria", "North Rhine-Westphalia", "North Rhine-Westphalia", "Saxony", "Saxony", "Baden-Wurttemberg", "Baden-Wurttemberg", "Baden-Wurttemberg", "Bavaria", "Bavaria", "Bavaria", "Lower Saxony", "North Rhine-Westphalia", "North Rhine-Westphalia", "North Rhine-Westphalia", "North Rhine-Westphalia", "North Rhine-Westphalia", "North Rhine-Westphalia", "North Rhine-Westphalia", "North Rhine-Westphalia", "North Rhine-Westphalia", "Rhineland-Palatinate", "Saxony", "Saxony", "Saxony", "Thuringia", "Thuringia", "Thuringia"),	dst=c("Berlin", "Saxony", "Baden-Wurttemberg", "Rhineland-Palatinate", "Saxony", "Thuringia", "Saarland", "Saxony", "Baden-Wurttemberg", "Thuringia", "Hesse", "Rhineland-Palatinate", "Saxony-Anhalt", "Berlin", "Hamburg", "Saxony-Anhalt", "Hamburg", "Baden-Wurttemberg", "Berlin", "Hamburg", "Hesse", "Lower Saxony", "Rhineland-Palatinate", "Saxony-Anhalt", "Schleswig-Holstein", "Thuringia", "Hesse", "Hesse", "Rhineland-Palatinate", "Saxony-Anhalt", "Berlin", "Rhineland-Palatinate", "Saxony-Anhalt"),	curvature=c(0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, -0.1, 0.1, 0.1, 0, 0, 0.2, 0.5, 1.1, 0.8, 0, 1, -0.1, -0.5, 0, -0.5, 0, 0, -0.5, 0, 0.5, -0.2, -0.3, -0.4, 0, 0.2, 0)
)

data6 <- data2 %>% filter(adm1.x != adm1.y) %>% left_join(stateLineageCount %>% dplyr::rename(adm1.y.lincount = n), by=c("adm1.y" = "adm1")) %>% 
  mutate(n.ratio = n/adm1.y.lincount) %>% 
  filter(n >= 5, n.ratio >= 0.10) %>% rename(src=adm1.x, dst=adm1.y, move=n.ratio) %>% 
  left_join(germany.state.grography %>% dplyr::rename(src.id = id, src.lat = lat, src.long = long), by=c("src"="value")) %>% 
  left_join(germany.state.grography %>% dplyr::rename(dst.id = id, dst.lat = lat, dst.long = long), by=c("dst"="value")) %>%
  left_join(map.edge.info, by=c("src", "dst")) 

# map.color <- unlist(dePal)
# map.color[setdiff(names(map.color), levels(as.factor(data6$src)))] <- "gray"
# map.color <- c()
# map.color[names(dePal)] <- "gray"
# map.color[data6$src] <- hue_pal()(length(data6$src))
# map.color[data6$src] <- brewer.pal(length(data6$src), "Set1")
map.color[levels(as.factor(data6$src))] <- hue_pal()(length(levels(as.factor(data6$src))))
map.color <- c("Baden-Wurttemberg"="#F46D43", "Bavaria"="#1A9850", "Lower Saxony"="#f1b6da", "North Rhine-Westphalia"="#B2182B",
"Rhineland-Palatinate"="#fa9fb5", "Saxony"="#c6dbef", "Thuringia"="#D9EF8B")
map.color[setdiff(names(dePal), names(map.color))] <- "gray"

# map.color <- hue_pal()(length(data6$src))
# names(map.color) <- levels(as.factor(germany.f$value))
ggplot() +
  geom_polygon(data = germany.f, aes(x = long, y = lat, group = group, fill = value), colour = "gray", alpha=0.5)+
  geom_polygon(data = germany.f[germany.f$id == "11",], aes(x = long, y = lat, group = group, fill = value), colour = "gray") + 
  scale_fill_manual("Source", values = rep("white", length(levels(as.factor(germany.f$value))))) +
  # scale_fill_manual('value', values = unname(unlist(map.color[as.character(unique(forcats::fct_inorder(names(map.color) )))])) ) +
  # scale_fill_manual('value', values = forcats::fct_inorder(value) ) +
  # scale_fill_manual('State', values = map.color) +
  scale_color_manual(values = map.color[levels(as.factor(data6 %>% pull(src)))]) + 
  theme(axis.line=element_blank(), axis.text.x=element_blank(),
        axis.text.y=element_blank(), axis.ticks=element_blank(),
        axis.title.x=element_blank(),
        axis.title.y=element_blank(),
        panel.background=element_blank(), panel.grid.major=element_blank(),
        panel.border = element_rect(colour = "black", fill=NA, size=0.1),
        panel.grid.minor=element_blank(), plot.background=element_blank(),
        aspect.ratio = (max(germany.f$long) - min(germany.f$long))/(max(germany.f$lat) - min(germany.f$lat)),
        ) +
  geom_point(data = germany.state.grography %>% left_join(data6 %>% group_by(src) %>% summarise(n = sum(n)), by=c("value"="src")) %>% mutate(n = ifelse(is.na(n), 0, n)),
             alpha=1.0,
             aes(x = long,
                 y = lat,
                 size = n/100,
                 colour = value), show.legend = FALSE) + 
  lapply(seq(nrow(data6)), function(i) {
    geom_curve(data = data6[i,],
             alpha = 0.8,
             curvature =  data6[i,"curvature"],
             # color = "dodgerblue1",
             aes(x = src.long, y = src.lat,
                 xend = dst.long, yend = dst.lat,
                 color = src), linewidth = data6[i,"n"]/10, show.legend = FALSE)
  }) + 
  lapply(seq(nrow(data6)), function(i) {
    geom_curve(data = data6[i,],
             alpha = 1.0,
             curvature =  data6[i,"curvature"],
             # color = "dodgerblue1",
             aes(x = src.long, y = src.lat,
                 xend = dst.long, yend = dst.lat,
                 color = src),
                 arrow = arrow(length = unit(0.7, "cm"), angle=10, type = "closed"), size = 0.5, show.legend = TRUE, 
                 key_glyph = "segment_custom")
  }) + geom_line() + guides(fill = FALSE, size=FALSE)+ labs(color = "Source State")


data6 <- data2 %>% filter(adm1.x != adm1.y) %>% left_join(stateLineageCount %>% dplyr::rename(adm1.y.lincount = n), by=c("adm1.y" = "adm1")) %>% 
  mutate(n.ratio = n/adm1.y.lincount) %>% 
  filter(n >= 5) %>% rename(src=adm1.x, dst=adm1.y, move=n.ratio) %>% 
  left_join(germany.state.grography %>% dplyr::rename(src.id = id, src.lat = lat, src.long = long), by=c("src"="value")) %>% 
  left_join(germany.state.grography %>% dplyr::rename(dst.id = id, dst.lat = lat, dst.long = long), by=c("dst"="value")) %>%
  left_join(map.edge.info, by=c("src", "dst")) 

# map.color <- hue_pal()(length(data6$src))
# names(map.color) <- levels(as.factor(germany.f$value))
ggplot() +
  geom_polygon(data = germany.f, aes(x = long, y = lat, group = group, fill = value), colour = "gray", alpha=0.5)+
  geom_polygon(data = germany.f[germany.f$id == "11",], aes(x = long, y = lat, group = group, fill = value), colour = "gray") + 
  scale_fill_manual("Source", values = rep("white", length(levels(as.factor(germany.f$value))))) +
  # scale_fill_manual('value', values = unname(unlist(map.color[as.character(unique(forcats::fct_inorder(names(map.color) )))])) ) +
  # scale_fill_manual('value', values = forcats::fct_inorder(value) ) +
  # scale_fill_manual('State', values = map.color) +
  scale_color_manual(values = map.color[levels(as.factor(data6 %>% pull(src)))]) + 
  theme(axis.line=element_blank(), axis.text.x=element_blank(),
        axis.text.y=element_blank(), axis.ticks=element_blank(),
        axis.title.x=element_blank(),
        axis.title.y=element_blank(),
        panel.background=element_blank(), panel.grid.major=element_blank(),
        panel.border = element_rect(colour = "black", fill=NA, size=0.1),
        panel.grid.minor=element_blank(), plot.background=element_blank(),
        aspect.ratio = (max(germany.f$long) - min(germany.f$long))/(max(germany.f$lat) - min(germany.f$lat)),
        ) +
        ggtitle("More than 5") + 
  geom_point(data = germany.state.grography %>% left_join(data6 %>% group_by(src) %>% summarise(n = sum(n)), by=c("value"="src")) %>% mutate(n = ifelse(is.na(n), 0, n)),
             alpha=1.0,
             aes(x = long,
                 y = lat,
                 size = n/100,
                 colour = value), show.legend = FALSE) + 
  lapply(seq(nrow(data6)), function(i) {
    geom_curve(data = data6[i,],
             alpha = 0.8,
             # curvature =  data6[i,"curvature"],
             # color = "dodgerblue1",
             aes(x = src.long, y = src.lat,
                 xend = dst.long, yend = dst.lat,
                 color = src), linewidth = data6[i,"n"]/10, show.legend = FALSE)
  }) + 
  lapply(seq(nrow(data6)), function(i) {
    geom_curve(data = data6[i,],
             alpha = 1.0,
             # curvature =  data6[i,"curvature"],
             # color = "dodgerblue1",
             aes(x = src.long, y = src.lat,
                 xend = dst.long, yend = dst.lat,
                 color = src),
                 arrow = arrow(length = unit(0.7, "cm"), angle=10, type = "closed"), size = 0.5, show.legend = TRUE, 
                 key_glyph = "segment_custom")
  }) + geom_line() + guides(fill = FALSE, size=FALSE)+ labs(color = "Source State")


x <- clusterSamplesMCC %>% group_by(cluster, adm1) %>% dplyr::summarise(n = n()) %>% left_join(clusterSamplesMCC %>% group_by(cluster, adm1) %>% dplyr::summarise(n = n()), by = "cluster") %>% group_by(adm1.x, adm1.y) %>% dplyr::summarise(n = n()) 

kable(x %>% pivot_wider(values_from = n, names_from = adm1.y, values_fill = 0))


for (state in c("Baden-Wurttemberg", "Bavaria", "North Rhine-Westphalia")) {
  data6 <- x %>% filter(adm1.x != "NA", adm1.y != "NA") %>% filter(adm1.x == state) 
  plot_on_map(data6$adm1.y, unlist(data6$n), title=paste("Number of common lineages with", state), legend_title = "Count", col = "green", 
              max_value = 35, legend.position = "bottom", text.font.size = NULL)
}



```

```{r, fig.width=7, fig.height=8, fig.show='animate'}
# library(transformr)
# library(gifski)

calculate.germany.germany.f <- function() {
  germany <- raster::getData("GADM", country = "DEU", level = 1)
  germany.f <- fortify(germany, region = "CC_1")
  
  mapNames <- germany$VARNAME_1
  mapNames[is.na(mapNames)] <- germany$NAME_1[is.na(mapNames)]
  mapNames[mapNames == "Baden-Württemberg"] <- "Baden-Wurttemberg"
  mapNames[mapNames == "Mecklenburg-West Pomerania"] <- "Mecklenburg-Western Pomerania"
  
  germany$NAME_1_EN <- germany$NAME_1
  germany$NAME_1_EN[germany$NAME_1 == "Baden-Württemberg"] <- "Baden-Wurttemberg"
  germany$NAME_1_EN[germany$NAME_1 == "Mecklenburg-Vorpommern"] <- "Mecklenburg-Western Pomerania"
  germany$NAME_1_EN[germany$NAME_1 == "Bayern"] <- "Bavaria"
  germany$NAME_1_EN[germany$NAME_1 == "Hessen"] <- "Hesse"
  germany$NAME_1_EN[germany$NAME_1 == "Niedersachsen"] <- "Lower Saxony"
  germany$NAME_1_EN[germany$NAME_1 == "Nordrhein-Westfalen"] <- "North Rhine-Westphalia"
  germany$NAME_1_EN[germany$NAME_1 == "Rheinland-Pfalz"] <- "Rhineland-Palatinate"
  germany$NAME_1_EN[germany$NAME_1 == "Sachsen"] <- "Saxony"
  germany$NAME_1_EN[germany$NAME_1 == "Sachsen-Anhalt"] <- "Saxony-Anhalt"
  germany$NAME_1_EN[germany$NAME_1 == "Thüringen"] <- "Thuringia"
  
  # col <- '#1e0000'
  # germany$value <- 0
  germany.f$value <- germany$NAME_1_EN[match(germany.f$id, germany$CC_1)]
  
  return(list('germany.f'=germany.f, 'germany'=germany))
}

calculateBreakIndex <- function(dates, breaks) {
  return( ifelse(dates >= breaks[length(breaks)], length(breaks), sapply(dates, function(x) which.max(x < breaks) - 1)) )
}

breaks <- seq.Date(as.Date("2020-01-01"), as.Date("2021-05-20"), by="month")
data <- clusterSamplesMCC %>% mutate(break.index = calculateBreakIndex(Collection.date, breaks)) %>% group_by(cluster, break.index, adm1) %>% dplyr::summarise(n = n()) %>% ungroup() %>% filter(adm1 != "NA") %>% complete(cluster, break.index, adm1) %>% mutate(break.date = breaks[if_else(break.index > 0, break.index, 1)]) %>% mutate(n = ifelse(is.na(n), 0, n)) %>% group_by(cluster, adm1) %>% arrange(break.index) %>% mutate(n.cum = cumsum(n)) %>% ungroup()

lin <- "B.1.1.7_MCC_237"
i <- 15

   # plot_on_map(data$adm1, data$n, 
   #          title=paste("Calibrated no. of ", lin, " seqs per capita", breaks[i], "to", 
   #                      breaks[i+1]), legend_title = "Calibrated no. per capita", col = "#f46d43", 
   #          max_value = NA)
   
   
  germany.f <- calculate.germany.f()
  germany.f <- germany.f %>% left_join(data %>% filter(cluster == lin), by=c("value"="adm1")) %>% mutate(n = ifelse(is.na(n), 0, n)) 
  #%>% left_join(data.frame(cluster=names(col), color = unname(col)))
  
  # id=11 is drawn again because it is inside another region.
#   p <- ggplot() + 
#     geom_polygon(data = germany.f, aes(x = long, y = lat, group = group, fill = n), colour = "grey10")+
#     geom_polygon(data = germany.f[germany.f$id == "11",], aes(x = long, y = lat, group = group, fill = n), colour = "grey10")+
#     # scale_fill_gradient(low = lighten(col, 1), high = col, space = "Lab", limits=c(0, 1),
#     #                     name = "legend_title")+
#     ggtitle("Dominant important lineage in states") +
#     # options(repr.plot.width=max(germany.f$lat) - min(germany.f$lat), repr.plot.height=max(germany.f$long) - min(germany.f$long)) +
#     theme(axis.line=element_blank(), axis.text.x=element_blank(),
#           axis.text.y=element_blank(), axis.ticks=element_blank(),
#           axis.title.x=element_blank(),
#           axis.title.y=element_blank(),
#           panel.background=element_blank(), panel.grid.major=element_blank(),
#           panel.border = element_rect(colour = "black", fill=NA, size=0.1),
#           panel.grid.minor=element_blank(), plot.background=element_blank(),
#           aspect.ratio = (max(germany.f$long) - min(germany.f$long))/(max(germany.f$lat) - min(germany.f$lat))
#           ) 
#   # + guides(fill=guide_legend(ncol=2))
#   # print(p + scale_fill_manual('Lineage', values = unname(col[as.character(unique(forcats::fct_inorder(germany.f$cluster)))]) ))
# 
# # print(p)
#   
# anim <- p + labs(subtitle = "{previous_state}") + 
#   transition_states(states = break.date, transition_length = 3, state_length = 1) + ease_aes('cubic-in-out')
# 
# anim
# # anim_save("temp/temp.gif", animate(anim, duration = 5, fps = 10, width = 400, height = 400, renderer = gifski_renderer(), device = 'ragg_png'))
# include_graphics("temp/temp.gif")
  
# library(plotly)
# library(gapminder)
# 
# 
# p <- gapminder %>%
#   plot_ly(
#     x = ~gdpPercap, 
#     y = ~lifeExp, 
#     size = ~pop, 
#     color = ~continent, 
#     frame = ~year, 
#     text = ~country, 
#     hoverinfo = "text",
#     type = 'scatter',
#     mode = 'markers'
#   ) %>%
#   layout(
#     xaxis = list(
#       type = "log"
#     )
#   )

library(animation)
dir.create("temp", showWarnings = FALSE)

saveGIF({
  # for (i in 1:10) plot(runif(10), ylim = 0:1)
  
  for (i in seq(germany.f %>% filter(n > 0) %>% pull(break.index) %>% min(), length(breaks)-1)) {
    data2 <- germany.f %>% filter(break.index == i) 
    p <- ggplot() +
      geom_polygon(data = data2, aes(x = long, y = lat, group = group, fill = n.cum), colour = "grey10")+
      geom_polygon(data = data2[data2$id == "11",], aes(x = long, y = lat, group = group, fill = n.cum), colour = "grey10")+
      scale_fill_gradient(low = lighten(col, 1), high = col, space = "Lab", limits=c(0, max(germany.f$n.cum)),
                          name = "legend_title")+
      ggtitle(paste("Dominant important lineage in states", breaks[i])) +
      # options(repr.plot.width=max(germany.f$lat) - min(germany.f$lat), repr.plot.height=max(germany.f$long) - min(germany.f$long)) +
      theme(axis.line=element_blank(), axis.text.x=element_blank(),
            axis.text.y=element_blank(), axis.ticks=element_blank(),
            axis.title.x=element_blank(),
            axis.title.y=element_blank(),
            panel.background=element_blank(), panel.grid.major=element_blank(),
            panel.border = element_rect(colour = "black", fill=NA, size=0.1),
            panel.grid.minor=element_blank(), plot.background=element_blank(),
            aspect.ratio = (max(germany.f$long) - min(germany.f$long))/(max(germany.f$lat) - min(germany.f$lat))
            )
    # + guides(fill=guide_legend(ncol=2))
    # print(p + scale_fill_manual('Lineage', values = unname(col[as.character(unique(forcats::fct_inorder(germany.f$cluster)))]) ))
    print(p)
  }
}, movie.name = "temp.gif", interval = 0.2, nmax = 30, ani.width = 600, autobrowse = FALSE, autoplay = FALSE)
include_graphics("temp.gif")

```

```{r}
# #TEMP
# library(gganimate)
# 
# # We'll start with a static plot
# p <- ggplot(iris, aes(x = Petal.Width, y = Petal.Length)) + 
#   geom_point()
# 
# anim <- p + 
#   transition_states(Species,
#                     transition_length = 2,
#                     state_length = 1)
# 
# dir.create("temp")
# anim_save("temp/temp.gif", animate(anim, duration = 5, fps = 20, width = 200, height = 200, renderer = gifski_renderer()))
# include_graphics("temp/temp.gif")  

```


```{r import-proportion-data}

#    getImportsByDate <- function(eii, countryList, tmrca_hist_shifted, breaks) {
#
#        # Proportion of imports on any day attributable to a country
#        importProp <- data.frame(date = sort(unique(eii$date)))
#        for (country in countryList) {
#            # Have to make very sure date order is correct
#            importProp[[country]] <- sapply(importProp$date, function(x) eii$num_intros[eii$location == country & eii$date == x] / 
#                                                                         eii$num_intros[eii$location == "all" & eii$date == x])
#        }
#        importDates      <- importProp$date
#        importProp$all   <- NULL
#        importProp$date  <- NULL
#        rownames(importProp) <- format.Date(importDates)
#        
#        z <- importProp$Other
#        importProp$Other <- NULL
#        importProp$Other <- rep(1, nrow(importProp)) - rowSums(importProp)
#        
#        # Count of imports from each country (using shifted TMRCA distribution)
#        # Not absolute count, can have fractions of importations!
#        start <- which(breaks == min(importDates))
#        end   <- which(breaks == max(importDates))
#        importCount <- apply(importProp, 2, function(x) x * tmrca_hist_shifted$counts[start:end])
#    
#        # Need to add one date so the props and counts act like a histogram (dates delimit breaks)
#        importDates <- c(importDates, importDates[length(importDates)] + (importDates[length(importDates)] - importDates[length(importDates)-1]))
#        
#        return(list(importDates = importDates, importProp = importProp, importCount = importCount))
#    }
#
#    importsAll <- getImportsByDate(eii, levels(eii$location), tmrca_hist_shifted, tmrcaBreaks)
#    importsSub <- getImportsByDate(eii, plotList, tmrca_hist_shifted, tmrcaBreaks)

```
    
  
```{r totalCountsTable, cache=TRUE}
#
#    # Sort and aggregate top 40 on MCC tree
   #  totalCounts <- colSums(importsAll$importCount) %>% sort(decreasing=TRUE)
   #  idx <- which(names(totalCounts) == "Other")
   #  totalCounts <- totalCounts[c(1:(idx-1), (idx+1):41, idx)]    
   #  
   #  # Get statistics across all posterior trees for the same 40 countries
   #  nreps  <- nrow(lagmodel)
   #  failed <- 0
   #  countryOrder <- names(totalCounts)
   #  totalCountsReps <- c()
   #  
   #  tic(paste0("\n\nNumbers of importations across ", nreps, " posterior trees: "))
   #  for (i in 1:nreps) {
   #    
   #      if (lagmodel$exit_code[i] == 1) {
   #          clusterStatsTemp <- clusterStats[clusterStats$tree == i, ]
   #          clusterStatsTemp$shift <- lagmodel$alpha[i] + lagmodel$beta[i]/clusterStatsTemp$seqs
   #          clusterStatsTemp$tmrca_shifted <- clusterStatsTemp$tmrca - (clusterStatsTemp$shift/366)
   #          clusterStatsTemp$tmrca_shifted_calendar <- as.Date(round_date(date_decimal(clusterStatsTemp$tmrca_shifted), unit = "day"))
   #          clusterStatsTemp$detection_lag <- as.Date(round_date(date_decimal(clusterStatsTemp$oldest), unit = "day")) - clusterStatsTemp$tmrca_shifted_calendar
   #          
   #          importHistTemp <- hist(clusterStatsTemp$tmrca_shifted_calendar, breaks=tmrcaBreaks, plot=FALSE, right=FALSE)  
   #          importsTemp    <- getImportsByDate(eii, levels(eii$location), importHistTemp, tmrcaBreaks)
   #          
   #          # Sort and aggregate top 40
   #          totalCountsTemp <- colSums(importsTemp$importCount) 
   #          totalCountsReps <- cbind(totalCountsReps, totalCountsTemp[countryOrder])
   #      } else {
   #          failed <- failed + 1
   #      }
   #  }
   #  totalPercReps <- apply(totalCountsReps, 2, function(x) 100*x/sum(x))
   #  toc()
   #  
   #  
   #  
   #  getHPDText <- function(x, digits=3) {
   #     res <- round(getHPD.boa(x), digits)
   #     return(paste0(res[2], " [",res[1],"-",res[3],"]"))
   # }
   # 
   # 
   # 
   # totalCountsTable <- data.frame(importsMCC        = round(totalCounts,2),
   #                                importsHPD        = apply(totalCountsReps, 1, getHPDText, digits=2),
   #                                #importsMeanSD    = apply(totalCountsReps, 1, getMeanSDText),
   #                                #importsMedIQR    = apply(totalCountsReps, 1, function(x) paste0(round(median(x),2), " [", paste(round(quantile(x, c(0.25, 0.75)),2), collapse="-"), "]")),
   #                                percentageMCC     = round(100*totalCounts/sum(totalCounts), 3),
   #                                percentageHPD     = apply(totalPercReps, 1, getHPDText))
   #                                #percentageMeanSD = apply(totalPercReps, 1, getMeanSDText),
   #                                #percentageMedIQR = apply(totalPercReps, 1, function(x) paste0(round(median(x),2), " [", paste(round(quantile(x, c(0.25, 0.75)),2), collapse="-"), "]")))
   # 
   # colnames(totalCountsTable) <- c("Observed importations (MCC tree)",
   #                                 "Observed importations (median, 95% HPD)",
   #                                 "Percentage (MCC tree)",
   #                                 "Percentage (median, 95% HPD)")
   # capTotalCounts <- paste0("Number of observed importations in our dataset and the percentage of the total that can be attributed to the 40 countries inferred to be sources for the most importations on the MCC tree and across a set of ", nreps-failed, " posterior trees (the optimisation procedure failed to converge on ", failed, " posterior trees).")
   # 
   # 
   # rownames(totalCountsTable) <- sub("Korea, South", "South Korea", rownames(totalCountsTable))
   # kable(totalCountsTable, caption=capTotalCounts)
   # cat(knitr::kable(totalCountsTable, caption = capTotalCounts, format="latex"), file = paste0(figpath, "import-counts.tex"))
   # cat(knitr::kable(totalCountsTable, caption = capTotalCounts, format="html"),  file = paste0(figpath, "import-counts.html"))
   # write.csv(totalCountsTable, file = paste0(figpath, "import-counts.csv"), row.names=TRUE, quote=FALSE)
   # 
   #  
```

```{r import-proportions, fig.width=7, fig.height=3, fig.cap="The estimated proportion of importation events that are attributable to inbound travellers from each of several source countries over time.", eval=TRUE}

   # par(mar=c(4,6,2.5,6), cex.axis=0.7, cex.lab=0.8)
   # 
   # dateFreqDistribution(t(importsSub$importProp), importsSub$importDates, plot.ci=FALSE,  barplot=FALSE,
   #                      startDate = startDate, endDate = endDate,
   #                      col=sapply(colnames(importsSub$importProp), function(x) mPal(countryPal[[x]], 0.75)), border = "#000000",
   #                      ymax = 1, ylab = "Proportion of samples")
   # rect(startDate, 0, endDate, 1, xpd=TRUE)
   # 
   # legend("top", horiz=FALSE, inset=c(0,-0.35), bty='n', xpd=TRUE, ncol=5,
   #        fill=unname(sapply(colnames(importsSub$importProp), function(x) mPal(countryPal[[x]], 0.75))),
   #        legend <- colnames(importsSub$importProp), cex=0.8)

```


```{r import-hist, fig.width=9.5, fig.height=4, fig.cap="Estimated histogram of virus lineage importation events per day, obtained from our lag model. Colours show the proportion attributable each day to inbound travel from various countries. This assignment is statistical, i.e. we cannot ascribe a specific source location to any given lineage."}
#
#    par(mar=c(4,6,2.5,8), cex.axis=0.7, cex.lab=0.8, mgp=c(3,0.75,0))
#
#    dateFreqDistribution(t(importsSub$importCount), importsSub$importDates, plot.ci=FALSE,  barplot=TRUE, 
#                         startDate = startDate, endDate = endDate, 
#                         col=sapply(colnames(importsSub$importCount), function(x) mPal(countryPal[[x]], 0.75)), 
#                         border = sapply(colnames(importsSub$importCount), function(x) mPal(countryPal[[x]])),
#                         ymax = 70, ylab = "Importation events leading to an\nobserved transmission lineage")
#    
#    legend("topleft", horiz=FALSE, inset=c(1,0), bty='n', xpd=TRUE, ncol=1,
#           border = unname(sapply(colnames(importsSub$importProp), function(x) mPal(countryPal[[x]]))), 
#           fill   = unname(sapply(colnames(importsSub$importProp), function(x) mPal(countryPal[[x]], 0.75))), 
#           legend <- colnames(importsSub$importProp), cex=1)

```

```{r import-hist-extended, fig.width=9, fig.height=4, fig.cap="Estimated histogram of virus lineage importation events per day, obtained from our lag model. Colours show the proportion attributable each day to inbound travel from various countries. This assignment is statistical, i.e. we cannot ascribe a specific source location to any given lineage. **This is the same as the previous plot but the axes have been extended. Lineages with TMRCAs after 30 April are not plotted, since data on inbound travellers after 30 April are not available.**"}
#
#    par(mar=c(4,6,2.5,7), cex.axis=0.7, cex.lab=0.8, mgp=c(3,0.75,0))
#
#    # Extend with zeros to plot on same axes as TMRCAs (need post-processing, since unassigned TMRCAs > Apr 30 are NOT plotted)
#    tempImportDates  <- c(importsSub$importDates, seq(max(importsSub$importDates+1), as.Date("2020-07-01"), by="days"))
#    tempImportCounts <- rbind(importsSub$importCount, matrix(nrow=(length(tempImportDates)-nrow(importsSub$importCount)-1), ncol=ncol(importsSub$importCount)))
#    
#
#    dateFreqDistribution(t(tempImportCounts), tempImportDates, plot.ci=FALSE,  barplot=TRUE, 
#                         startDate = startDate, endDate = "2020-06-21", 
#                         col=sapply(colnames(importsSub$importCount), function(x) mPal(countryPal[[x]], 0.75)), 
#                         border = sapply(colnames(importsSub$importCount), function(x) mPal(countryPal[[x]])),
#                         ymax = 70, ylab = "Importation events leading to an\nobserved transmission lineage")
#    
#    legend("topleft", horiz=FALSE, inset=c(1,0), bty='n', xpd=TRUE, ncol=1,
#           border = unname(sapply(colnames(importsSub$importProp), function(x) mPal(countryPal[[x]]))), 
#           fill   = unname(sapply(colnames(importsSub$importProp), function(x) mPal(countryPal[[x]], 0.75))), 
#           legend <- colnames(importsSub$importProp), cex=1)

```




```{r import-hist-cumulative, fig.width=5, fig.height=3, fig.cap="Estimated cumulative number of virus lineage importation events per day, obtained from our lag model. Colours show the proportion attributable each day to inbound travel from various countries. This assignment is statistical, i.e. we cannot ascribe a specific source location to any given lineage. The black line shows the cumulative global EII curve. **This plot is to check the fit of the importation distribution to the EII curve by eye.**"}
#
#    par(mar=c(4,5,2.5,6), cex.axis=0.7, cex.lab=0.8)
#
#    heights <- t(apply(importsSub$importCount, 2, cumsum))
#
#    dateFreqDistribution(heights, importsSub$importDates, plot.ci=FALSE,  barplot=FALSE, 
#                         startDate = startDate, endDate = endDate, 
#                         col=sapply(colnames(importsSub$importCount), function(x) mPal(countryPal[[x]], 0.75)), border = NA,
#                         ymax = max(colSums(heights))*1.1, ylab = "Importation events leading to an\nobserved transmission lineage")
#    
#    legend("top", horiz=FALSE, inset=c(0,-0.35), bty='n', xpd=TRUE, ncol=4,
#           border = unname(sapply(colnames(importsSub$importProp), function(x) mPal(countryPal[[x]]))), 
#           fill   = unname(sapply(colnames(importsSub$importProp), function(x) mPal(countryPal[[x]], 0.75))), 
#           legend <- colnames(importsSub$importProp), cex=0.8)
#    
#    par(new=TRUE)
#    
#    y <- cumsum(eii$num_intros[eii$location == "all"])
#    
#    plot(1, type='n', xlim=as.Date(c(startDate, endDate)), ylim=c(0,max(y)*1.1), axes=FALSE, 
#         xaxs='i', yaxs='i', xlab="", ylab="")
#    lines(eii$date[eii$location == "all"], y, lwd=2)
#    axis(4, las=1)
#    mtext(side=4, text="Cumulative estimated importation intensity\n(solid line)", line=4, cex=0.8)

```

```{r import-proportions-total, fig.width=6, fig.height=3, fig.cap="The estimated total fraction of importation events that are attributable to inbound travellers from each country."}
#
#    # Total proportion of observed (seen a TMRCA) importations attributable to a country
#    totalProps <- colSums(importsSub$importCount)/sum(importsSub$importCount)
#    
#    par(mar=c(0,0,0,0))
#    pie(totalProps, labels=sapply(names(totalProps), function(x) paste0(x, " (", round(totalProps[x]*100, 2), "%)")), 
#        col=sapply(names(totalProps), function(x) mPal(countryPal[[x]], 0.75)), border=NA, cex=1)

```


```{r import-hist-countries, fig.width=15, fig.height=12, fig.cap="Estimated histogram of virus lineage importation events per day, obtained from our lag model, for the 12 countries estimated to have contributed the most importations (see Table 3). This assignment is statistical, i.e. we cannot ascribe a specific source location to any given lineage. **This plot is just a sanity check and isn't useful for drawing any conclusions.**"}
#
#    # Adjust margins
#    ymax1 <- list(Spain       = 30, 
#                  France      = 30, 
#                  Italy       = 30, 
#                  Belgium     = 10, 
#                  Netherlands = 10, 
#                  Ireland     = 10, 
#                  Switzerland = 10, 
#                  US          = 10,
#                  Germany     = 3,
#                  Portugal    = 1,
#                  Sweden      = 1,
#                  China       = 4) 
#
#    ymax2 <- list(Spain       = 500, 
#                  France      = 500, 
#                  Italy       = 500, 
#                  Belgium     = 140, 
#                  Netherlands = 140, 
#                  Ireland     = 140, 
#                  Switzerland = 140, 
#                  US          = 140,
#                  Germany     = 50,
#                  Portugal    = 15,
#                  Sweden      = 15,
#                  China       = 1)
#
#    par(mar=c(4,6,2.5,6), cex.axis=1, cex.lab=1.2, cex.main=1.5, mgp=c(2,0.75,0))
#
#    layout(matrix(c(1:12), nrow=4, byrow=TRUE))
#    for (country in names(ymax1)) {
#
#        dateFreqDistribution(unname(importsAll$importCount[, country]), importsAll$importDates, plot.ci=FALSE,  barplot=TRUE, 
#                             startDate = startDate, endDate = endDate, 
#                             col=mPal(countryPal[[country]], 0.75), border = NA, 
#                             ymax = ymax1[[country]], ylab = "Importation events leading to an\nobserved transmission lineage", label=LETTERS[which(names(ymax1) == country)])
#        
#        par(new=TRUE)
#        plot(1, type='n', xlim=as.Date(c(startDate, endDate)), ylim=c(0,ymax2[[country]]), axes=FALSE, 
#             xaxs='i', yaxs='i', xlab="", ylab="")
#        lines(eii$date[eii$location == country], eii$num_intros[eii$location == country], lwd=2)
#        axis(4, las=1)
#        mtext(side=4, text="Estimated importation intensity\n(solid line)", line=4, cex=0.8)
#        title(capitalise(country))
#
#    }
#
```



\clearpage

# Session info

```{r sessionInfo, results='markup'}
    sessionInfo()
```
