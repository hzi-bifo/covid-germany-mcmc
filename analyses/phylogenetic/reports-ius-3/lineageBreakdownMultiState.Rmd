---
title: "SARS-CoV-19 introductions"
subtitle: "Transmission Lineage Breakdown for Germany"

date: '`r format(Sys.time(), "Last modified: %d %b %Y")`'
output:
  pdf_document:
    toc: true
    toc_depth: 3
    number_sections: true
    keep_tex: false
    fig_crop: false
layout: page
editor_options: 
  chunk_output_type: inline
params: 
  inputpath  :  "../../../data/phylogenetic/"
  cluster_f  : "DTA"
  startDate       : "2020-01-01"
  endDate         : "2021-06-02"
  device     : "pdf"
  metadata   : "../results/gisaid-20210602-metadata-sampled-unsampled.tsv"
  metadataAllSequences   : "../../../../data/data/gisaid-20210602-metadata.tsv"
  oldestCase : "2020-02-27"
  outputfolder    : "../results/beast/run/lin-ius-3/"
  caseDataGermany : "../data/cases-rki-by-state.csv"

---

```{r rsetup, include=FALSE}
  # outputpath : "../results/trees-gisaid-Hamburg-20210417-lin-rich/"
  # state      : "Hamburg"

# case file: https://github.com/CSSEGISandData/COVID-19
# case file details: https://github.com/GoogleCloudPlatform/covid-19-open-data
  
    library(lubridate)
    library(gplots)
    library(viridis)
    library(tictoc)
    library(stringr)
    library(dplyr)
    library(knitr)
    source("../reports/palettes.R")
    source("../reports/plotutils.R")
    source("../reports/reportutils.R")
    #source("../scripts/clusterutils.R")
    library(vegan)
    library(tidyr)

    library(raster)
    library(ggplot2)
    library(colorspace)
    library(maptools)

    inputpath  <- params$inputpath
    cluster_f  <- params$cluster_f
    
    startDate  <- as.Date(params$startDate)
    endDate    <- as.Date(params$endDate)
    # outputpath <- params$outputpath
    # state      <- params$state
    
    figpath    <- paste0(params$outputfolder, "figures/lineage_breakdown_figures_", params$device, "/")
    dir.create(figpath, recursive = TRUE, showWarnings = FALSE)
    
    cachepath  <- paste0(params$outputfolder, "figures/cache/lineageBreakdown_", params$device, "/")


    knitr::opts_chunk$set(tidy=FALSE, cache=FALSE, cache.path = cachepath, 
                          dev=params$device, fig.path=figpath, dpi=300,
                          message=FALSE, error=TRUE, warning=TRUE, echo=FALSE)
    
    
    
    dateBreaks  <- seq.Date(startDate, endDate+6, by="day")
    
    metadata <- load_metadata(params$metadata)
    metadataAllSequences <- load_metadata(params$metadataAllSequences)
    
    set_instate <- function(metadata, state) {
      return(sapply(str_split(paste0(metadata$Location,"/",metadata$Additional.location.information), "/"), function(x) {return(str_trim(x[2]) == "Germany" & (grepl(state, x[3], fixed=TRUE) | ( length(x) >= 4 & grepl(state, x[4], fixed=TRUE) )) );}))
    } 
    
    # metadata$instate      <- set_instate(metadata, state)
    
    labelDates <- list("oldestCase" = as.Date(params$oldestCase), 
                       "oldestSeq"  = as.Date(min(metadata$sample_date[metadata$instate])))
    

    stateFiles = data.frame(state = c("Germany"), 
                            state.name = c("Germany"),
                            adm.level = c(2),
                            outputpath=c("../results/beast/run/lin-ius-3/") )
                            # outputpath=c("../results/beast/run/lin-rich-sk/") )
                            # outputpath=c("../results/beast/run/lin/") )
    
    stateInfo <- list()
    stateInfo$metadata_instate <- data.frame(matrix(0, nrow=nrow(metadata), ncol=0))
    for (i in 1:nrow(stateFiles)) {
      state <- stateFiles$state[i]
      state.name <- stateFiles$state.name[i]
      # DEBUG TODO
      #stateInfo$metadata_instate <- cbind(stateInfo$metadata_instate, rep(FALSE, nrow(metadata)))
      if (stateFiles$adm.level[i] == 3)
        stateInfo$metadata_instate <- cbind(stateInfo$metadata_instate, set_instate(metadata, state.name))
      else if (stateFiles$adm.level[i] == 2)
        stateInfo$metadata_instate <- cbind(stateInfo$metadata_instate, metadata$country == state)
      colnames(stateInfo$metadata_instate)[ncol(stateInfo$metadata_instate)] <- state
    }
    
    stateInfo$stateOrder <- c(1)

    
    # for comments and documents before codes.
    states <- paste(stateFiles$state)

    rsumstate <- function(f) {
      return(sapply(seq(nrow(stateFiles)), function(s) { return (paste(stateFiles$state[s], ":", f(stateFiles$state[s], s, stateInfo$clusterStatsMCC[[s]]))); }))
    }
    
    case_data <- read.table("../data/time_series_covid19_confirmed_global.csv", sep = ",", quote = "\"", stringsAsFactors = FALSE)
    case_data_date <- as.Date(unlist(case_data[1,5:ncol(case_data)]), format="%m/%d/%y")
    case_data_value <- sapply(case_data[2:nrow(case_data), 5:ncol(case_data)], as.numeric)
    case_data_country <- case_data[2:nrow(case_data),2]
    case_data <- aggregate(case_data_value, data.frame(country = case_data_country), sum)
    case_data_country <- case_data[,1]
    case_data <- case_data[,2:ncol(case_data)]
    case_data[,2:ncol(case_data)] <- case_data[,2:ncol(case_data)] - case_data[,1:(ncol(case_data)-1)]
    rownames(case_data) <- case_data_country
    
    # 
    # 
    # 
    # case_data_value <- case_data[,2:ncol(case_data)]
    # case_data <- t(case_data_value)
    # colnames(case_data) <- case_data_country
    # rownames(case_data) <- case_data_date
    # germany_cases <- data.frame(date = case_data_date, case = case_data[,] )
    

    
   deCountyDaily <- getDeCountyDaily(params$caseDataGermany, "../data/germany-subdivisions.csv", metadataAllSequences)
   deCounty <- getDeInfo("../data/germany-data.csv", deCountyDaily, as.Date("2020-10-01"))
    


```

# Summary
This notebook plots breakdowns of `r states` transmission lineages over time (using only the assignment on the MCC trees).

## Data and Method
- GISAID sequences are retried at `r endDate`. 1,819,996 sequences are retrieved.
- Data is sampled evenly, for each epi-week 100 samples from Germany and 25 samples from every other country are kept. For special sub-clusters, 5 earliest and 5 oldest samples are also kept as the sampled sequence. Resuting a clustering of 72,579 samples.
- An initial hierarchical clustering of samples based on their pango-lineages is done.
- Data is partitioned to huge sub-trees. 
- Initial tree is calculated for each huge sub-tree via sarscov2phylo tool.
- Polytomy resolution and branch length assignment is done via BEAST MCMC.
- Location (Germany and non-Germany) is assigned to internal nodes based on a DTA model via BEAST MCMC.
- Imported lineages are calculated.
- Unsampled sequences from Germany re-attached to imported lineages. Finally 113,070 samples from Germany are clustered in different importation lineages.
<!-- 93989+186+272+614+8489+1879+2092+209+1999+481+334 tried to be added -->






```{r load-data, cache=TRUE}
               
    stateInfo$clusterStatsMCC <- stateInfo$clusterSamplesMCC <- stateInfo$cutoff <- list()
    for (s in 1:nrow(stateFiles)) {
      state <- stateFiles$state[s]
      state.name <- stateFiles$state.name[s]
      outputpath <- stateFiles$outputpath[s]
      
    # clusterStatsMCC   <- read.csv(paste0(outputpath, "clusters_", cluster_f, "_MCC_0.5.csv"))
    clusterStatsMCC   <- read.table(paste0(outputpath, "clusters_", cluster_f, "_MCC_NA.tsv"), sep="\t", head=TRUE, na.strings=c("NA", ""), fill=TRUE, stringsAsFactors=FALSE, quote="|")

    # clusterStatsMCC   <- read.csv(paste0(outputpath, "clusters_", cluster_f, "_MCC_NA.csv"))
    # clusterSamplesMCC <- read.csv(paste0(outputpath, "clusterSamples_", cluster_f, "_MCC_0.5.csv"))
    # clusterSamplesMCC <- read.csv(paste0(outputpath, "clusterSamples_", cluster_f, "_MCC_NA.csv"))
    clusterSamplesMCC <- read.table(paste0(outputpath, "clusterSamples_", cluster_f, "_MCC_NA.tsv"), sep="\t", head=TRUE, na.strings=c("NA", ""), fill=TRUE, stringsAsFactors=FALSE, quote="|")
    clusterSamplesMCC <- clusterSamplesMCC[!is.na(clusterSamplesMCC$Virus.name),]

    clusterStatsMCC$cluster <- sapply(clusterStatsMCC$cluster, function(cluster) paste(strsplit( gsub("-", "_", cluster), split="_")[[1]][c(3,6,7)], collapse="_"))
    clusterSamplesMCC$cluster <- sapply(clusterSamplesMCC$cluster, function(cluster) paste(strsplit( gsub("-", "_", cluster), split="_")[[1]][c(3,6,7)], collapse="_"))
    

    # Convert dates to POSIX dates
    clusterStatsMCC$tmrca_calendar <- ymd(clusterStatsMCC$tmrca_calendar)
    clusterSamplesMCC$sample_date  <- ymd(clusterSamplesMCC$sample_date)

    clusterSamplesMCC$decimal_date <- decimal_date(clusterSamplesMCC$sample_date)    

    lineageSizes <- sort(table(clusterSamplesMCC$cluster))
    clusterSamplesMCC$lineage_seqs            <- sapply(as.character(clusterSamplesMCC$cluster), function(x) lineageSizes[x])
    clusterSamplesMCC$lineage_tmrca           <- sapply(seq_len(nrow(clusterSamplesMCC)), function(x) 
                                                        ifelse(clusterSamplesMCC$lineage_seqs[x] == 1, NA, clusterStatsMCC$tmrca[clusterStatsMCC$cluster == as.character(clusterSamplesMCC$cluster[x])]))
    #clusterSamplesMCC$lineage_tmrca_calendar  <- sapply(seq_len(nrow(clusterSamplesMCC)), function(x) 
    #                                                    ifelse(clusterSamplesMCC$lineage_seqs[x] == 1, NA, clusterStatsMCC$tmrca_calendar[clusterStatsMCC$cluster == as.character(clusterSamplesMCC$cluster[x])]))
    clusterSamplesMCC$lineage_oldest          <- sapply(seq_len(nrow(clusterSamplesMCC)), function(x) 
                                                        ifelse(clusterSamplesMCC$lineage_seqs[x] == 1, NA, clusterStatsMCC$oldest[clusterStatsMCC$cluster == as.character(clusterSamplesMCC$cluster[x])]))
    clusterSamplesMCC$lineage_mostrecent      <- sapply(seq_len(nrow(clusterSamplesMCC)), function(x) 
                                                        ifelse(clusterSamplesMCC$lineage_seqs[x] == 1, NA, clusterStatsMCC$mostrecent[clusterStatsMCC$cluster == as.character(clusterSamplesMCC$cluster[x])]))
    clusterSamplesMCC$lineage_duration        <- 366*(clusterSamplesMCC$lineage_mostrecent - clusterSamplesMCC$lineage_tmrca)
    clusterSamplesMCC$lineage_age             <- 366*(clusterSamplesMCC$decimal_date - clusterSamplesMCC$lineage_oldest)

    clusterSamplesMCC$country                 <- sapply(strsplit(clusterSamplesMCC$Location, '/'), function(x) str_trim(x[2]))
    # clusterSamplesMCC$state      <- str_trim(sapply(str_split(paste0(clusterSamplesMCC$Location,"/",clusterSamplesMCC$Additional.location.information), "/"), "[[", 3))
    
    # clusterSamplesMCC$instate      <- set_instate(clusterSamplesMCC, state)
    
    if (stateFiles$adm.level[s] == 3){
      clusterSamplesMCC$instate <- set_instate(clusterSamplesMCC, state.name)
    }else if (stateFiles$adm.level[s] == 2){
      clusterSamplesMCC$instate <- clusterSamplesMCC$country == state
    }
      
    clusterSamplesMCCnoSingles <- clusterSamplesMCC[!is.na(clusterSamplesMCC$lineage_tmrca), ]
    clusterSamplesMCCnoSingles$lineage_tmrca_calendar <- ymd(round_date(date_decimal(clusterSamplesMCCnoSingles$lineage_tmrca), unit="day"))

    
      stateInfo$clusterStatsMCC[[s]] = clusterStatsMCC
      stateInfo$clusterSamplesMCC[[s]] = clusterSamplesMCC
      stateInfo$clusterSamplesMCCnoSingles[[s]] = clusterSamplesMCCnoSingles
      
    # Get the cutoff for plotting samples in lineage plots
    # (First day when cumulatively 500 UK genomes have been sequenced)
    degenomes <- sort(metadata$sample_date[stateInfo$metadata_instate[,s]])
    stateInfo$cutoff[[s]]    <- degenomes[min(1000, length(degenomes))]
  }
    
    
```

```{r functions}

    # sampleVsLineageTMRCA <- getSampleBreakdown(clusterStatsMCC[,], 
    #                                            clusterSamplesMCCnoSingles, 
    #                                            dateBreaks,
    #                                            stat="lineage_tmrca_calendar", 
    #                                            breaks=tmrcaBreaks)    

    getSampleBreakdown <- function(clusterSummary, clusterSamples, dateBreaks, 
                                    stat="lineage_tmrca", breaks) {
      
      clusterSamples$sample_date <- as.Date(clusterSamples$sample_date)
      dateBreaks                 <- as.Date(dateBreaks)
      
      
      dateBreakdown <- c()
      for (i in 2:length(dateBreaks)) {
        samples      <- clusterSamples[clusterSamples$sample_date >= dateBreaks[i-1] & clusterSamples$sample_date < dateBreaks[i] & clusterSamples$instate, ]
        
        if (nrow(samples) > 0) {
          #cat(i, samples[[stat]], breaks)
          dateBreakdown <- rbind(dateBreakdown, hist(samples[[stat]], plot=FALSE, breaks=breaks)$counts)
        } else {
          dateBreakdown <- rbind(dateBreakdown, rep(0, length(breaks)-1))
        }
      }
      rownames(dateBreakdown) <- format.Date(dateBreaks[1:(length(dateBreaks)-1)], format="%Y-%m-%d") # (used equivalent of right = FALSE)
      colnames(dateBreakdown) <- breaks[2:length(breaks)]  # (used default right = TRUE)
      
      return(dateBreakdown)
    }

    # stateInfo$weeklyBreakdown[[s]] <- getSampleLineageBreakdown(clusterSamplesMCC, breaks="weeks", startDate = startDate, endDate = endDate)
    getSampleLineageBreakdown <- function(clusterSamples, breaks="weeks", startDate="2020-01-12", endDate="2020-06-28") {
    
        uksamples <- droplevels(clusterSamples[clusterSamples$instate, ])
        uksamples$sample_date <- as.Date(uksamples$sample_date)
        
        sampleBreaks      <- seq.Date(as.Date(startDate), as.Date(endDate), by=breaks)
        
        
        #################################################
        # Get nr of sequences / period for each lineage #
        #################################################
        
        sizeDistr  <- sort(table(uksamples$cluster), decreasing=TRUE)
        clustNames <- names(sizeDistr)
        
        clustSizes <- c()
        for (cluster in clustNames) {
            sampleDates <- uksamples$sample_date[uksamples$cluster == cluster]
            sampleHist  <- hist(sampleDates, breaks=sampleBreaks, plot=FALSE, right=FALSE)
            clustSizes  <- cbind(clustSizes, sampleHist$counts)
        }
        rownames(clustSizes) <- format.Date(sampleBreaks[1:(length(sampleBreaks)-1)])    # Label rows by the start of the epi-week the row represents
        colnames(clustSizes) <- clustNames
        
        weekSums   <- rowSums(clustSizes)
        weekSums[weekSums == 0] <- 1
        clustProps <- clustSizes/weekSums
    
        
        ########################################
        # Aggregate into different size groups #
        ########################################
        
        aggregateLineages <- function(name, sizes) {
            if (sizes[name] == 1) {
                return("singleton")
            } else 
            if (sizes[name] <= 10) {
                return("small")
            } else 
            if (sizes[name] <= 100) {
                return("medium")
            } else 
            if (sizes[name] <= 1000) {
                return("big")
            } else {
                return("huge")
            }
        }
        
        uksamples$aggr_lineage <- factor(sapply(as.character(uksamples$cluster), function(x) aggregateLineages(x, sizeDistr)))
        aggrSizes <- c()
        sizeCats  <- c("huge", "big", "medium", "small", "singleton")
        for (cat in sizeCats) {
            sampleDates <- uksamples$sample_date[uksamples$aggr_lineage == cat]
            sampleHist  <- hist(sampleDates, breaks=sampleBreaks, plot=FALSE, right=FALSE)
            aggrSizes   <- cbind(aggrSizes, sampleHist$counts)
        }
        rownames(aggrSizes) <- format.Date(sampleBreaks[1:(length(sampleBreaks)-1)])
        colnames(aggrSizes) <- sizeCats
        
        weekSums   <- rowSums(aggrSizes)
        weekSums[weekSums == 0] <- 1
        aggrProps <- aggrSizes/weekSums
        
        
        
        #########################################
        # Top 8 largest clusters (>400 genomes) #
        #########################################
        
        
        clustSizesTop8 <- clustSizes[, 1:8]
        clustPropsTop8 <- clustProps[, 1:8]
        
        clustSizesTop8 <- cbind(clustSizesTop8, c(rowSums(clustSizes) - rowSums(clustSizesTop8)))
        clustPropsTop8 <- cbind(clustPropsTop8, c(rowSums(clustProps) - rowSums(clustPropsTop8)))
        colnames(clustSizesTop8)[9] <- colnames(clustPropsTop8)[9] <- "Other"
    
        
        #######################################################################
        # Hybrid approach, 8 largest clusters + aggregated sizes for the rest #
        #######################################################################
        
        t <- aggrSizes[, 2:ncol(aggrSizes)]
        t[, 1] <- t[, 1] + aggrSizes[, 1] - rowSums(clustSizesTop8[, 1:8])
        clustSizesHybrid <- cbind(clustSizesTop8[, 1:8], t)
        
        t <- aggrProps[, 2:ncol(aggrProps)]
        t[, 1] <- t[, 1] + aggrProps[, 1] - rowSums(clustPropsTop8[, 1:8])
        clustPropsHybrid <- cbind(clustPropsTop8[, 1:8], t)
     
        return(list(sampleBreaks = sampleBreaks, 
                    clustSizes   = clustSizes, 
                    clustProps   = clustProps, 
                    aggrSizes    = aggrSizes, 
                    aggrProps    = aggrProps, 
                    clustSizesTop8   = clustSizesTop8, 
                    clustPropsTop8   = clustPropsTop8, 
                    clustSizesHybrid = clustSizesHybrid, 
                    clustPropsHybrid = clustPropsHybrid))
    }
   
```


\clearpage


# Sample breakdown (daily)

```{r samples-vs-lineage-age-absolute, fig.width=7, fig.height=3, fig.cap = "Number of genomes collected each day, coloured by the time since the age of the transmission lineage when the genome was collected (time from the oldest sampled genome in the lineage to the sampling time of the genome). Note that **only** genomes in transmission lineages are shown (no singletons)."}

    for (s in 1:nrow(stateFiles)) {
      state <- stateFiles$state[s]
      clusterStatsMCC <- stateInfo$clusterStatsMCC[[s]]
      clusterSamplesMCCnoSingles <- stateInfo$clusterSamplesMCCnoSingles[[s]]

      
    maxBreakSize <- max(clusterSamplesMCCnoSingles[["lineage_age"]]) + 10

    sampleVsLineageAge <- getSampleBreakdown(clusterStatsMCC, clusterSamplesMCCnoSingles, dateBreaks,
                                             #stat="lineage_age", breaks=seq(2019, 2022, by=0.2))
                                             stat="lineage_age", breaks=seq(-20, maxBreakSize, by=10))
    date_count <- metadata[stateInfo$metadata_instate[,s],] %>% filter(!is.na(sample_date)) %>% dplyr::count(sample_date) 
    
    maxSeqPerDay <- max(date_count$n)
    maxSeqPerDay <- max(rowSums(sampleVsLineageAge)) * 1.05

    par(mar=c(4,4,2.5,8), cex.axis=0.7, cex.lab=0.8, mgp=c(2,0.75,0))
    plotDateGradient(sampleVsLineageAge, dateBreaks, startDate=startDate, endDate=endDate, plotLegend=TRUE,
                     ymax=maxSeqPerDay, normalise=FALSE, ylab="No. of sampled genomes\n(per day)", main=paste(state), 
                     palfn=inferno, direction=-1, alpha=1, legend = "Lineage age\n(weeks)")
    
    # plotDateGradient(sampleVsLineageAge, dateBreaks, startDate=as.Date("2020-06-01"), endDate=as.Date("2021-03-15"), plotLegend=TRUE,
    #                  ymax=maxSeqPerDay, normalise=FALSE, ylab="No. of sampled genomes\n(per day)",
    #                  palfn=inferno, direction=-1, alpha=1, legend = "Lineage age\n(weeks)")
  }
    
```

```{r samples-vs-lineage-age-proportion, fig.width=7, fig.height=3, fig.cap = "Proportion of genomes collected each day, coloured by the time since the age of the transmission lineage when the genome was collected (time from the oldest sampled genome in the lineage to the sampling time of the genome). Note that **only** genomes in transmission lineages are shown (no singletons)."}

#    par(mar=c(4,4,2.5,8), cex.axis=0.7, cex.lab=0.8, mgp=c(2,0.75,0))
#    plotDateGradient(sampleVsLineageAge, dateBreaks, startDate="2020-03-01", endDate="2020-06-07", plotLegend=TRUE,
#                     normalise=TRUE, ylab="Proportion of sampled genomes\n(per day)", axes=TRUE, 
#                     palfn=inferno, direction=-1, alpha=1, legend="Lineage age\n(weeks)")
    
```



```{r samples-vs-lineage-tmrca-absolute, fig.width=7, fig.height=3, fig.cap = "Number of genomes collected each day, coloured by the TMRCA of the transmission lineage. Note that **only** genomes in transmission lineages are shown (no singletons)."}

    for (s in 1:nrow(stateFiles)) {
      state <- stateFiles$state[s]
      clusterStatsMCC <- stateInfo$clusterStatsMCC[[s]]
      clusterSamplesMCCnoSingles <- stateInfo$clusterSamplesMCCnoSingles[[s]]


    tmrcaBreaks <- seq(startDate, endDate, by="week")
    sampleVsLineageTMRCA <- getSampleBreakdown(clusterStatsMCC[,], 
                                               clusterSamplesMCCnoSingles, 
                                               dateBreaks,
                                               stat="lineage_tmrca_calendar", 
                                               breaks=tmrcaBreaks)

    maxSeqPerDay <- max(rowSums(sampleVsLineageTMRCA)) + 2

    par(mar=c(4,4,2.5,8), cex.axis=0.7, cex.lab=0.8, mgp=c(2,0.75,0))
    plotDateGradient(sampleVsLineageTMRCA, dateBreaks, startDate=startDate, endDate=endDate, plotLegend=TRUE,
                     ymax=maxSeqPerDay, normalise=FALSE, ylab="No. of sampled genomes\n(per day)", main=paste(state), 
                     palfn=inferno, direction=-1, alpha=1, legend = "Lineage TMRCA", legendTicks = tmrcaBreaks)

    }
```

```{r samples-vs-lineage-tmrca-proportion, fig.width=7, fig.height=3, fig.cap = "Proportion of genomes collected each day, coloured by the TMRCA of the transmission lineage. Note that **only** genomes in transmission lineages are shown (no singletons)."}

#    par(mar=c(4,4,2.5,8), cex.axis=0.7, cex.lab=0.8, mgp=c(2,0.75,0))
#    plotDateGradient(sampleVsLineageTMRCA, dateBreaks, startDate="2020-03-01", endDate="2020-06-07", plotLegend=TRUE,
#                     normalise=TRUE, ylab="Proportion of sampled genomes\n(per day)", axes=TRUE, 
#                     palfn=inferno, direction=-1, alpha=1, legend="Lineage TMRCA", legendTicks = tmrcaBreaks)

```

\clearpage

# Sample breakdown into lineages (weekly)

```{r sample-breakdown-weekly}
    
    stateInfo$weeklyBreakdown <- list()
    for (s in 1:nrow(stateFiles)) {
      state <- stateFiles$state[s]
      clusterSamplesMCC <- stateInfo$clusterSamplesMCC[[s]]
      
  # test
    stateInfo$weeklyBreakdown[[s]] <- getSampleLineageBreakdown(clusterSamplesMCC, breaks="weeks", startDate = startDate, endDate = endDate)

    ###################
    # Figure captions # 
    ###################
    sample_breakdown_weekly_absolute_cap   <- 
    sample_breakdown_weekly_proportion_cap <- paste0("Lineage size breakdown of ", state, " genomes collected each week. The 8 largest lineages are coloured.")
    
    sample_breakdown_weekly_absolute_top8_cap   <- paste0("Lineage size breakdown of ", state, " genomes in the 8 largest lineages collected each week.")

    sample_breakdown_weekly_lineages_absolute_cap   <-
    sample_breakdown_weekly_lineages_proportion_cap <- paste0("Lineage size breakdown of ", state, " genomes collected each week.")
    
    sample_breakdown_weekly_aggr_absolute_cap   <- 
    sample_breakdown_weekly_aggr_proportion_cap <- paste0("Lineage size breakdown of ", state, " genomes collected each week.")
  }
```



```{r sample-breakdown-weekly-absolute, fig.width=7, fig.height=3, fig.cap = sample_breakdown_weekly_absolute_cap, eval=TRUE}

    for (s in 1:nrow(stateFiles)) {
      state <- stateFiles$state[s]
      clusterStatsMCC <- stateInfo$clusterStatsMCC[[s]]
      clusterSamplesMCC <- stateInfo$clusterSamplesMCC[[s]]
      weeklyBreakdown <- stateInfo$weeklyBreakdown[[s]]

    par(mar=c(4,4,2.5,8), cex.axis=0.7, cex.lab=0.8, mgp=c(2,0.75,0))

    cols <- c(mPal(unlist(countryPal), 0.75)[c(2,3,4,6,10,8,11,12)], gray.colors(n = 4, start=0.75, end=0, alpha = 0.75)) 
    
#    dateFreqDistribution(t(weeklyBreakdown$clustSizesHybrid), weeklyBreakdown$sampleBreaks, plot.ci=FALSE,  barplot=FALSE, 
#                         startDate = startDate, endDate = endDate, 
#                         col=cols, border = "#000000", 
#                         ymax = 5000, ylab = "Weekly no. of sampled genomes")
    
    dateFreqDistribution(t(weeklyBreakdown$clustSizesHybrid), weeklyBreakdown$sampleBreaks, plot.ci=FALSE,  barplot=FALSE, 
                         startDate = weeklyBreakdown$sampleBreaks[1], endDate = weeklyBreakdown$sampleBreaks[length(weeklyBreakdown$sampleBreaks)-1], 
                         col=cols, border = "#000000", 
                         ymax = max(rowSums(weeklyBreakdown$clustSizes)) + 2, 
                         ylab = "Weekly no. of sampled genomes")

    legendText1 <- c()
    for (cluster in colnames(weeklyBreakdown$clustSizesHybrid)[1:8]) {
        i    <- which(clusterStatsMCC$cluster == cluster)
        size <- clusterStatsMCC$seqs[i]
        duration <- lubridate::round_date(lubridate::date_decimal(clusterStatsMCC$mostrecent[i]), unit="day") -
                    lubridate::round_date(lubridate::date_decimal(clusterStatsMCC$tmrca[i]), unit="day")
        
        clusterSimple <- paste("Importation_lineage",strsplit(strsplit(cluster, split="_")[[1]][1],split="-")[[1]][3], sep = "_")
        
        # clusterSimple <- paste("Importation_lineage", paste(strsplit( gsub("-", "_", cluster), split="_")[[1]][c(3,6,7)], collapse="_") , sep = "_")
        
        clusterSimple <- cluster;
        legendText1   <- c(legendText1, sprintf("%s\n(%d genomes, %d days)", clusterSimple, size, duration))
    }
    legend("left", horiz=FALSE, inset=c(1,-0), bty='n', xpd=TRUE, ncol=1,
           fill=cols[1:8], border = "#000000", 
           legend = legendText1, y.intersp = 2,
           cex=0.6)
    
    legendText2 <- c(sprintf("Bigger than 100 (n = %d)", sum(clusterStatsMCC$seqs > 100)),
                     sprintf("11 to 100 (n = %d)", sum(clusterStatsMCC$seqs <= 100 & clusterStatsMCC$seqs > 10)), 
                     sprintf("10 or smaller (n = %d)", sum(clusterStatsMCC$seqs <= 10)), 
                     sprintf("Singletons (n = %d)", sum(metadata$instate) - sum(clusterStatsMCC$seqs)))
    legend("top", horiz=FALSE, inset=c(0,-0.33), bty='n', xpd=TRUE, ncol=2,
           fill=cols[9:12], border = "#000000", 
           legend = legendText2, title = paste("Transmission lineage size of", state),
           cex=0.8)

    stateInfo$legendText1[[s]] <- legendText1
    stateInfo$legendText2[[s]] <- legendText2
  }
```


```{r sample-breakdown-weekly-absolute-top8, fig.width=14, fig.height=12, fig.cap = "The weekly sampling frequency of the 8 largest `r state` transmission lineages.", eval=TRUE}

for (s in stateInfo$stateOrder) { 
  state <- stateFiles$state[s]
  clusterStatsMCC <- stateInfo$clusterStatsMCC[[s]]
  clusterSamplesMCC <- stateInfo$clusterSamplesMCC[[s]]
  weeklyBreakdown <- stateInfo$weeklyBreakdown[[s]]
  legendText1 <- stateInfo$legendText1[[s]]
  legendText2 <- stateInfo$legendText2[[s]]
  
  
  par(mar=c(4,4,2.5,8), cex.axis=1, cex.lab=1.2, cex.main=1.2, mgp=c(3,0.75,0))
  
  cols <- c(mPal(unlist(countryPal), 0.75)[c(2,3,4,6,10,8,11,12)], gray.colors(n = 4, start=0.75, end=0, alpha = 0.75)) 
  
  
  layout(matrix(1:8, nrow=4))
  for (i in 1:8) {
    
    dateFreqDistribution(t(weeklyBreakdown$clustSizesTop8[, i]), weeklyBreakdown$sampleBreaks, plot.ci=FALSE,  barplot=FALSE, 
                         startDate = "2020-10-28", endDate="2021-06-02",
                         # startDate = weeklyBreakdown$sampleBreaks[1], endDate = #weeklyBreakdown$sampleBreaks[length(weeklyBreakdown$sampleBreaks)], 
                         col=cols[i], border = "#000000", 
                         ymax = max(weeklyBreakdown$clustSizesTop8[,1:8])+2, ylab = "Weekly no. of sampled genomes")
    
    mtext(side=3, line=0.5, gsub("\n", " ", legendText1[i]), cex=par("cex.main"))
    
    x <- startDate - 0.075*(endDate - startDate)
    mtext(text = paste(state, LETTERS[i]), side=3, line=0.5, at=x, cex = par("cex.main"))
    
  }
}

```

```{r sample-breakdown-weekly-proportion, fig.width=7, fig.height=3, fig.cap = sample_breakdown_weekly_proportion_cap, eval=TRUE}


for (s in 1:nrow(stateFiles)) {
  state <- stateFiles$state[s]
  clusterStatsMCC <- stateInfo$clusterStatsMCC[[s]]
  clusterSamplesMCC <- stateInfo$clusterSamplesMCC[[s]]
  weeklyBreakdown <- stateInfo$weeklyBreakdown[[s]]
  legendText1 <- stateInfo$legendText1[[s]]
  legendText2 <- stateInfo$legendText2[[s]]
  
  par(mar=c(4,4,2.5,8), cex.axis=0.7, cex.lab=0.8, mgp=c(2,0.75,0))
  
  
  cols <- c(mPal(unlist(countryPal), 0.75)[c(2,3,4,6,10,8,11,12)], gray.colors(n = 4, start=0.75, end=0, alpha = 0.75)) 
  
  dateFreqDistribution(t(weeklyBreakdown$clustPropsHybrid), weeklyBreakdown$sampleBreaks, plot.ci=FALSE,  barplot=FALSE, 
                         startDate = "2020-10-28", endDate="2021-05-26",
                       # startDate = weeklyBreakdown$sampleBreaks[1], 
                       # endDate = weeklyBreakdown$sampleBreaks[length(weeklyBreakdown$sampleBreaks)-1], 
                       #startDate = "2020-03-01", endDate = "2020-06-07", 
                       col=cols, border = "#000000",
                       ymax = 1, ylab = "Proportion of sampled genomes\n(per week)", axes=TRUE)
  
  legend("left", horiz=FALSE, inset=c(1,-0), bty='n', xpd=TRUE, ncol=1,
         fill=cols[1:8], border = "#000000", 
         legend = legendText1, y.intersp = 2,
         cex=0.6)
  
  legend("top", horiz=FALSE, inset=c(0,-0.33), bty='n', xpd=TRUE, ncol=2,
         fill=cols[9:12], border = "#000000", 
         legend = legendText2, title = paste("Transmission lineage size of", state),
         cex=0.8)
}


```

```{r sample-breakdown-weekly-proportion-germany-based, fig.width=7, fig.height=3, fig.cap = sample_breakdown_weekly_proportion_cap, eval=TRUE}

germanyState <- which(stateFiles$state == "Germany")
germanyClusterStatsMCC <- stateInfo$clusterStatsMCC[[germanyState]]
germanyLargeClusters <- germanyClusterStatsMCC[order(-germanyClusterStatsMCC$seqs)[1:8],]$cluster
germanyClusterSamplesMCC <- stateInfo$clusterSamplesMCC[[germanyState]]

getSampleLargeClusterIndex <- function(sample) {
  if (sample$cluster %in% germanyLargeClusters)
    return(which(sample$cluster == germanyLargeClusters))
  else
    return(length(germanyLargeClusters)+1)
}

stateInfo$clusterSamplesMCC[[germanyState]]$cluster_category <- 
  sapply(seq_len(nrow(stateInfo$clusterSamplesMCC[[germanyState]])), 
         function(i) getSampleLargeClusterIndex(stateInfo$clusterSamplesMCC[[germanyState]][i,]))

# germany is removed from this charts, since it shows the lineages of Germany in other states
for (s in tail(stateInfo$stateOrder, -1)) { 
  state <- stateFiles$state[s]
  state.name <- stateFiles$state.name[s]
  clusterStatsMCC <- stateInfo$clusterStatsMCC[[s]]
  clusterSamplesMCC <- stateInfo$clusterSamplesMCC[[s]]
  weeklyBreakdown <- stateInfo$weeklyBreakdown[[s]]
  
  
  
  sampleBreaks      <- seq.Date(as.Date(startDate), as.Date(endDate), by="week")
  uksamples <- droplevels(germanyClusterSamplesMCC[set_instate(germanyClusterSamplesMCC, state.name), ])
  clustNames <- seq_len(length(germanyLargeClusters)+1)
  
  clustSizes <- c()
  for (cluster in clustNames) {
    sampleDates <- uksamples$sample_date[uksamples$cluster_category == cluster]
    sampleHist  <- hist(sampleDates, breaks=sampleBreaks, plot=FALSE, right=FALSE)
    clustSizes  <- cbind(clustSizes, sampleHist$counts)
  }
  rownames(clustSizes) <- format.Date(sampleBreaks[1:(length(sampleBreaks)-1)])
  colnames(clustSizes) <- clustNames
  
  clustPropsHybrid <- t(apply(clustSizes, 1, function(x) if(sum(x) == 0) x else x/sum(x)))
  
  
  # stateSamplesBreakdownWithGermany$sampleBreaks <- sampleBreaks
  # stateSamplesBreakdownWithGermany$clustPropsHybrid
  # 
  # 
  # clusterSamplesMCCTmp <- stateInfo$clusterSamplesMCC[[germanyState]]
  # clusterSamplesMCCTmp$instate <- set_instate(clusterSamplesMCCTmp, state)
  # stateSamplesBreakdownWithGermany <- getSampleLineageBreakdown(clusterSamplesMCCTmp, breaks="weeks", startDate = startDate, endDate = endDate)
  legendText1 <- stateInfo$legendText1[[germanyState]]
  legendText2 <- stateInfo$legendText2[[germanyState]]
  
  
  par(mar=c(4,4,2.5,8), cex.axis=0.7, cex.lab=0.8, mgp=c(2,0.75,0))
  
  
  cols <- c(mPal(unlist(countryPal), 0.75)[c(2,3,4,6,10,8,11,12)], gray.colors(n = 4, start=0.75, end=0, alpha = 0.75)) 
  
  dateFreqDistribution(t(clustSizes[]), 
                       sampleBreaks, plot.ci=FALSE,  barplot=FALSE, 
                       startDate = sampleBreaks[1], 
                       endDate = sampleBreaks[length(sampleBreaks)-1], 
                       #startDate = "2020-03-01", endDate = "2020-06-07", 
                       col=cols, border = "#000000",
                       ymax = max(rowSums(clustSizes)) * 1.05, ylab = "Number of sampled genomes\n(per week)", axes=TRUE)
  
  legend("left", horiz=FALSE, inset=c(1,-0), bty='n', xpd=TRUE, ncol=1,
         fill=cols[1:8], border = "#000000", 
         legend = legendText1, y.intersp = 2,
         cex=0.6)
  
  legend("top", horiz=FALSE, inset=c(0,-0.33), bty='n', xpd=TRUE, ncol=2,
         fill=cols[9:12], border = "#000000", 
         legend = legendText2, title = paste("Transmission lineage size of", state),
         cex=0.8)
  
  
  
  
  dateFreqDistribution(t(clustPropsHybrid[]), 
                       sampleBreaks, plot.ci=FALSE,  barplot=FALSE, 
                       startDate = sampleBreaks[1], 
                       endDate = sampleBreaks[length(sampleBreaks)-1], 
                       #startDate = "2020-03-01", endDate = "2020-06-07", 
                       col=cols, border = "#000000",
                       ymax = 1, ylab = "Proportion of sampled genomes\n(per week)", axes=TRUE)
  
  legend("left", horiz=FALSE, inset=c(1,-0), bty='n', xpd=TRUE, ncol=1,
         fill=cols[1:8], border = "#000000", 
         legend = legendText1, y.intersp = 2,
         cex=0.6)
  
  legend("top", horiz=FALSE, inset=c(0,-0.33), bty='n', xpd=TRUE, ncol=2,
         fill=cols[9:12], border = "#000000", 
         legend = legendText2, title = paste("Transmission lineage size of", state),
         cex=0.8)
}



```

```{r sample-breakdown-weekly-proportion-germany-based-onmap, fig.width=5, fig.height=3, fig.cap = sample_breakdown_weekly_proportion_cap, eval=TRUE}

germanyState <- which(stateFiles$state == "Germany")
germanyClusterStatsMCC <- stateInfo$clusterStatsMCC[[germanyState]]
germanyLargeClusters <- germanyClusterStatsMCC[order(-germanyClusterStatsMCC$seqs)[1:8],]$cluster
germanyClusterSamplesMCC <- stateInfo$clusterSamplesMCC[[germanyState]]

getSampleLargeClusterIndex <- function(sample) {
  if (sample$cluster %in% germanyLargeClusters)
    return(which(sample$cluster == germanyLargeClusters))
  else
    return(length(germanyLargeClusters)+1)
}

stateInfo$clusterSamplesMCC[[germanyState]]$cluster_category <- 
  sapply(seq_len(nrow(stateInfo$clusterSamplesMCC[[germanyState]])), 
         function(i) getSampleLargeClusterIndex(stateInfo$clusterSamplesMCC[[germanyState]][i,]))

stateInfo$clusterSamplesMCC[[germanyState]]$adm1 <- sapply(
  str_split(paste0(stateInfo$clusterSamplesMCC[[germanyState]]$Location,"/",stateInfo$clusterSamplesMCC[[germanyState]]$Additional.location.information), "/"), function(x) str_trim(x[3]) )

stateInfo$clusterSamplesMCC[[germanyState]]$adm1[stateInfo$clusterSamplesMCC[[germanyState]]$adm1 == "Baden-Württemberg"] <- "Baden-Wurttemberg"
# stateInfo$clusterSamplesMCC[[germanyState]]$adm1[stateInfo$clusterSamplesMCC[[germanyState]]$adm1 == "NA"] <- "NA"
adm1.rows <- unique(stateInfo$clusterSamplesMCC[[germanyState]]$adm1)
adm1.rows <- c(adm1.rows[-which(adm1.rows == "NA")], "NA")


aggs <- stateInfo$clusterSamplesMCC[[germanyState]] %>% group_by(cluster_category, adm1) %>% dplyr::summarize(c = length(Accession.ID))
aggs.matrix <- matrix(0, nrow=length(adm1.rows), ncol=length(unique(aggs$cluster_category)))
dimnames(aggs.matrix) <- list(adm1.rows,
                              unique(aggs$cluster_category))
for (i in 1:nrow(aggs)) {
  aggs.matrix[aggs$adm1[i], match(aggs$cluster_category[i], unique(aggs$cluster_category))] <- aggs$c[i]
}
cols <- c(mPal(unlist(countryPal), 0.75)[c(2,3,4,6,10,8,11,12)], gray.colors(n = 4, start=0.75, end=0, alpha = 0.75)) 



par(mar=c(6,2,1,1), cex.axis=0.7, cex.lab=0.7, mgp=c(2,0.75,0))



for (cluster in 1:length(germanyLargeClusters)) {
  x <- barplot2(aggs.matrix[,cluster], col=cols[cluster], las=2, ylim=c(0,400))
  # text(cex=1, x=x-.25, y=-1.25, rownames(aggs.matrix), xpd=TRUE, srt=90)
}

```

```{r large_lineages_on_map, fig.width = 5, fig.height = 4}

# germany <- getData(country = "Germany", level = 1) 
# 
# ggplot(data = germany, aes(x = long, y = lat, group = group, fill)) +
#   geom_polygon(colour = "grey10", fill = "#fff7bc") +
#     coord_equal() +
#     theme()
# germany <- readRDS(url("https://biogeo.ucdavis.edu/data/gadm3.6/Rsp/gadm36_DEU_1_sp.rds"))



germany <- raster::getData("GADM", country = "DEU", level = 1)
germany.f <- fortify(germany, region = "CC_1")

mapNames <- germany$VARNAME_1
mapNames[is.na(mapNames)] <- germany$NAME_1[is.na(mapNames)]
mapNames[mapNames == "Baden-Württemberg"] <- "Baden-Wurttemberg"
mapNames[mapNames == "Mecklenburg-West Pomerania"] <- "Mecklenburg-Western Pomerania"

cols <- c(mPal(unlist(countryPal), 0.75)[c(2,3,4,6,10,8,11,12)], gray.colors(n = 4, start=0.75, end=0, alpha = 0.75)) 


for (cluster in 1:length(germanyLargeClusters)) {
  germany$value <- aggs.matrix[match(mapNames, rownames(aggs.matrix)), cluster]
  germany.f$value <- germany$value[match(germany.f$id, germany$CC_1)]
  # col <- dePal[[germanyState]]
  col <- cols[cluster]
  p <- ggplot(data = germany.f, aes(x = long, y = lat, group = group, fill = value)) +
    geom_polygon(colour = "grey10")+
    scale_fill_gradient(low = lighten(col, 1), high = col, space = "Lab", limits=c(0, max(germany$value)), 
                        name = "Number of sequences")+
    ggtitle(germanyLargeClusters[cluster]) +
    theme(axis.line=element_blank(), axis.text.x=element_blank(),
          axis.text.y=element_blank(), axis.ticks=element_blank(),
          axis.title.x=element_blank(),
          axis.title.y=element_blank(),
          panel.background=element_blank(), panel.grid.major=element_blank(),
          panel.border = element_rect(colour = "black", fill=NA, size=0.1),
          panel.grid.minor=element_blank(), plot.background=element_blank()) 
  print(p)
}
    
```



```{r large_lineages_on_map_evolution, fig.width = 5, fig.height = 4}

clusterSamplesMCC <- stateInfo$clusterSamplesMCC[[germanyState]]

germany <- raster::getData("GADM", country = "DEU", level = 1)
germany.f <- fortify(germany, region = "CC_1")

mapNames <- germany$VARNAME_1
mapNames[is.na(mapNames)] <- germany$NAME_1[is.na(mapNames)]
mapNames[mapNames == "Baden-Württemberg"] <- "Baden-Wurttemberg"
mapNames[mapNames == "Mecklenburg-West Pomerania"] <- "Mecklenburg-Western Pomerania"

cols <- c(mPal(unlist(countryPal), 0.75)[c(2,3,4,6,10,8,11,12)], gray.colors(n = 4, start=0.75, end=0, alpha = 0.75)) 

 for (cluster in 1:length(germanyLargeClusters)) {
# cluster <- 1
  oldest <- min(clusterSamplesMCC$decimal_date[clusterSamplesMCC$cluster == germanyLargeClusters[cluster]])
  newest <- max(clusterSamplesMCC$decimal_date[clusterSamplesMCC$cluster == germanyLargeClusters[cluster]])
  starting_counties_count <- table(clusterSamplesMCC$adm1[clusterSamplesMCC$cluster == germanyLargeClusters[cluster] & clusterSamplesMCC$decimal_date == oldest])
  starting_counties <- levels(as.factor(clusterSamplesMCC$adm1[clusterSamplesMCC$cluster == germanyLargeClusters[cluster] & clusterSamplesMCC$decimal_date == oldest]))
  starting_points_ = sapply(starting_counties, function(county) { map_id <- germany$CC_1[mapNames == county]; cond <- germany.f$id == map_id; return(data.frame(long=mean(germany.f$long[cond]), lat=mean(germany.f$lat[cond]))); })
  starting_points = data.frame(long=unlist(starting_points_[1,]), lat=unlist(starting_points_[2,]), ratio = c(starting_counties_count[starting_counties]) / sum(starting_counties_count) )
  
  germany$value <- aggs.matrix[match(mapNames, rownames(aggs.matrix)), cluster]
  germany.f$value <- germany$value[match(germany.f$id, germany$CC_1)]
  maxcase <- max(germany$value)

    # col <- dePal[[germanyState]]
  col <- cols[cluster]
  p <- ggplot() + 
    geom_polygon(data = germany.f, aes(x = long, y = lat, group = group, fill = 0), colour = "grey10")+
    scale_fill_gradient(low = lighten(col, 1), high = col, space = "Lab", limits=c(0, maxcase), guide = FALSE)+
    geom_point(data=starting_points, mapping=aes(x=long, y=lat), size=20 * starting_points$ratio, col=col) +
    ggtitle(paste("State of oldest sample(s) of", germanyLargeClusters[cluster])) +
    theme(axis.line=element_blank(), axis.text.x=element_blank(),
          axis.text.y=element_blank(), axis.ticks=element_blank(),
          axis.title.x=element_blank(),
          axis.title.y=element_blank(),
          panel.background=element_blank(), panel.grid.major=element_blank(),
          panel.border = element_rect(colour = "black", fill=NA, size=0.1),
          panel.grid.minor=element_blank(), plot.background=element_blank(), 
          aspect.ratio = (max(germany.f$long) - min(germany.f$long))/(max(germany.f$lat) - min(germany.f$lat)))
  print(p)
  
  divCount = 4
  samples <- stateInfo$clusterSamplesMCC[[germanyState]][stateInfo$clusterSamplesMCC[[germanyState]]$cluster == germanyLargeClusters[cluster],]
  samples$date_prtition <- floor((samples$decimal_date - oldest)/(newest - oldest+1/365)* divCount) + 1
  
  aggsTimed <- samples %>% group_by(date_prtition, adm1) %>% dplyr::summarize(c = length(Accession.ID))

  for (i in 1:divCount) {
    aggsTimedPartition <- as.data.frame(aggsTimed[aggsTimed$date_prtition == i,])
    for (ad in setdiff(mapNames, aggsTimedPartition$adm1)) {
      aggsTimedPartition <- aggsTimedPartition %>% add_row(date_prtition=1, adm1=ad, c=0)
    }
    
    startDate <- format(date_decimal((newest - oldest+1/365) / divCount* (i-1) + oldest), format="%Y-%m-%d")
    endDate <- format(date_decimal((newest - oldest+1/365) /divCount * (i) + oldest), format="%Y-%m-%d")
    
    
    
    germany$value <- aggsTimedPartition$c[match(mapNames, aggsTimedPartition$adm1)]
    germany.f$value <- germany$value[match(germany.f$id, germany$CC_1)]
  p <- ggplot() + 
    geom_polygon(data = germany.f, aes(x = long, y = lat, group = group, fill = value), colour = "grey10")+
    scale_fill_gradient(low = lighten(col, 1), high = col, space = "Lab", limits=c(0, maxcase),
                        name = "Number of sequences")+
    # geom_point(data=starting_points, mapping=aes(x=long, y=lat), size=5, col=col) +
    ggtitle(paste(germanyLargeClusters[cluster], startDate, "-", endDate)) +
    theme(axis.line=element_blank(), axis.text.x=element_blank(),
          axis.text.y=element_blank(), axis.ticks=element_blank(),
          axis.title.x=element_blank(),
          axis.title.y=element_blank(),
          panel.background=element_blank(), panel.grid.major=element_blank(),
          panel.border = element_rect(colour = "black", fill=NA, size=0.1),
          panel.grid.minor=element_blank(), plot.background=element_blank(), 
          aspect.ratio = (max(germany.f$long) - min(germany.f$long))/(max(germany.f$lat) - min(germany.f$lat)))
  print(p)
  }
  
  germany$value <- aggs.matrix[match(mapNames, rownames(aggs.matrix)), cluster]
  germany.f$value <- germany$value[match(germany.f$id, germany$CC_1)]
  p <- ggplot() + 
    geom_polygon(data = germany.f, aes(x = long, y = lat, group = group, fill = value), colour = "grey10")+
    scale_fill_gradient(low = lighten(col, 1), high = col, space = "Lab", limits=c(0, maxcase),
                        name = "Number of sequences")+
    # geom_point(data=starting_points, mapping=aes(x=long, y=lat), size=5, col=col) +
    ggtitle(paste(germanyLargeClusters[cluster], format(date_decimal(oldest), format="%Y-%m-%d"), format(date_decimal(newest), format="%Y-%m-%d"))) +
    theme(axis.line=element_blank(), axis.text.x=element_blank(),
          axis.text.y=element_blank(), axis.ticks=element_blank(),
          axis.title.x=element_blank(),
          axis.title.y=element_blank(),
          panel.background=element_blank(), panel.grid.major=element_blank(),
          panel.border = element_rect(colour = "black", fill=NA, size=0.1),
          panel.grid.minor=element_blank(), plot.background=element_blank(), 
          aspect.ratio = (max(germany.f$long) - min(germany.f$long))/(max(germany.f$lat) - min(germany.f$lat)))
  print(p)
  
  
}
    
```
```{r distribution_of_first_cases, fig.width = 5, fig.height = 4}

clusterSamplesMCC <- stateInfo$clusterSamplesMCC[[germanyState]]
clusterStatsMCC <- stateInfo$clusterStatsMCC[[germanyState]]

germany <- raster::getData("GADM", country = "DEU", level = 1)
germany.f <- fortify(germany, region = "CC_1")

mapNames <- germany$VARNAME_1
mapNames[is.na(mapNames)] <- germany$NAME_1[is.na(mapNames)]
mapNames[mapNames == "Baden-Württemberg"] <- "Baden-Wurttemberg"
mapNames[mapNames == "Mecklenburg-West Pomerania"] <- "Mecklenburg-Western Pomerania"

cols <- c(mPal(unlist(countryPal), 0.75)[c(2,3,4,6,10,8,11,12)], gray.colors(n = 4, start=0.75, end=0, alpha = 0.75)) 


largeLineages <- clusterStatsMCC[order(-clusterStatsMCC$seqs)[1:min(100, nrow(clusterStatsMCC))], ]

filteredClusterSamples <- clusterSamplesMCC[clusterSamplesMCC$cluster %in% largeLineages$cluster,]

firstCaseCount <- data.frame(adm1 = filteredClusterSamples$adm1[filteredClusterSamples$decimal_date - filteredClusterSamples$lineage_oldest < 1/365]) %>% dplyr::count(adm1)
for (ad in setdiff(mapNames, firstCaseCount$adm1)) {
  firstCaseCount <- firstCaseCount %>% add_row(adm1=ad, n=0)
}


  germany$value <- firstCaseCount$n[match(mapNames, firstCaseCount$adm1)]
  germany.f$value <- germany$value[match(germany.f$id, germany$CC_1)]

  col <- cols[1]
  p <- ggplot() + 
    geom_polygon(data = germany.f, aes(x = long, y = lat, group = group, fill = value), colour = "grey10")+
    scale_fill_gradient(low = lighten(col, 1), high = col, space = "Lab", limits=c(0, max(germany$value)),
                        name = "Number of first cases")+
    # geom_point(data=starting_points, mapping=aes(x=long, y=lat), size=5, col=col) +
    # ggtitle(paste(germanyLargeClusters[cluster])) +
    theme(axis.line=element_blank(), axis.text.x=element_blank(),
          axis.text.y=element_blank(), axis.ticks=element_blank(),
          axis.title.x=element_blank(),
          axis.title.y=element_blank(),
          panel.background=element_blank(), panel.grid.major=element_blank(),
          panel.border = element_rect(colour = "black", fill=NA, size=0.1),
          panel.grid.minor=element_blank(), plot.background=element_blank())
  print(p)
  
metadata$adm1 <- sapply(
  str_split(paste0(metadata$Location,"/",metadata$Additional.location.information), "/"), function(x) str_trim(x[3]) )

  sample_count <- data.frame(adm1=metadata$adm1[metadata$country == "Germany"]) %>% dplyr::count(adm1)
  firstCaseAndSamples <- firstCaseCount %>% left_join(sample_count, by="adm1") %>% dplyr::filter(adm1 != "NA") %>% dplyr::rename(no.first.cases=n.x, no.total.cases=n.y)
  knitr::kable(firstCaseAndSamples, col.names = c("State",
                           "No. First Cases",
                           "No. Total Cases"), row.names=FALSE, caption = "Distribution of first cases of imported lineages in states") 
  
```


```{r germany_lineage_cs_states, fig.width = 5, fig.height = 4}

  # FOR NON-GERMANY:
# 
#   selectedClusters <- c()
#   for (s in stateInfo$stateOrder[stateInfo$stateOrder != germanyState]) { 
#       state <- stateFiles$state[s]
#       clusterStatsMCC <- stateInfo$clusterStatsMCC[[s]]
#       clusterSamplesMCC <- stateInfo$clusterSamplesMCC[[s]]
#       weeklyBreakdown <- stateInfo$weeklyBreakdown[[s]]
#       legendText1 <- stateInfo$legendText1[[s]]
#       legendText2 <- stateInfo$legendText2[[s]]
#       
#       clusterOneSample <- clusterSamplesMCC[!duplicated(clusterSamplesMCC$cluster), c("cluster", "Accession.ID")]
#       
#       clusterOneSample$germanyLineage <- stateInfo$clusterSamplesMCC[[germanyState]]$cluster[match(clusterOneSample$Accession.ID, stateInfo$clusterSamplesMCC[[germanyState]]$Accession.ID)]
#       
#       
#       clusterStatsMCC$germanyLineage <- clusterOneSample$germanyLineage[match(clusterStatsMCC$cluster, clusterOneSample$cluster)]
#       clusterStatsMCC$state <- s
#       
#       selectedClusters <- rbind(selectedClusters, 
#         clusterStatsMCC[clusterStatsMCC$germanyLineage %in% germanyLargeClusters & clusterStatsMCC$seqs > 10,]
#       )
#   }
#   
#   selectedClusters$germanyLineageIndex <- match(selectedClusters$germanyLineage, germanyLargeClusters)
#   
#   rows <- unique(selectedClusters$state)
#   cols <- unique(selectedClusters$germanyLineageIndex)
#   state_germany_large_lineage <- matrix("", nrow=length(rows), ncol=length(cols))
#   rownames(state_germany_large_lineage) <- stateFiles$state.name[rows]
#   colnames(state_germany_large_lineage) <- germanyLargeClusters[cols]
#   for (i in seq_len(nrow(selectedClusters))) {
#     st <- which(rows == selectedClusters$state[i])
#     gc <- which(cols == selectedClusters$germanyLineageIndex[i])
#     cl <- str_replace(str_replace(selectedClusters$cluster[i], ".*20210417-", ""), "_.*", "")
#     state_germany_large_lineage[st, gc] <- ifelse(state_germany_large_lineage[st, gc] == "", cl,
#                                                   paste(state_germany_large_lineage[st, gc], cl, sep = ","))
#   }
#   
#   knitr::kable(state_germany_large_lineage)
#   
#   germany$name <- mapNames
#   germany_map_states <- germany.f %>% group_by(id) %>%
#     summarise(long = mean(long), lat = mean(lat))
#   germany_map_states$name <- germany$name[match(germany_map_states$id, germany$CC_1)]
# 
#   for (col_index in 1:length(cols)) {
#     cluster <- cols[col_index]
#       germany$value <- aggs.matrix[match(mapNames, rownames(aggs.matrix)), cluster]
#       germany.f$value <- germany$value[match(germany.f$id, germany$CC_1)]
#       
#       # germany$lin <- state_germany_large_lineage[match(mapNames, rownames(state_germany_large_lineage)), col_index]
#       # germany.f$lin <- germany$lin[match(germany.f$id, germany$CC_1)]
#       
#       germany_map_states$lin <- state_germany_large_lineage[match(germany_map_states$name, rownames(state_germany_large_lineage)), col_index]
#       germany_map_states$lin[is.na(germany_map_states$lin)] <- ""
#       
#       col <- dePal[[stateFiles$state[cluster]]]
#       p <- ggplot() +
#         geom_polygon(data = germany.f, aes(x = long, y = lat, group = group, fill = value), colour = "grey70") +
#         scale_fill_gradient(low = lighten(col, 1), high = col, space = "Lab", limits=c(0, max(germany$value)), 
#                             name = "Number of sequences")+
#         ggtitle(germanyLargeClusters[cluster]) +
#         geom_text(aes(label = lin, x=long, y=lat), data = germany_map_states,  size = 3, hjust = 0.5)+
#         theme(axis.line=element_blank(),axis.text.x=element_blank(),
#           axis.text.y=element_blank(),axis.ticks=element_blank(),
#           axis.title.x=element_blank(),
#           axis.title.y=element_blank(),
#           panel.background=element_blank(),panel.grid.major=element_blank(),
#            panel.border = element_rect(colour = "black", fill=NA, size=0.1),
#           panel.grid.minor=element_blank(),plot.background=element_blank()) +
#         coord_equal() 
#       print(p)
#     }
#     
```


\clearpage

```{r sample-breakdown-weekly-lineages-absolute, fig.width=7, fig.height=3, fig.cap = sample_breakdown_weekly_lineages_absolute_cap, eval=TRUE}

for (s in 1:nrow(stateFiles)) {
  state <- stateFiles$state[s]
  clusterStatsMCC <- stateInfo$clusterStatsMCC[[s]]
  clusterSamplesMCC <- stateInfo$clusterSamplesMCC[[s]]
  weeklyBreakdown <- stateInfo$weeklyBreakdown[[s]]
  legendText1 <- stateInfo$legendText1[[s]]
  legendText2 <- stateInfo$legendText2[[s]]
  
  par(mar=c(4,4,2.5,8), cex.axis=0.7, cex.lab=0.8, mgp=c(2,0.75,0))
  
  dateFreqDistribution(t(weeklyBreakdown$clustSizes), weeklyBreakdown$sampleBreaks, plot.ci=FALSE,  barplot=FALSE, 
                       startDate = weeklyBreakdown$sampleBreaks[1], endDate = weeklyBreakdown$sampleBreaks[length(weeklyBreakdown$sampleBreaks)-1], 
                       #startDate = startDate, endDate = endDate, 
                       col=mPal(unlist(countryPal), 0.75), border = NA,
                       ymax = max(rowSums(weeklyBreakdown$clustSizes))+2, ylab = "Weekly no. of sampled genomes", main = state)
}

```


```{r sample-breakdown-weekly-lineages-proportion, fig.width=7, fig.height=3, fig.cap = sample_breakdown_weekly_lineages_proportion_cap, eval=TRUE}

for (s in 1:nrow(stateFiles)) {
  state <- stateFiles$state[s]
  clusterStatsMCC <- stateInfo$clusterStatsMCC[[s]]
  clusterSamplesMCC <- stateInfo$clusterSamplesMCC[[s]]
  weeklyBreakdown <- stateInfo$weeklyBreakdown[[s]]
  legendText1 <- stateInfo$legendText1[[s]]
  legendText2 <- stateInfo$legendText2[[s]]
  
  par(mar=c(4,4,2.5,8), cex.axis=0.7, cex.lab=0.8, mgp=c(2,0.75,0))
  
  dateFreqDistribution(t(weeklyBreakdown$clustProps), weeklyBreakdown$sampleBreaks, plot.ci=FALSE,  barplot=FALSE, 
                       # startDate = weeklyBreakdown$sampleBreaks[1], 
                       # endDate = weeklyBreakdown$sampleBreaks[length(weeklyBreakdown$sampleBreaks)-1], 
                         startDate = "2020-10-28", endDate="2021-05-26",
                       #startDate = "2020-03-01", endDate = "2020-06-07", 
                       col=mPal(unlist(countryPal), 0.75), border = "#000000CC",
                       ymax = 1, ylab = "Proportion of sampled genomes\n(per week)", axes=TRUE, main = state)
  
}

```

\clearpage

```{r sample-breakdown-weekly-aggr-absolute, fig.width=7, fig.height=3, fig.cap = sample_breakdown_weekly_aggr_absolute_cap, eval=TRUE}

for (s in stateInfo$stateOrder) { 
  state <- stateFiles$state[s]
  clusterStatsMCC <- stateInfo$clusterStatsMCC[[s]]
  clusterSamplesMCC <- stateInfo$clusterSamplesMCC[[s]]
  weeklyBreakdown <- stateInfo$weeklyBreakdown[[s]]
  legendText1 <- stateInfo$legendText1[[s]]
  legendText2 <- stateInfo$legendText2[[s]]
  
  par(mar=c(4,4,2.5,8), cex.axis=0.7, cex.lab=0.8, mgp=c(2,0.75,0))
  
  dateFreqDistribution(t(weeklyBreakdown$aggrSizes), weeklyBreakdown$sampleBreaks, plot.ci=FALSE,  barplot=FALSE, 
                       # startDate = "2020-10-01",  endDate = "2021-03-30", 
                         startDate = "2020-10-28", endDate="2021-05-26",
                       # startDate = weeklyBreakdown$sampleBreaks[1], endDate = weeklyBreakdown$sampleBreaks[length(weeklyBreakdown$sampleBreaks)-1], 
                       col=mPal(unlist(ukPal), 0.75), border = "#000000", 
                       ymax = max(rowSums(weeklyBreakdown$aggrSizes))+2, ylab = "Weekly no. of sampled genomes")
  
  legend("top", horiz=FALSE, inset=c(0,-0.33), bty='n', xpd=TRUE, ncol=3,
         fill=mPal(unlist(ukPal), 0.75), border = mPal(unlist(ukPal)), 
         legend = c("Bigger than 1000", "101 to 1000", "11 to 100", "10 or smaller", "Singletons"), 
         title = paste("Transmission lineage size of", state),
         cex=0.8)
}

```

```{r sample-breakdown-weekly-aggr-absolute-2, fig.width=5, fig.height=5, fig.cap = sample_breakdown_weekly_aggr_absolute_cap, eval=TRUE}

aggregateLineages <- function(sizes) {
  if (sizes == 1) {
    return("singleton")
  } else 
    if (sizes <= 10) {
      return("small")
    } else 
      if (sizes <= 100) {
        return("medium")
      } else 
        if (sizes <= 1000) {
          return("big")
        } else {
          return("huge")
        }
}


for (s in stateInfo$stateOrder) { 
  state <- stateFiles$state[s]
  clusterStatsMCC <- stateInfo$clusterStatsMCC[[s]]
  clusterSamplesMCC <- stateInfo$clusterSamplesMCC[[s]]
  weeklyBreakdown <- stateInfo$weeklyBreakdown[[s]]
  legendText1 <- stateInfo$legendText1[[s]]
  legendText2 <- stateInfo$legendText2[[s]]
  
  clusterStatsMCC$size_category <- NA
  clusterStatsMCC$size_category[clusterStatsMCC$seq > 1000] <- "huge"
  clusterStatsMCC$size_category[is.na(clusterStatsMCC$size_category) & clusterStatsMCC$seq > 100] <- "big"
  clusterStatsMCC$size_category[is.na(clusterStatsMCC$size_category) & clusterStatsMCC$seq > 10] <- "medium"
  clusterStatsMCC$size_category[is.na(clusterStatsMCC$size_category) & clusterStatsMCC$seq > 1] <- "small"
  clusterStatsMCC$size_category[is.na(clusterStatsMCC$size_category) ] <- "singleton"
  clusterStatsMCC$size_category <- as.factor(clusterStatsMCC$size_category)
  
  linBreakdown <- matrix(0, nrow=length(weeklyBreakdown$sampleBreak)-1, ncol=0)
  
  for (i in 1:ncol(weeklyBreakdown$aggrSizes)) {
    sz <- colnames(weeklyBreakdown$aggrSizes)[i]
    bd <- hist(clusterStatsMCC$tmrca_calendar[clusterStatsMCC$size_category == sz], breaks=weeklyBreakdown$sampleBreak, plot=FALSE, right=FALSE)$count
    linBreakdown <- cbind(linBreakdown, bd)
  }
  colnames(linBreakdown) <- colnames(weeklyBreakdown$aggrSizes)
  
  seqBreakdown <- hist(metadata$sample_date[stateInfo$metadata_instate[,s]], breaks=weeklyBreakdown$sampleBreak, plot=FALSE, right=FALSE)$count
  
  
  # par(mar=c(6,4,2.5,6), cex.axis=0.8, cex.lab=0.8, mgp=c(2,0.75,0))
  # layout(matrix(1:2, nrow=2, byrow=TRUE))
  
  
  
  # plotLineageScatter(clusterStatsMCC, stat1="tmrca", stat2="duration", startDate = startDate, endDate = endDate, addLine = TRUE, ymax=150, log=FALSE, label="B", 
  #                ylab="Duration of transmission\nlineage detection (days)")
  
  col=mPal(unlist(ukPal), 0.75)
  
  for (i in 1:ncol(weeklyBreakdown$aggrSizes)) {
    sz <- colnames(weeklyBreakdown$aggrSizes)[i]
    # mtext(side=1, line=4, text="xlab", cex=1)
    # plotShadedAxes(xlim=c(startDate, endDate), ylim=c(0, 100), ylab="ylab", side=2, decimal=TRUE, yaxs='i')
    if (i == 1) {
      plot(seqBreakdown, linBreakdown[,sz], col=col[i], pch=20, xpd=TRUE, main=state, xlab="Number of sequences", ylab="Number of lienages", ylim=c(10, max(linBreakdown) ))
    } else {
      points(seqBreakdown, linBreakdown[,sz], col=col[i], pch=20, xpd=TRUE)
    }
    reg<-lm(linBreakdown[,sz] ~ seqBreakdown)
    
    abline(reg, col=col[i])
  }
  
  legend("topleft", legend=(colnames(weeklyBreakdown$aggrSizes)), col=col, pch=20)
  
  
  for (i in 1:ncol(weeklyBreakdown$aggrSizes)) {
    sz <- colnames(weeklyBreakdown$aggrSizes)[i]
    ind <- 54:length(seqBreakdown)
    # mtext(side=1, line=4, text="xlab", cex=1)
    # plotShadedAxes(xlim=c(startDate, endDate), ylim=c(0, 100), ylab="ylab", side=2, decimal=TRUE, yaxs='i')
    if (i == 1) {
      plot(cumsum(seqBreakdown[ind]), cumsum(linBreakdown[ind,sz]), col=col[i], pch=20, xpd=TRUE, main=state, xlab="Number of sequences", ylab="Number of lienages", ylim=c(10, max(cumsum(linBreakdown[ind,])) ))
    } else {
      points(cumsum(seqBreakdown[ind]), cumsum(linBreakdown[ind,sz]), col=col[i], pch=20, xpd=TRUE)
    }
    reg<-lm(cumsum(linBreakdown[,sz]) ~ cumsum(seqBreakdown))
    
    abline(reg, col=col[i])
  }
  
  legend("topleft", legend=(colnames(weeklyBreakdown$aggrSizes)), col=col, pch=20)
  
  
  
  for (i in 1:ncol(weeklyBreakdown$aggrSizes)) {
    sz <- colnames(weeklyBreakdown$aggrSizes)[i]
    ind <- 54:length(seqBreakdown)
    # mtext(side=1, line=4, text="xlab", cex=1)
    # plotShadedAxes(xlim=c(startDate, endDate), ylim=c(0, 100), ylab="ylab", side=2, decimal=TRUE, yaxs='i')
    if (i == 1) {
      plot(cumsum(seqBreakdown[ind]), cumsum(linBreakdown[ind,sz]), col=col[i], pch=20, xpd=TRUE, main=state, xlab="logarithm number of sequences", ylab="logarithm of number of detected lienages", ylim=c(1, max(cumsum(linBreakdown[ind,])) ), log="xy")
      
      
    } else {
      points(cumsum(seqBreakdown[ind]), cumsum(linBreakdown[ind,sz]), col=col[i], pch=20, xpd=TRUE)
    }
    reg<-lm(cumsum(linBreakdown[,sz]) ~ cumsum(seqBreakdown))
    
    #abline(reg, col=col[i])
  }
  
  legend("topleft", legend=(colnames(weeklyBreakdown$aggrSizes)), col=col, pch=20)
  
  
  
  #   for (i in 1:ncol(weeklyBreakdown$aggrSizes)) {
  #     sz <- colnames(weeklyBreakdown$aggrSizes)[i]
  #       # mtext(side=1, line=4, text="xlab", cex=1)
  #     # plotShadedAxes(xlim=c(startDate, endDate), ylim=c(0, 100), ylab="ylab", side=2, decimal=TRUE, yaxs='i')
  #     if (i == 1) {
  #       plot(seqBreakdown, weeklyBreakdown$aggrSizes[,sz], col=col[i], pch=20, xpd=TRUE, main=paste0("log ", state), xlab="log Number of sequences", ylab="log Number of lienages", ylim=c(10, max(weeklyBreakdown$aggrSizes) ), log="xy")
  #     } else {
  #       points(seqBreakdown, weeklyBreakdown$aggrSizes[,sz], col=col[i], pch=20, xpd=TRUE)
  #     }
  #     reg<-lm(weeklyBreakdown$aggrSizes[,sz] ~ seqBreakdown)
  # 
  #     abline(reg, col=col[i])
  #   }
  #   
  #   legend("topleft", legend=(colnames(weeklyBreakdown$aggrSizes)), col=col, pch=20)
  # 
  #   
  #   for (i in 1:ncol(weeklyBreakdown$aggrSizes)) {
  #     sz <- colnames(weeklyBreakdown$aggrSizes)[i]
  #       # mtext(side=1, line=4, text="xlab", cex=1)
  #     # plotShadedAxes(xlim=c(startDate, endDate), ylim=c(0, 100), ylab="ylab", side=2, decimal=TRUE, yaxs='i')
  #     seqBreakdownAcc <- cumsum(seqBreakdown)
  #     lienageSizeAcc <- cumsum(weeklyBreakdown$aggrSizes[,sz])
  #     if (i == 1) {
  #       plot(seqBreakdownAcc, lienageSizeAcc, col=col[i], pch=20, xpd=TRUE, main=state, xlab="Number of sequences", ylab="Number of lienages", ylim=c(10, max(colSums(weeklyBreakdown$aggrSizes) ) ) )
  #     } else {
  #       points(seqBreakdownAcc, lienageSizeAcc, col=col[i], pch=20, xpd=TRUE)
  #     }
  #     reg<-lm(lienageSizeAcc ~ seqBreakdownAcc)
  # 
  #     abline(reg, col=col[i])
  #   }
  # 
  #   legend("topleft", legend=(colnames(weeklyBreakdown$aggrSizes)), col=col, pch=20)
  #   
  #   
  #   
  #   
  #    for (i in 1:ncol(weeklyBreakdown$aggrSizes)) {
  #     sz <- colnames(weeklyBreakdown$aggrSizes)[i]
  #       # mtext(side=1, line=4, text="xlab", cex=1)
  #     # plotShadedAxes(xlim=c(startDate, endDate), ylim=c(0, 100), ylab="ylab", side=2, decimal=TRUE, yaxs='i')
  #     seqBreakdownAcc <- cumsum(seqBreakdown)
  #     lienageSizeAcc <- cumsum(weeklyBreakdown$aggrSizes[,sz])
  #     if (i == 1) {
  #       plot(seqBreakdownAcc, lienageSizeAcc, col=col[i], pch=20, xpd=TRUE, main=state, xlab="log Number of sequences", ylab="log Number of lienages", ylim=c(10, max(colSums(weeklyBreakdown$aggrSizes) ) ) , log="xy")
  #     } else {
  #       points(seqBreakdownAcc, lienageSizeAcc, col=col[i], pch=20, xpd=TRUE)
  #     }
  #     reg<-lm(lienageSizeAcc ~ seqBreakdownAcc)
  # 
  #     abline(reg, col=col[i])
  #   }
  # 
  #   legend("topleft", legend=(colnames(weeklyBreakdown$aggrSizes)), col=col, pch=20)
  #   
  #   
  # # par(mar=c(4,4,2.5,8), cex.axis=0.7, cex.lab=0.8, mgp=c(2,0.75,0))
  # # 
  # # dateFreqDistribution(t(weeklyBreakdown$aggrSizes), weeklyBreakdown$sampleBreaks, plot.ci=FALSE,  barplot=FALSE, 
  # #              startDate = "2020-12-22",  endDate = "2021-03-30", 
  # #                      # startDate = weeklyBreakdown$sampleBreaks[1], endDate = weeklyBreakdown$sampleBreaks[length(weeklyBreakdown$sampleBreaks)-1], 
  # #              col=mPal(unlist(ukPal), 0.75), border = "#000000", 
  # #              ymax = max(rowSums(weeklyBreakdown$aggrSizes))+2, ylab = "Weekly no. of sampled genomes")
  # # 
  # # legend("top", horiz=FALSE, inset=c(0,-0.33), bty='n', xpd=TRUE, ncol=3,
  # #        fill=mPal(unlist(ukPal), 0.75), border = mPal(unlist(ukPal)), 
  # #        legend = c("Bigger than 1000", "101 to 1000", "11 to 100", "10 or smaller", "Singletons"), title = paste("Transmission lineage size of", state),
  # #        cex=0.8)
}

```




```{r sample-breakdown-weekly-aggr-proportion, fig.width=7, fig.height=3, fig.cap = sample_breakdown_weekly_aggr_proportion_cap, eval=TRUE}

for (s in 1:nrow(stateFiles)) {
  state <- stateFiles$state[s]
  clusterStatsMCC <- stateInfo$clusterStatsMCC[[s]]
  clusterSamplesMCC <- stateInfo$clusterSamplesMCC[[s]]
  weeklyBreakdown <- stateInfo$weeklyBreakdown[[s]]
  legendText1 <- stateInfo$legendText1[[s]]
  legendText2 <- stateInfo$legendText2[[s]]
  
  par(mar=c(4,4,2.5,8), cex.axis=0.7, cex.lab=0.8, mgp=c(2,0.75,0))
  
  dateFreqDistribution(t(weeklyBreakdown$aggrProps), weeklyBreakdown$sampleBreaks, plot.ci=FALSE,  barplot=FALSE, 
                         startDate = "2020-10-28", endDate="2021-05-26",
                       #startDate = "2020-03-01", endDate = "2020-06-07", 
                       #startDate = weeklyBreakdown$sampleBreaks[1], endDate = weeklyBreakdown$sampleBreaks[length(weeklyBreakdown$sampleBreaks)-1], 
                       # startDate = "2020-10-01", endDate = "2021-06-02",
                       col=mPal(unlist(ukPal), 0.75), border = "#000000",
                       ymax = 1, ylab = "Proportion of sampled genomes\n(per week)", axes=TRUE)
  
  legend("top", horiz=FALSE, inset=c(0,-0.33), bty='n', xpd=TRUE, ncol=3,
         fill=mPal(unlist(ukPal), 0.75), border = "#000000", 
         legend = c("Bigger than 1000", "101 to 1000", "11 to 100", "10 or smaller", "Singletons"), 
         title = paste("Transmission lineage size of", state),
         cex=0.8)
}

```

<!-- \clearpage -->

<!-- # Sample breakdown into lineages (daily) -->

<!-- ```{r sample-breakdown-daily} -->

<!-- stateInfo$dailyBreakdown <- list() -->
<!--     for (s in 1:nrow(stateFiles)) { -->
<!--       state <- stateFiles$state[s] -->
<!--       clusterStatsMCC <- stateInfo$clusterStatsMCC[[s]] -->
<!--       clusterSamplesMCC <- stateInfo$clusterSamplesMCC[[s]] -->
<!--       weeklyBreakdown <- stateInfo$weeklyBreakdown[[s]] -->
<!--       legendText1 <- stateInfo$legendText1[[s]] -->
<!--       legendText2 <- stateInfo$legendText2[[s]] -->

<!-- #dailyBreakdown <- getSampleLineageBreakdown(clusterSamplesMCC, breaks="days") -->
<!-- stateInfo$dailyBreakdown[[s]] <- getSampleLineageBreakdown(clusterSamplesMCC, breaks="days", startDate = startDate, endDate = endDate) -->

<!--   } -->
<!-- ################### -->
<!-- # Figure captions # -->
<!-- ################### -->
<!-- sample_breakdown_daily_absolute_cap   <-  -->
<!-- sample_breakdown_daily_proportion_cap <- sprintf("Lineage size breakdown of %s genomes collected each day. The 8 largest lineages are coloured.", state) -->

<!-- sample_breakdown_daily_absolute_top8_cap   <- sprintf("Lineage size breakdown of %s genomes in the largest 8 lineages collected each day.", state) -->


<!-- sample_breakdown_daily_lineages_absolute_cap   <-  -->
<!-- sample_breakdown_daily_lineages_proportion_cap <- sprintf("Lineage size breakdown of %s genomes collected each day.", state) -->

<!-- sample_breakdown_daily_aggr_absolute_cap   <-  -->
<!-- sample_breakdown_daily_aggr_proportion_cap <- sprintf("Lineage size breakdown of %s genomes collected each day.", state) -->

<!-- ``` -->



<!-- ```{r sample-breakdown-daily-absolute, fig.width=7, fig.height=3, fig.cap = sample_breakdown_daily_absolute_cap, eval=TRUE} -->

<!--     for (s in 1:nrow(stateFiles)) { -->
<!--       state <- stateFiles$state[s] -->
<!--       clusterStatsMCC <- stateInfo$clusterStatsMCC[[s]] -->
<!--       clusterSamplesMCC <- stateInfo$clusterSamplesMCC[[s]] -->
<!--       weeklyBreakdown <- stateInfo$weeklyBreakdown[[s]] -->
<!--       legendText1 <- stateInfo$legendText1[[s]] -->
<!--       legendText2 <- stateInfo$legendText2[[s]] -->
<!--       dailyBreakdown <- stateInfo$dailyBreakdown[[s]] -->

<!-- par(mar=c(4,4,2.5,8), cex.axis=0.7, cex.lab=0.8, mgp=c(2,0.75,0)) -->


<!-- cols   <- c(mPal(unlist(countryPal), 0.75)[c(2,3,4,6,10,8,11,12)], gray.colors(n = 4, start=0.75, end=0, alpha = 0.75))  -->
<!-- border <- c(mPal(unlist(countryPal), 1)[c(2,3,4,6,10,8,11,12)], gray.colors(n = 4, start=0.75, end=0, alpha = 1))  -->

<!-- dateFreqDistribution(t(dailyBreakdown$clustSizesHybrid), dailyBreakdown$sampleBreaks, plot.ci=FALSE,  barplot=TRUE,  -->
<!--                          startDate = dailyBreakdown$sampleBreaks[1], endDate = dailyBreakdown$sampleBreaks[length(dailyBreakdown$sampleBreaks)-1],  -->
<!--                      #startDate = startDate, endDate = endDate,  -->
<!--                      col=cols, border = border,  -->
<!--                      ymax = max(rowSums(dailyBreakdown$clustSizesHybrid))+2, ylab = "Daily no. of sampled genomes") -->

<!-- legendText1 <- c() -->
<!-- for (cluster in colnames(dailyBreakdown$clustSizesHybrid)[1:8]) { -->
<!--     i    <- which(clusterStatsMCC$cluster == cluster) -->
<!--     size <- clusterStatsMCC$seqs[i] -->
<!--     duration <- lubridate::round_date(lubridate::date_decimal(clusterStatsMCC$mostrecent[i]), unit="day") - -->
<!--     lubridate::round_date(lubridate::date_decimal(clusterStatsMCC$tmrca[i]), unit="day") -->
<!--     #clusterSimple <- paste(strsplit(cluster, split="_")[[1]][c(2,4)], collapse = "_") -->
<!--     clusterSimple <- paste("Importation_lineage",strsplit(strsplit(cluster, split="_")[[1]][1],split="-")[[1]][3], sep = "_") -->
<!--     clusterSimple <- cluster -->
<!--     legendText1   <- c(legendText1, sprintf("%s\n(%d genomes, %d days)", clusterSimple, size, duration)) -->
<!-- } -->
<!-- legend("left", horiz=FALSE, inset=c(1,-0), bty='n', xpd=TRUE, ncol=1, -->
<!--            fill=cols[1:8], border = border[1:8],  -->
<!--            legend = legendText1, y.intersp = 2, -->
<!--            cex=0.6) -->

<!-- legendText2 <- c(sprintf("Bigger than 100 (n = %d)", sum(clusterStatsMCC$seqs > 100)), -->
<!--                  sprintf("11 to 100 (n = %d)", sum(clusterStatsMCC$seqs <= 100 & clusterStatsMCC$seqs > 10)),  -->
<!--                  sprintf("10 or smaller (n = %d)", sum(clusterStatsMCC$seqs <= 10)),  -->
<!--                  sprintf("Singletons (n = %d)", sum(metadata$instate) - sum(clusterStatsMCC$seqs))) -->
<!-- legend("top", horiz=FALSE, inset=c(0,-0.33), bty='n', xpd=TRUE, ncol=2, -->
<!--        fill=cols[9:12], border = border[9:12],  -->
<!--        legend = legendText2, title = paste("Transmission lineage size of", state), -->
<!--        cex=0.8) -->
<!--       legendText1 <- stateInfo$legendText1[[s]] -->
<!--       legendText2 <- stateInfo$legendText2[[s]] -->

<!-- } -->
<!-- ``` -->

<!-- ```{r sample-breakdown-daily-absolute-top8, fig.width=14, fig.height=12, fig.cap = "The daily sampling frequency of the 8 largest `r state` transmission lineages.", eval=TRUE} -->

<!--     for (s in 1:nrow(stateFiles)) { -->
<!--       state <- stateFiles$state[s] -->
<!--       clusterStatsMCC <- stateInfo$clusterStatsMCC[[s]] -->
<!--       clusterSamplesMCC <- stateInfo$clusterSamplesMCC[[s]] -->
<!--       weeklyBreakdown <- stateInfo$weeklyBreakdown[[s]] -->
<!--       legendText1 <- stateInfo$legendText1[[s]] -->
<!--       legendText2 <- stateInfo$legendText2[[s]] -->
<!--       dailyBreakdown <- stateInfo$dailyBreakdown[[s]] -->

<!--     par(mar=c(4,4,2.5,8), cex.axis=1, cex.lab=1.2, cex.main=1.2, mgp=c(3,0.75,0)) -->

<!--     cols   <- c(mPal(unlist(countryPal), 0.75)[c(2,3,4,6,10,8,11,12)], gray.colors(n = 4, start=0.75, end=0, alpha = 0.75))  -->
<!--     border <- c(mPal(unlist(countryPal), 1)[c(2,3,4,6,10,8,11,12)], gray.colors(n = 4, start=0.75, end=0, alpha = 1))  -->
<!--     layout(matrix(1:8, nrow=4)) -->
<!--     for (i in 1:8) { -->
<!--       dateFreqDistribution(t(dailyBreakdown$clustSizesTop8[, i]), dailyBreakdown$sampleBreaks, plot.ci=FALSE,  barplot=TRUE,  -->
<!--                          startDate = dailyBreakdown$sampleBreaks[1], endDate = dailyBreakdown$sampleBreaks[length(dailyBreakdown$sampleBreaks)-1],  -->
<!--                            #startDate = startDate, endDate = endDate,  -->
<!--                            col=cols[i], border = border[i],  -->
<!--                            ymax = max(rowSums(dailyBreakdown$clustSizesTop8[, 1:8])),  -->
<!--                          ylab = "Daily no. of sampled genomes") -->

<!--       mtext(side=3, line=0.5, gsub("\n", " ", legendText1[i]), cex=par("cex.main")) -->

<!--       x <- -0.075*(endDate - startDate) -->
<!--       mtext(text = paste(state, LETTERS[i]), side=3, line=0.5, at=x, cex = par("cex.main")) -->
<!--     } -->
<!--     } -->

<!-- ``` -->


<!-- ```{r sample-breakdown-daily-proportion, fig.width=7, fig.height=3, fig.cap = sample_breakdown_daily_proportion_cap, eval=TRUE} -->

<!--     for (s in 1:nrow(stateFiles)) { -->
<!--       state <- stateFiles$state[s] -->
<!--       clusterStatsMCC <- stateInfo$clusterStatsMCC[[s]] -->
<!--       clusterSamplesMCC <- stateInfo$clusterSamplesMCC[[s]] -->
<!--       weeklyBreakdown <- stateInfo$weeklyBreakdown[[s]] -->
<!--       legendText1 <- stateInfo$legendText1[[s]] -->
<!--       legendText2 <- stateInfo$legendText2[[s]] -->
<!--       dailyBreakdown <- stateInfo$dailyBreakdown[[s]] -->

<!-- par(mar=c(4,4,2.5,8), cex.axis=0.7, cex.lab=0.8, mgp=c(2,0.75,0)) -->


<!-- cols <- c(mPal(unlist(countryPal), 0.75)[c(2,3,4,6,10,8,11,12)], gray.colors(n = 4, start=0.75, end=0, alpha = 0.75))  -->

<!-- dateFreqDistribution(t(dailyBreakdown$clustPropsHybrid), dailyBreakdown$sampleBreaks, plot.ci=FALSE,  barplot=FALSE,  -->
<!--                          startDate = dailyBreakdown$sampleBreaks[1], endDate = dailyBreakdown$sampleBreaks[length(dailyBreakdown$sampleBreaks)-1],  -->
<!--                      #startDate = "2020-03-01", endDate = "2020-06-07",  -->
<!--                      col=cols, border = "#000000", -->
<!--                      ymax = 1, ylab = "Proportion of sampled genomes\n(per day)", axes=TRUE) -->


<!-- legend("left", horiz=FALSE, inset=c(1,-0), bty='n', xpd=TRUE, ncol=1, -->
<!--        fill=cols[1:8], border = "#000000",  -->
<!--        legend = legendText1, y.intersp = 2, -->
<!--        cex=0.6) -->

<!-- legend("top", horiz=FALSE, inset=c(0,-0.33), bty='n', xpd=TRUE, ncol=2, -->
<!--        fill=cols[9:12], border = "#000000",  -->
<!--        legend = legendText2, title = paste("Transmission lineage size of", state), -->
<!--        cex=0.8) -->
<!-- } -->

<!-- ``` -->

<!-- \clearpage -->

<!-- ```{r sample-breakdown-daily-lineages-absolute, fig.width=7, fig.height=3, fig.cap = sample_breakdown_daily_lineages_absolute_cap, eval=TRUE} -->

<!--     for (s in 1:nrow(stateFiles)) { -->
<!--       state <- stateFiles$state[s] -->
<!--       clusterStatsMCC <- stateInfo$clusterStatsMCC[[s]] -->
<!--       clusterSamplesMCC <- stateInfo$clusterSamplesMCC[[s]] -->
<!--       weeklyBreakdown <- stateInfo$weeklyBreakdown[[s]] -->
<!--       legendText1 <- stateInfo$legendText1[[s]] -->
<!--       legendText2 <- stateInfo$legendText2[[s]] -->
<!--       dailyBreakdown <- stateInfo$dailyBreakdown[[s]] -->

<!-- par(mar=c(4,4,2.5,8), cex.axis=0.7, cex.lab=0.8, mgp=c(2,0.75,0)) -->


<!-- dateFreqDistribution(t(dailyBreakdown$clustSizes), dailyBreakdown$sampleBreaks, plot.ci=FALSE,  barplot=FALSE,  -->
<!--                      #startDate = startDate, endDate = endDate,  -->
<!--                          startDate = dailyBreakdown$sampleBreaks[1], endDate = dailyBreakdown$sampleBreaks[length(dailyBreakdown$sampleBreaks)-1],  -->
<!--                      col=mPal(unlist(countryPal), 0.75), border = NA, -->
<!--                      ymax = max(rowSums(dailyBreakdown$clustSizes))+2, ylab = "Daily no. of sampled genomes", main=state) -->
<!-- } -->
<!-- ``` -->


<!-- ```{r sample-breakdown-daily-lineages-proportion, fig.width=7, fig.height=3, fig.cap = sample_breakdown_daily_lineages_proportion_cap, eval=TRUE} -->


<!--     for (s in 1:nrow(stateFiles)) { -->
<!--       state <- stateFiles$state[s] -->
<!--       clusterStatsMCC <- stateInfo$clusterStatsMCC[[s]] -->
<!--       clusterSamplesMCC <- stateInfo$clusterSamplesMCC[[s]] -->
<!--       weeklyBreakdown <- stateInfo$weeklyBreakdown[[s]] -->
<!--       legendText1 <- stateInfo$legendText1[[s]] -->
<!--       legendText2 <- stateInfo$legendText2[[s]] -->
<!--       dailyBreakdown <- stateInfo$dailyBreakdown[[s]] -->


<!-- par(mar=c(4,4,2.5,8), cex.axis=0.7, cex.lab=0.8, mgp=c(2,0.75,0)) -->


<!-- dateFreqDistribution(t(dailyBreakdown$clustProps), dailyBreakdown$sampleBreaks, plot.ci=FALSE,  barplot=FALSE,  -->
<!--                          startDate = dailyBreakdown$sampleBreaks[1], endDate = dailyBreakdown$sampleBreaks[length(dailyBreakdown$sampleBreaks)-1],  -->
<!--                      #startDate = "2020-03-01", endDate = "2020-06-07",  -->
<!--                      col=mPal(unlist(countryPal), 0.75), border = "#000000CC", -->
<!--                      ymax = 1, ylab = "Proportion of sampled genomes\n(per day)", axes=TRUE, main=state) -->
<!-- } -->

<!-- ``` -->

<!-- \clearpage -->

<!-- ```{r sample-breakdown-daily-aggr-absolute, fig.width=7, fig.height=3, fig.cap = sample_breakdown_daily_aggr_absolute_cap, eval=TRUE} -->


<!--     for (s in 1:nrow(stateFiles)) { -->
<!--       state <- stateFiles$state[s] -->
<!--       clusterStatsMCC <- stateInfo$clusterStatsMCC[[s]] -->
<!--       clusterSamplesMCC <- stateInfo$clusterSamplesMCC[[s]] -->
<!--       weeklyBreakdown <- stateInfo$weeklyBreakdown[[s]] -->
<!--       legendText1 <- stateInfo$legendText1[[s]] -->
<!--       legendText2 <- stateInfo$legendText2[[s]] -->
<!--       dailyBreakdown <- stateInfo$dailyBreakdown[[s]] -->

<!-- par(mar=c(4,4,2.5,8), cex.axis=0.7, cex.lab=0.8, mgp=c(2,0.75,0)) -->


<!-- dateFreqDistribution(t(dailyBreakdown$aggrSizes), dailyBreakdown$sampleBreaks, plot.ci=FALSE,  barplot=TRUE,  -->
<!--                      #startDate = startDate, endDate = endDate,  -->
<!--                          startDate = dailyBreakdown$sampleBreaks[1], endDate = dailyBreakdown$sampleBreaks[length(dailyBreakdown$sampleBreaks)-1],  -->
<!--                      col=mPal(unlist(ukPal), 0.75), border = mPal(unlist(ukPal)), -->
<!--                      ymax = max(rowSums(dailyBreakdown$aggrSizes))+2, ylab = "Daily no. of sampled genomes") -->

<!-- legend("top", horiz=FALSE, inset=c(0,-0.33), bty='n', xpd=TRUE, ncol=3, -->
<!--        fill=mPal(unlist(ukPal), 0.75), border = mPal(unlist(ukPal)),  -->
<!--        legend = c("Bigger than 1000", "101 to 1000", "11 to 100", "10 or smaller", "Singletons"), title = paste("Transmission lineage size of", state), -->
<!--        cex=0.8) -->
<!-- } -->
<!-- ``` -->


<!-- ```{r sample-breakdown-daily-aggr-proportion, fig.width=7, fig.height=3, fig.cap = sample_breakdown_daily_aggr_proportion_cap, eval=TRUE} -->


<!--     for (s in 1:nrow(stateFiles)) { -->
<!--       state <- stateFiles$state[s] -->
<!--       clusterStatsMCC <- stateInfo$clusterStatsMCC[[s]] -->
<!--       clusterSamplesMCC <- stateInfo$clusterSamplesMCC[[s]] -->
<!--       weeklyBreakdown <- stateInfo$weeklyBreakdown[[s]] -->
<!--       legendText1 <- stateInfo$legendText1[[s]] -->
<!--       legendText2 <- stateInfo$legendText2[[s]] -->
<!--       dailyBreakdown <- stateInfo$dailyBreakdown[[s]] -->

<!-- par(mar=c(4,4,2.5,8), cex.axis=0.7, cex.lab=0.8, mgp=c(2,0.75,0)) -->


<!-- dateFreqDistribution(t(dailyBreakdown$aggrProps), dailyBreakdown$sampleBreaks, plot.ci=FALSE,  barplot=FALSE,  -->
<!--                      #startDate = "2020-03-01", endDate = "2020-06-07",  -->
<!--                          startDate = dailyBreakdown$sampleBreaks[1], endDate = dailyBreakdown$sampleBreaks[length(dailyBreakdown$sampleBreaks)-1],  -->
<!--                      col=mPal(unlist(ukPal), 0.75), border = "#000000", -->
<!--                      ymax = 1, ylab = "Proportion of sampled genomes\n(per day)", axes=TRUE) -->

<!-- legend("top", horiz=FALSE, inset=c(0,-0.33), bty='n', xpd=TRUE, ncol=3, -->
<!--        fill=mPal(unlist(ukPal), 0.75), border = "#000000",  -->
<!--        legend = c("Bigger than 1000", "101 to 1000", "11 to 100", "10 or smaller", "Singletons"), title = paste("Transmission lineage size of", state), -->
<!--        cex=0.8) -->

<!-- } -->
<!-- ``` -->


\clearpage

# Individual transmission lineage plots

```{r lineage-duration-captions}

    supp <- "Each row is a transmission lineage. Dots are genome sampling times and boxes show the range of sampling times for each transmission lineage (sampling duration). Asterisks show the TMRCA of each lineage. On the right, n indicates the number of Dusseldorf genomes in the lineage and the duration of lineage detection (time between the lineage’s oldest and most recent genomes). Sampling times of the first 500 SARS-CoV-2 genomes collected in the Dusseldorf have been obscured."

    lineage_duration_biggest_cap    <- paste0("Illustration of the time course of the 50 largest Dusseldorf transmission lineages in our dataset. ", supp)
    lineage_duration_earliest_cap   <- paste0("Illustration of the time course of the 50 earliest Dusseldorf transmission lineages in our dataset. ", supp)
    lineage_duration_newest_cap     <- paste0("Illustration of the time course of the 50 most recent (by TMRCA) Dusseldorf transmission lineages in our dataset. ", supp)
    lineage_duration_cryptic_cap    <- paste0("Illustration of the time course of the 50 Dusseldorf transmission lineages in our dataset with the longest period of cryptic circulation. ", supp)
    lineage_duration_longest_cap    <- paste0("Illustration of the time course of the 50 Dusseldorf transmission lineages in our dataset with the longest sampling duration (from earliest to most recently collected genome). ", supp)
    lineage_duration_unobserved_cap <- paste0("Illustration of the time course of the 50 Dusseldorf transmission lineages  in our dataset with the longest unobserved period before reemerging. ", supp)

```

\clearpage

## Biggest transmission lineages

```{r lineage-duration-biggest, fig.width=7, fig.height=8, fig.cap=lineage_duration_biggest_cap, eval=TRUE}

s = germanyState;
# for (s in stateInfo$stateOrder) {
state <- stateFiles$state[s]
clusterStatsMCC <- stateInfo$clusterStatsMCC[[s]]
clusterSamplesMCC <- stateInfo$clusterSamplesMCC[[s]]
weeklyBreakdown <- stateInfo$weeklyBreakdown[[s]]
legendText1 <- stateInfo$legendText1[[s]]
legendText2 <- stateInfo$legendText2[[s]]
# dailyBreakdown <- stateInfo$dailyBreakdown[[s]]
cutoff <- stateInfo$cutoff[[s]]

par(mar=c(5,10,3,12), cex.axis=0.7, cex.lab=0.8, mgp=c(2,0.75,0))
bigLineages <- clusterStatsMCC[order(clusterStatsMCC$seqs, decreasing = TRUE)[1:min(50, nrow(clusterStatsMCC))], ]
#plotLineageDurations(bigLineages, clusterSamplesMCC, startDate="2020-01-12", endDate="2020-06-28", cutoff=cutoff, orderby="")
plotLineageDurations(bigLineages, clusterSamplesMCC, startDate="2020-01-15", endDate="2021-06-01", cutoff="2019-01-05", orderby="", state=state)

clusterSamplesMCC$state <- sapply(str_split(clusterSamplesMCC$Location, "/"), function(x) ifelse(length(x) >= 3, x[[3]], ""))

kable(clusterSamplesMCC[clusterSamplesMCC$cluster %in% bigLineages$cluster, ] %>% group_by(cluster) %>% filter(sample_date == min(sample_date)) %>% merge(clusterStatsMCC) %>% arrange(-seqs) %>% dplyr::select(cluster, Pango.lineage, sample_date, lineage_seqs, state ))
# }
    
```

\clearpage
## Earliest transmission lineages

```{r lineage-duration-earliest, fig.width=7, fig.height=9, fig.cap=lineage_duration_earliest_cap, eval=TRUE}
    for (s in 1:nrow(stateFiles)) {
      state <- stateFiles$state[s]
      clusterStatsMCC <- stateInfo$clusterStatsMCC[[s]]
      clusterSamplesMCC <- stateInfo$clusterSamplesMCC[[s]]
      weeklyBreakdown <- stateInfo$weeklyBreakdown[[s]]
      legendText1 <- stateInfo$legendText1[[s]]
      legendText2 <- stateInfo$legendText2[[s]]
      # dailyBreakdown <- stateInfo$dailyBreakdown[[s]]
      cutoff <- stateInfo$cutoff[[s]]
      
      par(mar=c(5,10,3,7), cex.axis=0.7, cex.lab=0.8, mgp=c(2,0.75,0))
      earlyLineages <- clusterStatsMCC[order(clusterStatsMCC$tmrca)[1:min(50, nrow(clusterStatsMCC))], ]
      #plotLineageDurations(earlyLineages, clusterSamplesMCC, startDate="2020-01-12", endDate="2020-06-28", cutoff=cutoff, orderby="")
      plotLineageDurations(earlyLineages, clusterSamplesMCC[], startDate=startDate, endDate=endDate, cutoff="2019-01-05", orderby="", state=state)
    }
    
```

\clearpage
## Newest transmission lineages

```{r lineage-duration-newest, fig.width=7, fig.height=9, fig.cap=lineage_duration_newest_cap, eval=TRUE}

    for (s in 1:nrow(stateFiles)) {
      state <- stateFiles$state[s]
      clusterStatsMCC <- stateInfo$clusterStatsMCC[[s]]
      clusterSamplesMCC <- stateInfo$clusterSamplesMCC[[s]]
      weeklyBreakdown <- stateInfo$weeklyBreakdown[[s]]
      legendText1 <- stateInfo$legendText1[[s]]
      legendText2 <- stateInfo$legendText2[[s]]
      # dailyBreakdown <- stateInfo$dailyBreakdown[[s]]
      cutoff <- stateInfo$cutoff[[s]]
    
    par(mar=c(5,10,3,7), cex.axis=0.7, cex.lab=0.8, mgp=c(2,0.75,0))
    newLineages <- clusterStatsMCC[order(clusterStatsMCC$tmrca, decreasing = TRUE)[1:min(50, nrow(clusterStatsMCC))], ]
    #plotLineageDurations(newLineages, clusterSamplesMCC, startDate="2020-01-12", endDate="2020-06-28", cutoff=cutoff)
    plotLineageDurations(newLineages, clusterSamplesMCC, startDate=startDate, endDate=endDate, cutoff="2019-01-05", state=state)
    }
```
\clearpage
## Longest periods of cryptic circulation

```{r lineage-duration-cryptic, fig.width=7, fig.height=9, fig.cap=lineage_duration_cryptic_cap, eval=TRUE}
for (s in 1:nrow(stateFiles)) {
  state <- stateFiles$state[s]
  clusterStatsMCC <- stateInfo$clusterStatsMCC[[s]]
  clusterSamplesMCC <- stateInfo$clusterSamplesMCC[[s]]
  weeklyBreakdown <- stateInfo$weeklyBreakdown[[s]]
  legendText1 <- stateInfo$legendText1[[s]]
  legendText2 <- stateInfo$legendText2[[s]]
  # dailyBreakdown <- stateInfo$dailyBreakdown[[s]]
  cutoff <- stateInfo$cutoff[[s]]
  
  par(mar=c(5,10,3,7), cex.axis=0.7, cex.lab=0.8, mgp=c(2,0.75,0))
  longestCryptic <- clusterStatsMCC[order(clusterStatsMCC$oldest - clusterStatsMCC$tmrca, decreasing = TRUE)[1:min(50, nrow(clusterStatsMCC))], ]
  plotLineageDurations(longestCryptic, clusterSamplesMCC, startDate=min(longestCryptic$tmrca_calendar) - 7, endDate=round_date(date_decimal(max(longestCryptic$mostrecent))+7, unit="day"), cutoff="2019-01-05", orderby = "", state=state)
}

```
\clearpage
## Longest sampling period

```{r lineage-duration-longest, fig.width=7, fig.height=9, fig.cap=lineage_duration_longest_cap, eval=TRUE}
for (s in 1:nrow(stateFiles)) {
  state <- stateFiles$state[s]
  clusterStatsMCC <- stateInfo$clusterStatsMCC[[s]]
  clusterSamplesMCC <- stateInfo$clusterSamplesMCC[[s]]
  weeklyBreakdown <- stateInfo$weeklyBreakdown[[s]]
  legendText1 <- stateInfo$legendText1[[s]]
  legendText2 <- stateInfo$legendText2[[s]]
  # dailyBreakdown <- stateInfo$dailyBreakdown[[s]]
  cutoff <- stateInfo$cutoff[[s]]
  
  par(mar=c(5,10,3,7), cex.axis=0.7, cex.lab=0.8, mgp=c(2,0.75,0))
  longestSampling <- clusterStatsMCC[order(clusterStatsMCC$mostrecent - clusterStatsMCC$oldest, decreasing = TRUE)[1:min(50, nrow(clusterStatsMCC))], ]
  #plotLineageDurations(longestSampling, clusterSamplesMCC, startDate="2020-01-12", endDate="2020-06-28", cutoff=cutoff, orderby="")
  plotLineageDurations(longestSampling, clusterSamplesMCC, startDate="2020-01-01", endDate="2021-05-30", cutoff="2019-01-05", orderby="", state=state)
}

```

\clearpage
## Longest unobserved period before reactivating

```{r lineage-longest-unobserved, fig.width=7, fig.height=9, fig.cap=lineage_duration_unobserved_cap, eval=TRUE}

for (s in 1:nrow(stateFiles)) {
  state <- stateFiles$state[s]
  clusterStatsMCC <- stateInfo$clusterStatsMCC[[s]]
  clusterSamplesMCC <- stateInfo$clusterSamplesMCC[[s]]
  weeklyBreakdown <- stateInfo$weeklyBreakdown[[s]]
  legendText1 <- stateInfo$legendText1[[s]]
  legendText2 <- stateInfo$legendText2[[s]]
  # dailyBreakdown <- stateInfo$dailyBreakdown[[s]]
  cutoff <- stateInfo$cutoff[[s]]
  cutoff <- "2019-01-05"
  
  clusterStatsMCC$longest_unobserved <- rep(0, nrow(clusterStatsMCC))
  for (i in 1:nrow(clusterStatsMCC)) {
    sampleTimes <- sort(clusterSamplesMCC$sample_date[clusterSamplesMCC$cluster == as.character(clusterStatsMCC$cluster[i])])
    clusterStatsMCC$longest_unobserved[i] <- max(diff(sampleTimes))
  }
  
  par(mar=c(5,10,3,7), cex.axis=0.7, cex.lab=0.8, mgp=c(2,0.75,0))
  reemergedLineages <- clusterStatsMCC[order(clusterStatsMCC$longest_unobserved, decreasing = TRUE)[1:min(50, nrow(clusterStatsMCC))], ]
  #plotLineageDurations(reemergedLineages, clusterSamplesMCC, startDate="2020-01-12", endDate="2020-06-28", cutoff=cutoff, orderby = "longest_unobserved")
  plotLineageDurations(reemergedLineages, clusterSamplesMCC, startDate=startDate, endDate=endDate, cutoff=cutoff, orderby = "longest_unobserved", state=state)
}
```

\clearpage
## Largest lienages

```{r lineage-largest, fig.width=7, fig.height=9, fig.cap=lineage_duration_unobserved_cap, eval=TRUE}

for (s in 1:nrow(stateFiles)) {
  state <- stateFiles$state[s]
  clusterStatsMCC <- stateInfo$clusterStatsMCC[[s]]
  clusterSamplesMCC <- stateInfo$clusterSamplesMCC[[s]]
  weeklyBreakdown <- stateInfo$weeklyBreakdown[[s]]
  legendText1 <- stateInfo$legendText1[[s]]
  legendText2 <- stateInfo$legendText2[[s]]
  # dailyBreakdown <- stateInfo$dailyBreakdown[[s]]
  cutoff <- stateInfo$cutoff[[s]]
  cutoff <- "2019-01-05"
  
  largeLineages <- clusterStatsMCC[order(-clusterStatsMCC$seqs)[1:min(100, nrow(clusterStatsMCC))], ]

  par(mar=c(5,10,3,7), cex.axis=0.7, cex.lab=0.8, mgp=c(2,0.75,0))
  plotLineageDurations(largeLineages, clusterSamplesMCC, startDate=startDate, endDate=endDate, cutoff=cutoff, orderby = "", state=state)
}
```

\clearpage

#Shannon Index

```{r shannon-index-initialize, eval=TRUE}
clusterAdm1 <- clusterSamplesMCC %>% mutate(adm1 = ifelse(adm1 == "Sachsen", "Saxony", adm1)) %>% mutate(adm1 = ifelse(adm1 == "Herzogenrath", "North Rhine-Westphalia", adm1)) %>% group_by(cluster, adm1) %>% dplyr::summarize(x=n()) %>% tidyr::spread(key=adm1, value=x, fill=0) %>% as.data.frame()
rownames(clusterAdm1) <- clusterAdm1$cluster
clusterAdm1 <- clusterAdm1 %>% dplyr::select(-cluster)
clusterAdm1IndexInClusterStatsMCC <- match(rownames(clusterAdm1), clusterStatsMCC$cluster)

clusterStatsMCC[clusterAdm1IndexInClusterStatsMCC[!is.na(clusterAdm1IndexInClusterStatsMCC)], "shannon.index"] <- diversity(clusterAdm1[!is.na(clusterAdm1IndexInClusterStatsMCC), ])

deCountyShannonIndex <- data.frame(county = colnames(clusterAdm1), "shannon.index" = diversity(t(clusterAdm1[!is.na(clusterAdm1IndexInClusterStatsMCC), ])))
# deCounty <- deCounty[!deCounty$county %in% c("NA"),]
# rownames(deCounty) <- deCounty$county
deCounty <- deCounty %>% left_join(deCountyShannonIndex, by = c("state" = "county"))

```


```{r shannon-index-lienage, eval=TRUE}

knitr::kable(clusterStatsMCC[order(-clusterStatsMCC$shannon.index)[1:20], c("cluster", "shannon.index", "seqs")], 
             col.names = c("Cluster",
                         "Shannon Index",
                         "No. Sequences"), row.names=FALSE, 
             caption = "Clusters with highest Shannon Index") 

data <- deCounty[order(-deCounty$shannon.index), c("state", "shannon.index")]
data[,2] = round(data[,2],2)

knitr::kable(data, 
             col.names = c("County",
                         "Shannon Index"), row.names=FALSE, 
             caption = "Counties with highest Shannon Index. Singletone clusters not included.") 


```


```{r shannon-index-map, fig.width=5, fig.height=4, eval=TRUE}

# germany <- raster::getData("GADM", country = "DEU", level = 1)
# germany.f <- fortify(germany, region = "CC_1")
# 
# mapNames <- germany$VARNAME_1
# mapNames[is.na(mapNames)] <- germany$NAME_1[is.na(mapNames)]
# mapNames[mapNames == "Baden-Württemberg"] <- "Baden-Wurttemberg"
# mapNames[mapNames == "Mecklenburg-West Pomerania"] <- "Mecklenburg-Western Pomerania"
# 
# germany$NAME_1_EN <- germany$NAME_1
# germany$NAME_1_EN[germany$NAME_1 == "Baden-Württemberg"] <- "Baden-Wurttemberg"
# germany$NAME_1_EN[germany$NAME_1 == "Mecklenburg-Vorpommern"] <- "Mecklenburg-Western Pomerania"
# germany$NAME_1_EN[germany$NAME_1 == "Bayern"] <- "Bavaria"
# germany$NAME_1_EN[germany$NAME_1 == "Hessen"] <- "Hesse"
# germany$NAME_1_EN[germany$NAME_1 == "Niedersachsen"] <- "Lower Saxony"
# germany$NAME_1_EN[germany$NAME_1 == "Nordrhein-Westfalen"] <- "North Rhine-Westphalia"
# germany$NAME_1_EN[germany$NAME_1 == "Rheinland-Pfalz"] <- "Rhineland-Palatinate"
# germany$NAME_1_EN[germany$NAME_1 == "Sachsen"] <- "Saxony"
# germany$NAME_1_EN[germany$NAME_1 == "Sachsen-Anhalt"] <- "Saxony-Anhalt"
# germany$NAME_1_EN[germany$NAME_1 == "Thüringen"] <- "Thuringia"
# 
# germany$value <- 0
# germany$value[match(deCounty$county, germany$NAME_1_EN)] <- deCounty$shannon.index
# 
# 
# germany.f$value <- germany$value[match(germany.f$id, germany$CC_1)]
# maxcase <- max(germany$value)
# col = "#FF8000"
# 
#   p <- ggplot() + 
#     geom_polygon(data = germany.f, aes(x = long, y = lat, group = group, fill = value), colour = "grey10")+
#     scale_fill_gradient(low = lighten(col, 1), high = col, space = "Lab", limits=c(3.35, maxcase),
#                         name = "Shannon index")+
#     # geom_point(data=starting_points, mapping=aes(x=long, y=lat), size=5, col=col) +
#     ggtitle("Shannon index of counties") +
#     theme(axis.line=element_blank(), axis.text.x=element_blank(),
#           axis.text.y=element_blank(), axis.ticks=element_blank(),
#           axis.title.x=element_blank(),
#           axis.title.y=element_blank(),
#           panel.background=element_blank(), panel.grid.major=element_blank(),
#           panel.border = element_rect(colour = "black", fill=NA, size=0.1),
#           panel.grid.minor=element_blank(), plot.background=element_blank())
#   print(p)

plot_on_map(deCounty$state, deCounty$shannon.index, title="Shannon index of states", legend_title = "Shannon Index", col = "#0000FF", min_value = min(deCounty$shannon.index) * 0.9, max_value = max(deCounty$shannon.index))

```
\clearpage

# First sequences
```{r first-sequence-init, fig.width=5, fig.height=5, eval=TRUE}
# only non-singletones

for (lsm in c(1, 10, 50, 100, 200, 250)) {
  for (firstCaseDistance in c(0, 1, 2)) {
    clusterFirstCases <- clusterSamplesMCC %>% filter(lineage_seqs > lsm & abs(lineage_oldest - decimal_date) < 0.0001 + firstCaseDistance/366) 
    clusterFirstCasesCount <- clusterFirstCases %>% group_by(cluster) %>% dplyr::summarise(cluster.first.case.count = n())
    clusterFirstCases <- clusterFirstCases %>% left_join(clusterFirstCasesCount, by=c("cluster" = "cluster"))
    clusterFirstCaseByCounty <- clusterFirstCases %>% filter(cluster.first.case.count <= 1000000) %>% group_by(adm1) %>% 
      dplyr::summarise(n = sum(1/cluster.first.case.count)) %>% 
      mutate(p =  round(n/sum(n) * 100, digits=1)) %>% arrange(desc(n))
    
    print(kable(clusterFirstCaseByCounty, caption = paste("First case count for lineages with size > ", lsm, "days after first case", firstCaseDistance)))
    
    plot_on_map(clusterFirstCaseByCounty$adm1[clusterFirstCaseByCounty$adm1 != "NA"], clusterFirstCaseByCounty$p[clusterFirstCaseByCounty$adm1 != "NA"], title=paste("Percentages of first cases of lineages", "lin size", lsm, "fcd", firstCaseDistance), legend_title = "Percent", col = "#FF0000", max_value = max(clusterFirstCaseByCounty$p[clusterFirstCaseByCounty$adm1 != "NA"]))
  }
  
}

# Remove duplicate in code:
lsm <- 1
firstCaseDistance <- 0
    clusterFirstCases <- clusterSamplesMCC %>% filter(lineage_seqs > lsm & abs(lineage_oldest - decimal_date) < 0.0001 + firstCaseDistance/366) 
    clusterFirstCasesCount <- clusterFirstCases %>% group_by(cluster) %>% dplyr::summarise(cluster.first.case.count = n())
    clusterFirstCases <- clusterFirstCases %>% left_join(clusterFirstCasesCount, by=c("cluster" = "cluster"))
    clusterFirstCaseByCounty <- clusterFirstCases %>% filter(cluster.first.case.count <= 1000000) %>% group_by(adm1) %>% 
      dplyr::summarise(n = sum(1/cluster.first.case.count)) %>% 
      mutate(p =  round(n/sum(n) * 100, digits=1)) %>% arrange(desc(n))

```


```{r}
#deCounty <- deCounty %>% dplyr::select(-first.case.count, -first.case.prob, -no.lineage, -no.lineage)

deCounty <- deCounty %>% left_join(clusterFirstCaseByCounty %>% dplyr::rename(first.case.count=n, first.case.prob=p), by=c("state"="adm1")) %>% 
  mutate(first.case.count = ifelse(is.na(first.case.count), 0, first.case.count), first.case.prob = ifelse(is.na(first.case.prob), 0, first.case.prob))

```

```{r first-sequence, fig.width=5, fig.height=5, eval=TRUE}

kable(clusterFirstCases %>% group_by(cluster) %>% dplyr::summarise(n = n()) %>% arrange(-n) %>% filter(n > 1) %>% left_join(clusterStatsMCC, by=c("cluster" = "cluster")) %>% dplyr::rename(no.first.case = n), caption="Clusters with more than one first case")

kable(clusterFirstCaseByCounty %>% full_join(deCounty %>% dplyr::select(state), by=c("adm1" = "state")) %>% mutate(n = ifelse(is.na(n), 0, n), p = ifelse(is.na(p), 0, p)) %>% arrange(-n), caption = "Number of first cases in each state")

# 
# germany$value <- 0
# germany$value[match(clusterFirstCaseByCounty$adm1[clusterFirstCaseByCounty$adm1 != "NA"], germany$NAME_1_EN)] <- clusterFirstCaseByCounty$p[clusterFirstCaseByCounty$adm1 != "NA"]
# 
# 
# germany.f$value <- germany$value[match(germany.f$id, germany$CC_1)]
# maxcase <- max(germany$value)
# col = "#FF0000"
# 
#   p <- ggplot() + 
#     geom_polygon(data = germany.f, aes(x = long, y = lat, group = group, fill = value), colour = "grey10")+
#     scale_fill_gradient(low = lighten(col, 1), high = col, space = "Lab", limits=c(0, maxcase),
#                         name = "Percent")+
#     # geom_point(data=starting_points, mapping=aes(x=long, y=lat), size=5, col=col) +
#     ggtitle("Percentages of first cases of lineages") +
#     theme(axis.line=element_blank(), axis.text.x=element_blank(),
#           axis.text.y=element_blank(), axis.ticks=element_blank(),
#           axis.title.x=element_blank(),
#           axis.title.y=element_blank(),
#           panel.background=element_blank(), panel.grid.major=element_blank(),
#           panel.border = element_rect(colour = "black", fill=NA, size=0.1),
#           panel.grid.minor=element_blank(), plot.background=element_blank())
#   print(p)

plot_on_map(clusterFirstCaseByCounty$adm1[clusterFirstCaseByCounty$adm1 != "NA"], clusterFirstCaseByCounty$p[clusterFirstCaseByCounty$adm1 != "NA"], title="Percentages of first cases of lineages", legend_title = "Percent", col = "#FF0000", max_value = max(clusterFirstCaseByCounty$p[clusterFirstCaseByCounty$adm1 != "NA"]))


```

# Correlation Coefficients


- Correlation coefficient between Lineage Shannon Index and number of sequences: `cor(clusterStatsMCC$shannon.index, clusterStatsMCC$seqs)`

```{r correlation-coefficient-statewise} 

  deCounty <- deCounty %>% left_join(clusterSamplesMCC %>% filter(lineage_seqs > 1) %>% dplyr::select(cluster, adm1) %>% mutate(adm1 = case_when(adm1 == "Sachsen" ~ "Saxony", adm1 == "Herzogenrath" ~ "North Rhine-Westphalia", TRUE ~ adm1)) %>% distinct() %>% group_by(adm1) %>% dplyr::summarise(no.lineage = n()), by=c("state" = "adm1"))

```

```{r}

data.cols <- c("shannon.index", "first.case.count", "no.lineage", "population",  "case", "seqs", "seq.rate")   

data.xyz <- data.frame("x" = character(), "y"=character(), "z"=numeric())
data <- matrix(NA, nrow = length(data.cols), ncol = length(data.cols), dimnames = list(data.cols, data.cols))
for (colIt in colnames(data)) {
  for (rowIt in rownames(data)) {
    data[rowIt, colIt] <- round(cor(deCounty[,rowIt], deCounty[,colIt]), 2)
    data.xyz <- rbind(data.xyz, data.frame(rowIt, colIt, data[rowIt, colIt]))
  }
}

colnames(data.xyz) <- c("x", "y", "z") 

kable(data)

ggplot(data = data.xyz, aes(x=x, y=y)) + geom_raster(aes(fill=z)) +   
  scale_fill_gradientn(colours=c("yellow", "white", "green"), limits=c(-1,1), breaks=c(-1,0,1)) +
  labs(x="Index", y="Index", z="Correlation coefficient", title="Correlation coefficient between indices for Germany states") +
  geom_text(aes(label = round(z, 2)), col = "grey30") +
  theme_bw() + 
  theme(axis.text.x=element_text(size=9, angle=0, vjust=0.3),
                     axis.text.y=element_text(size=9),
                     plot.title=element_text(size=11))

```

# Pangolin analysis

```{r}

clusterStatsMCC$pangolin <- gsub("_.*", "", clusterStatsMCC$cluster)

alpha           <- 0.7189865
beta            <- 28.91369
clusterStatsMCC$shift <- alpha + beta/clusterStatsMCC$seqs
clusterStatsMCC$tmrca_shifted <- clusterStatsMCC$tmrca - (clusterStatsMCC$shift/366)
clusterStatsMCC$tmrca_shifted_calendar <- as.Date(round_date(date_decimal(clusterStatsMCC$tmrca_shifted), unit = "day"))
clusterStatsMCC$detection_lag <- as.Date(round_date(date_decimal(clusterStatsMCC$oldest), unit = "day")) - clusterStatsMCC$tmrca_shifted_calendar


breaks <- seq(as.Date("2020-01-01"), as.Date("2021-06-01"), by="week")

for (lin in levels(as.factor(clusterStatsMCC$pangolin))) {
  # clusterStatsMCC %>% group_by(pangolin) %>% summarise()
  
  linClusters <- clusterStatsMCC %>% 
          filter(pangolin == lin & tmrca_calendar >= breaks[1] & tmrca_calendar < breaks[length(breaks)])
  
  tmrca_hist_small <- hist((linClusters %>% filter(seqs <= 10))$tmrca_calendar, plot=FALSE, breaks=breaks)
  tmrca_hist_med  <- hist((linClusters %>% filter(seqs  > 10))$tmrca_calendar, plot=FALSE, breaks=breaks)
  tmrca_hist_big  <- hist((linClusters %>% filter(seqs > 100))$tmrca_calendar, plot=FALSE, breaks=breaks)
  tmrca_hist_huge <- hist((linClusters %>% filter(seqs > 1000))$tmrca_calendar, plot=FALSE, breaks=breaks)
  
  tmrca_hist_breakdown <- data.frame(huge  = tmrca_hist_huge$counts,
                                     big   = tmrca_hist_big$counts,
                                     med   = tmrca_hist_med$counts,
                                     small = tmrca_hist_small$counts)

  
  dateFreqDistribution(t(tmrca_hist_breakdown), 
       breaks, plot.ci=FALSE,  barplot=TRUE, 
                         startDate = breaks[1], 
                         endDate = breaks[length(breaks)-1], 
                         col=mPal(unlist(ukPal), 0.75), border = "#000000", 
                         # ymax = max(rowSums(weeklyBreakdown$clustSizes)) + 2, 
                         ylab = "No. imported lineages",
       main = paste("TMRCA of pango lineage ", lin), ymax=20)

  
  
  
  
  tmrca_hist_small <- hist((linClusters %>% filter(seqs <= 10))$tmrca_shifted_calendar, plot=FALSE, breaks=breaks)
  tmrca_hist_med  <- hist((linClusters %>% filter(seqs  > 10))$tmrca_shifted_calendar, plot=FALSE, breaks=breaks)
  tmrca_hist_big  <- hist((linClusters %>% filter(seqs > 100))$tmrca_shifted_calendar, plot=FALSE, breaks=breaks)
  tmrca_hist_huge <- hist((linClusters %>% filter(seqs > 1000))$tmrca_shifted_calendar, plot=FALSE, breaks=breaks)
  
  tmrca_hist_breakdown <- data.frame(huge  = tmrca_hist_huge$counts,
                                     big   = tmrca_hist_big$counts,
                                     med   = tmrca_hist_med$counts,
                                     small = tmrca_hist_small$counts)

  
  dateFreqDistribution(t(tmrca_hist_breakdown), 
       breaks, plot.ci=FALSE,  barplot=TRUE, 
                         startDate = breaks[1], 
                         endDate = breaks[length(breaks)-1], 
                         col=mPal(unlist(ukPal), 0.75), border = "#000000", 
                         # ymax = max(rowSums(weeklyBreakdown$clustSizes)) + 2, 
                         ylab = "No. imported lineages",
       main = paste("Importation of pango lineage ", lin), ymax=20)

}



```

\clearpage

# Session info

```{r sessionInfo, results='markup'}
    sessionInfo()
```
